---
title:                "Використання асоціативних масивів"
aliases:
- /uk/arduino/using-associative-arrays/
date:                  2024-01-30T19:10:32.600402-07:00
model:                 gpt-4-0125-preview
simple_title:         "Використання асоціативних масивів"

tag:                  "Data Structures"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/uk/arduino/using-associative-arrays.md"
changelog:
  - 2024-01-30, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## Що і чому?
У світі Arduino асоціативні масиви дозволяють зіставляти ключі зі значеннями, приблизно так само, як ви б зіставляли шкарпетки з їхніми парами. Вони стають в нагоді, коли вам потрібно зберігати та отримувати дані, використовуючи описові назви, роблячи ваш код чистішим та набагато зрозумілішим.

## Як це зробити:
Суворо кажучи, Arduino не має вбудованої підтримки асоціативних масивів, як це можна знайти в мовах вищого рівня. Але, не бійтесь. Ми можемо використати структури та масиви, щоб імітувати цю функціональність. Ось простий приклад створення базового "асоціативного масиву" для зберігання та доступу до температур у різних містах.

Спочатку, визначимо структуру, щоб зберігати місто (ключ) та його температуру (значення):

```cpp
struct CityTemperature {
  String city;
  float temperature;
};
```

Далі, ініціалізуємо масив об'єктів `CityTemperature`:

```cpp
CityTemperature temperatures[] = {
  {"New York", 19.5},
  {"Los Angeles", 22.0},
  {"Chicago", 17.0}
};
```

Ось як ви можете отримати доступ до температури конкретного міста та вивести її:

```cpp
void setup() {
  Serial.begin(9600);
  for(int i = 0; i < 3; i++) {
    if(temperatures[i].city == "Los Angeles") {
      Serial.print("Температура в Лос-Анджелесі: ");
      Serial.println(temperatures[i].temperature);
    }
  }
}

void loop() {
  // Тут поки що нічого немає.
}
```

Запуск цього коду дасть вам наступний результат:

```
Температура в Лос-Анджелесі: 22.0
```

## Поглиблене вивчення
Історично, мови програмування такі як C та C++ (з яких походить синтаксис Arduino) не мали вбудованих асоціативних масивів, що призводило до використання обхідних шляхів, як показано вище. Такий підхід є відносно простим, але погано масштабується при збільшенні розміру даних через його час пошуку O(n).

Мови, такі як Python, пропонують словники, а JavaScript має об'єкти для цієї цілі, обидва з яких набагато ефективніші для керування парами ключ-значення. У Arduino, коли продуктивність і ефективність стають критичними, розробники можуть вибирати більш спеціалізовані структури даних, як-от хеш-таблиці, реалізовані через бібліотеки.

Хоча Arduino нативно не підтримує асоціативні масиви, спільнота розробила бібліотеки, такі як `HashMap`, які можна додати до вашого проекту, щоб забезпечити подібну функціональність з кращою продуктивністю, ніж підхід "зроби сам". Ці бібліотеки, як правило, пропонують більш елегантні та ефективні способи керування асоціативними масивами, особливо для більш складних проектів.
