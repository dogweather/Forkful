---
date: 2024-01-26 00:49:56.181443-07:00
description: "\u041E\u0431\u0440\u043E\u0431\u043A\u0430 \u043F\u043E\u043C\u0438\u043B\
  \u043E\u043A \u0443 Bash \u0441\u043A\u0440\u0438\u043F\u0442\u0430\u0445 \u043F\
  \u043E\u043B\u044F\u0433\u0430\u0454 \u0443 \u043F\u0435\u0440\u0435\u0434\u0431\
  \u0430\u0447\u0435\u043D\u043D\u0456 \u0441\u0438\u0442\u0443\u0430\u0446\u0456\u0439\
  , \u043A\u043E\u043B\u0438 \u0449\u043E\u0441\u044C \u043C\u043E\u0436\u0435 \u043F\
  \u0456\u0442\u0438 \u043D\u0435 \u0442\u0430\u043A, \u0442\u0430 \u0433\u0440\u0430\
  \u0446\u0456\u043E\u0437\u043D\u043E\u043C\u0443 \u0457\u0445 \u0432\u0438\u0440\
  \u0456\u0448\u0435\u043D\u043D\u0456. \u0427\u043E\u043C\u0443? \u0426\u0435 \u0440\
  \u043E\u0431\u0438\u0442\u044C \u0432\u0430\u0448 \u0441\u043A\u0440\u0438\u043F\
  \u0442\u2026"
lastmod: '2024-03-13T22:44:49.590287-06:00'
model: gpt-4-1106-preview
summary: "\u041E\u0431\u0440\u043E\u0431\u043A\u0430 \u043F\u043E\u043C\u0438\u043B\
  \u043E\u043A \u0443 Bash \u0441\u043A\u0440\u0438\u043F\u0442\u0430\u0445 \u043F\
  \u043E\u043B\u044F\u0433\u0430\u0454 \u0443 \u043F\u0435\u0440\u0435\u0434\u0431\
  \u0430\u0447\u0435\u043D\u043D\u0456 \u0441\u0438\u0442\u0443\u0430\u0446\u0456\u0439\
  , \u043A\u043E\u043B\u0438 \u0449\u043E\u0441\u044C \u043C\u043E\u0436\u0435 \u043F\
  \u0456\u0442\u0438 \u043D\u0435 \u0442\u0430\u043A, \u0442\u0430 \u0433\u0440\u0430\
  \u0446\u0456\u043E\u0437\u043D\u043E\u043C\u0443 \u0457\u0445 \u0432\u0438\u0440\
  \u0456\u0448\u0435\u043D\u043D\u0456."
title: "\u041E\u0431\u0440\u043E\u0431\u043A\u0430 \u043F\u043E\u043C\u0438\u043B\u043E\
  \u043A"
weight: 16
---

## Як це зробити:
```Bash
#!/bin/bash

# Перенаправлення stderr у файл
grep "something" file.txt 2> errors.log

# Обробка помилок із використанням статусів виходу
if ! grep "something" file.txt; then
    echo "Ой, щось пішло не так під час пошуку 'something'."
    exit 1
fi

# Використання trap для очищення перед виходом зі скрипта через помилку
cleanup() {
  echo "Очищення тимчасових файлів..."
  rm temp_*
}

trap cleanup ERR

# навмисна помилка: файл не існує
cat temp_file.txt
```

Приклад виводу при виникненні помилки:

```
Очищення тимчасових файлів...
cat: temp_file.txt: Такого файлу чи каталогу немає
```

## Поглиблено
Обробка помилок у скриптах Bash сягає корінням до початків Unix shell, де надійні та робочі скрипти були (і залишаються) важливими для системного адміністрування та автоматизації. Традиційно помилки в Bash обробляються шляхом перевірки статусу виходу команди, який за звичаєм повертає 0 у випадку успіху та ненульове значення при помилці.

Bash представив команду `trap` як вбудовану, дозволяючи користувачам вказувати команди для запуску за різних сигналів або виходів із скрипта. Це корисно для завдань очищення або як задній запобіжник механізму обробки помилок.

Є також команда `set`, яка може змінити поведінку Bash при помилках. Наприклад, `set -e` змусить скрипт негайно вийти, якщо будь-яка команда завершиться з ненульовим статусом, шлях до швидкого виявлення та запобігання каскадних помилок.

Альтернативи вбудованій обробці помилок в Bash включають явну перевірку наявності файлів, використання підстановки команд або навіть написання власних функцій для більш деталізованої обробки помилок.

Хоча ретельна обробка помилок часом здається зайвою для маленьких скриптів, це практика, що може зекономити багато часу при налагодженні та запобігти непередбачуваній поведінці і для вас, і для користувачів.

## Дивіться також
- Bash Manual про параметри оболонки: https://www.gnu.org/software/bash/manual/bash.html#Shell-Parameters
- Розділ Посібника з поглибленого скриптингу Bash про обробку помилок: https://www.tldp.org/LDP/abs/html/exit-status.html
- Поглиблений посібник по `trap`: https://mywiki.wooledge.org/SignalTrap

Пам'ятайте, скриптинг - це мистецтво, і як ви обробляєте помилки та спотикання, може зробити ваш твір більш стійким. Успішного скриптингу!
