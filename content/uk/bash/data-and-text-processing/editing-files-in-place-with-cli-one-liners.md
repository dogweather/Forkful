---
title:                "Редагування файлів безпосередньо за допомогою командного рядка одним рядком"
aliases:
- uk/bash/editing-files-in-place-with-cli-one-liners.md
date:                  2024-01-27T16:22:15.888483-07:00
model:                 gpt-4-0125-preview
simple_title:         "Редагування файлів безпосередньо за допомогою командного рядка одним рядком"

tag:                  "Data and Text Processing"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/uk/bash/editing-files-in-place-with-cli-one-liners.md"
---

{{< edit_this_page >}}

## Що і чому?

Уявіть, що ви щойно дізналися, що потрібно зробити пакетне оновлення кількох конфігураційних файлів, що знаходяться на вашому сервері. Ви могли б відкрити кожен файл, внести зміни вручну та зберегти їх. Або ж ви можете виконати редагування на місці безпосередньо з вашого інтерфейсу командного рядка (CLI), навичка, яка економить час, зменшує кількість помилок і автоматизує повторювані завдання. Ця техніка особливо корисна для системних оновлень, виправлень або масових модифікацій, де ручне редагування може бути непрактичним або схильним до помилок.

## Як:

Коли справа доходить до редагування файлів на місці за допомогою Bash, два видатні інструменти вступають у гру: `sed` і `awk`. Давайте дослідимо, як використовувати ці потужні утиліти з деякими прикладами коду.

### Використання `sed` для простої заміни тексту

Наступна команда замінює перше входження "text1" на "text2" у `file.txt`:

```Bash
sed -i 's/text1/text2/' file.txt
```

Для глобальної заміни (усі входження) додайте `g` наприкінці:

```Bash
sed -i 's/text1/text2/g' file.txt
```

Для модифікації кількох файлів одночасно:

```Bash
sed -i 's/text1/text2/g' file1.txt file2.txt file3.txt
```

### Використання `awk` для складніших маніпуляцій

`awk` - ще один інструмент, який вирізняється своїми програмними можливостями, особливо корисний для обробки тексту, що включає дані, базовані на полях.

Зміна другого поля кожного рядка на `newValue` у `data.csv`, розділеному комами:

```Bash
awk -i inplace -F, '{$2="newValue"; print $0}' OFS=, data.csv
```

### Створення резервної копії перед стрибком

Одна практична порада: завжди створюйте резервну копію перед редагуванням на місці. `sed` полегшує це за допомогою опції `-i`, за якою слідує суфікс для створення резервної копії.

```Bash
sed -i.bak 's/text1/text2/g' file.txt
```

Ця команда створює резервну копію оригінального `file.txt` як `file.txt.bak` перед виконанням заміни.

## Поглиблений огляд

Можливість редагувати файли безпосередньо з командного рядка виникла як природний розвиток філософії Unix: надання користувачам можливості ефективно керувати та маніпулювати даними з мінімумом натискань клавіш. Проте, ця могутність має свої підводні камені.

### Історичний контекст

Інструменти Unix, такі як `sed` і `awk`, існують з ранніх днів Unix, створені як частина його філософії інструментарію, зосередженої на спеціалізованих, компонованих командах. Їх включення до арсеналу Unix було відповіддю на потребу в ефективній обробці тексту в ландшафті, домінованому інтерфейсами командного рядка.

### Альтернативи

Хоча `sed` і `awk` є могутніми, вони не єдина опція. Perl і Python, наприклад, мають опції командного рядка (`-p` і `-i` відповідно), які дозволяють аналогічні можливості редагування на місці з аргументовано більш читабельним синтаксисом для складних операцій.

```Bash
perl -pi -e 's/text1/text2/g' file.txt
```

```Bash
python -c "import fileinput, sys; [sys.stdout.write(line.replace('text1', 'text2')) for line in fileinput.input(files='file.txt', inplace=True)]"
```

Кожна альтернатива має свої сильні сторони: неймовірні можливості однорядкових команд Perl та більш доступний синтаксис Python для тих, хто не глибоко занурений в інструменти обробки тексту Unix.

### Деталі реалізації

Редагування на місці не є справді "на місці" у технічному сенсі. Як `sed -i`, так і `awk -i inplace` працюють, створюючи тимчасовий файл, в якому зберігається оброблений вивід перед заміною оригінального файлу. Цей підхід забезпечує, що файл не буде пошкоджений у разі переривання процесу. Наслідки переважно стосуються ресурсів та дозволів: ви повинні мати достатньо дискового простору для тимчасового файлу та дозволи на створення файлів у директорії вашого цільового файлу.

Попри могутність, команди редагування на місці слід використовувати з обережністю. Неправильно розміщений регекс може призвести до втрати даних, підкреслюючи важливість резервних копій. Незважаючи на потенційні пастки, володіння цими командами може значно покращити вашу здатність виконувати швидкі, ефективні модифікації файлів безпосередньо з командного рядка, втілюючи філософію Unix про використання простих, могутніх інструментів для виконання складних завдань.
