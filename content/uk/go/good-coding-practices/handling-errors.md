---
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 17:58:44.039944-07:00
description: "\u041E\u0431\u0440\u043E\u0431\u043A\u0430 \u043F\u043E\u043C\u0438\u043B\
  \u043E\u043A \u0432 Go \u043F\u043E\u043B\u044F\u0433\u0430\u0454 \u0432 \u0440\u043E\
  \u0437\u043F\u0456\u0437\u043D\u0430\u0432\u0430\u043D\u043D\u0456 \u0442\u0430\
  \ \u0440\u0435\u0430\u0433\u0443\u0432\u0430\u043D\u043D\u0456 \u043D\u0430 \u0443\
  \u043C\u043E\u0432\u0438 \u043F\u043E\u043C\u0438\u043B\u043E\u043A \u0443 \u0432\
  \u0430\u0448\u0456\u0439 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u0456. \u041F\
  \u0440\u043E\u0433\u0440\u0430\u043C\u0456\u0441\u0442\u0438 \u0437\u0430\u0439\u043C\
  \u0430\u044E\u0442\u044C\u0441\u044F \u043E\u0431\u0440\u043E\u0431\u043A\u043E\u044E\
  \ \u043F\u043E\u043C\u0438\u043B\u043E\u043A, \u0449\u043E\u0431 \u0437\u0430\u0431\
  \u0435\u0437\u043F\u0435\u0447\u0438\u0442\u0438\u2026"
lastmod: '2024-03-13T22:44:48.448294-06:00'
model: gpt-4-0125-preview
summary: "\u041E\u0431\u0440\u043E\u0431\u043A\u0430 \u043F\u043E\u043C\u0438\u043B\
  \u043E\u043A \u0432 Go \u043F\u043E\u043B\u044F\u0433\u0430\u0454 \u0432 \u0440\u043E\
  \u0437\u043F\u0456\u0437\u043D\u0430\u0432\u0430\u043D\u043D\u0456 \u0442\u0430\
  \ \u0440\u0435\u0430\u0433\u0443\u0432\u0430\u043D\u043D\u0456 \u043D\u0430 \u0443\
  \u043C\u043E\u0432\u0438 \u043F\u043E\u043C\u0438\u043B\u043E\u043A \u0443 \u0432\
  \u0430\u0448\u0456\u0439 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u0456."
title: "\u041E\u0431\u0440\u043E\u0431\u043A\u0430 \u043F\u043E\u043C\u0438\u043B\u043E\
  \u043A"
weight: 16
---

## Як:
В Go обробка помилок явно керується за допомогою типу `error`. Функції, які можуть зазнати невдачі, повертають помилку як своє останнє значення повернення. Перевірка, чи це значення помилки є `nil`, скаже вам, чи сталася помилка.

```go
package main

import (
    "errors"
    "fmt"
)

func Compute(value int) (int, error) {
    if value > 100 {
        return 0, errors.New("значення має бути 100 або менше")
    }
    return value * 2, nil
}

func main() {
    result, err := Compute(150)
    if err != nil {
        fmt.Println("Помилка:", err)
    } else {
        fmt.Println("Результат:", result)
    }
    
    // Граційна обробка помилки
    anotherResult, anotherErr := Compute(50)
    if anotherErr != nil {
        fmt.Println("Помилка:", anotherErr)
    } else {
        fmt.Println("Результат:", anotherResult)
    }
}
```

Приклад виводу для наведеного вище коду:
```
Помилка: значення має бути 100 або менше
Результат: 100
```

У цьому прикладі, функція `Compute` або повертає обчислене значення, або помилку. Викликуюча сторона обробляє помилку, перевіряючи, що `err` не є `nil`.

## Поглиблений аналіз
Підхід Go до обробки помилок навмисно простий і типобезпечний, вимагаючи явних перевірок на помилки. Цей концепт контрастує з обробкою помилок на основі виключень, яка спостерігається в мовах на кшталт Java і Python, де помилки розповсюджуються вгору стеку викликів, доки їх не перехопить обробник виключень. Команда Go аргументує, що явне оброблення помилок призводить до чіткішого та більш надійного коду, оскільки це змушує програмістів негайно адресувати помилки там, де вони виникають.

Однак, деякі критики зазначають, що цей шаблон може призвести до надмірно деталізованого коду, особливо у складних функціях з багатьма операціями, схильними до помилок. У відповідь на це, новіші версії Go ввели більш витончені функції обробки помилок, такі як обгортання помилок, що робить легшим надання контексту помилці без втрати оригінальної інформації про помилку. Спільнота також бачила пропозиції щодо нових механізмів обробки помилок, таких як перевірка/обробка, хоча ці обговорення залишаються актуальними станом на мій останній оновлення.

Філософія обробки помилок в Go підкреслює розуміння та планування помилок як частини нормального потоку програми. Цей підхід спонукає до розробки більш стійкого та передбачуваного програмного забезпечення, хоча й потенційно збільшує кількість шаблонного коду. Існують альтернативні шаблони та бібліотеки для спрощення обробки помилок у особливо складних випадках, але вбудований тип `error` залишається основою обробки помилок у мові.
