---
aliases:
- /uk/go/finding-the-length-of-a-string/
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 17:57:15.670355-07:00
description: "\u0417\u043D\u0430\u0445\u043E\u0434\u0436\u0435\u043D\u043D\u044F \u0434\
  \u043E\u0432\u0436\u0438\u043D\u0438 \u0440\u044F\u0434\u043A\u0430 \u0432 Go \u043F\
  \u043E\u043B\u044F\u0433\u0430\u0454 \u0443 \u0432\u0438\u0437\u043D\u0430\u0447\
  \u0435\u043D\u043D\u0456 \u043A\u0456\u043B\u044C\u043A\u043E\u0441\u0442\u0456\
  \ \u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432, \u044F\u043A\u0456 \u0432\u0456\
  \u043D \u043C\u0456\u0441\u0442\u0438\u0442\u044C. \u041F\u0440\u043E\u0433\u0440\
  \u0430\u043C\u0456\u0441\u0442\u0438 \u0440\u0435\u0433\u0443\u043B\u044F\u0440\u043D\
  \u043E \u0432\u0438\u043A\u043E\u043D\u0443\u044E\u0442\u044C \u0446\u044E \u043E\
  \u043F\u0435\u0440\u0430\u0446\u0456\u044E \u0434\u043B\u044F \u0435\u0444\u0435\
  \u043A\u0442\u0438\u0432\u043D\u043E\u0457\u2026"
lastmod: 2024-02-18 23:08:59.677520
model: gpt-4-0125-preview
summary: "\u0417\u043D\u0430\u0445\u043E\u0434\u0436\u0435\u043D\u043D\u044F \u0434\
  \u043E\u0432\u0436\u0438\u043D\u0438 \u0440\u044F\u0434\u043A\u0430 \u0432 Go \u043F\
  \u043E\u043B\u044F\u0433\u0430\u0454 \u0443 \u0432\u0438\u0437\u043D\u0430\u0447\
  \u0435\u043D\u043D\u0456 \u043A\u0456\u043B\u044C\u043A\u043E\u0441\u0442\u0456\
  \ \u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432, \u044F\u043A\u0456 \u0432\u0456\
  \u043D \u043C\u0456\u0441\u0442\u0438\u0442\u044C. \u041F\u0440\u043E\u0433\u0440\
  \u0430\u043C\u0456\u0441\u0442\u0438 \u0440\u0435\u0433\u0443\u043B\u044F\u0440\u043D\
  \u043E \u0432\u0438\u043A\u043E\u043D\u0443\u044E\u0442\u044C \u0446\u044E \u043E\
  \u043F\u0435\u0440\u0430\u0446\u0456\u044E \u0434\u043B\u044F \u0435\u0444\u0435\
  \u043A\u0442\u0438\u0432\u043D\u043E\u0457\u2026"
title: "\u0417\u043D\u0430\u0445\u043E\u0434\u0436\u0435\u043D\u043D\u044F \u0434\u043E\
  \u0432\u0436\u0438\u043D\u0438 \u0440\u044F\u0434\u043A\u0430"
---

{{< edit_this_page >}}

## Що і чому?
Знаходження довжини рядка в Go полягає у визначенні кількості символів, які він містить. Програмісти регулярно виконують цю операцію для ефективної маніпуляції з рядками, будь то для валідації, витягу підрядків або просто для накладення обмежень на користувацькі введення.

## Як:
В Go рядки розглядаються як незмінні послідовності байтів. Ви можете знайти довжину рядка, використовуючи вбудовану функцію `len()`, яка повертає кількість байтів, а не обов'язково кількість символів. Ось як це використовувати:

```go
package main

import (
	"fmt"
	"unicode/utf8"
)

func main() {
	// Використання len() для знаходження довжини у байтах
	str := "Hello, 世界"
	byteLength := len(str)
	fmt.Println("Довжина у байтах:", byteLength) // Вивід: Довжина у байтах: 13

	// Для точного отримання кількості символів або рун в рядку
	runeLength := utf8.RuneCountInString(str)
	fmt.Println("Довжина рун:", runeLength) // Вивід: Довжина рун: 9
}
```
Перший метод використання `len()` може не завжди давати очікуваний результат, оскільки він рахує байти. Для рядків, які містять не-ASCII символи (наприклад, "世界"), замість цього слід використовувати `RuneCountInString` з пакету `unicode/utf8` для точного підрахунку Unicode кодових пунктів.

## Поглиблений огляд
До Go 1 не було чіткої відмежування для обробки рядків як послідовностей байтів проти послідовностей символів. Після Go 1, прийняття UTF-8 як стандартної схеми кодування для рядків зажадало більш чіткого підходу. Функція `len()` чудово працює для ASCII рядків, де символи представлені в одному байті. Однак, як Go програми стали більш глобальними і потреба підтримувати безліч мов і наборів символів виросла, спрощений підхід функції `len()` показав свої обмеження.

Введення і використання `utf8.RuneCountInString()` відповідає на ці обмеження, надаючи спосіб для точного підрахунку Unicode символів (рун в термінології Go). Цей метод забезпечує, що обчислення довжини незалежне від конкретики кодування UTF-8, де символи можуть займати кілька байтів.

Альтернативний підхід для перетину та маніпулювання рядками, більш узгоджений з етосом конкурентності та ефективності Go, може полягати в тому, щоб розглядати рядки як розрізи рун. Однак, цей метод потребує кроку перетворення і не відразу вирішує всі тонкощі Unicode (напр., комбіновані символи).

Підсумовуючи, хоча `len()` підходить для виміру довжини в байтах і ефективний для ASCII тексту, `utf8.RuneCountInString()` є більш надійним вибором для глобально сумісного застосування. Тим не менш, розробникам рекомендується зрозуміти компроміси в продуктивності та використанні пам'яті, які ці вибори передбачають.
