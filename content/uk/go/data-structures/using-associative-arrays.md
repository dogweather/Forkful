---
title:                "Використання асоціативних масивів"
aliases:
- /uk/go/using-associative-arrays/
date:                  2024-02-03T18:11:29.550712-07:00
model:                 gpt-4-0125-preview
simple_title:         "Використання асоціативних масивів"
tag:                  "Data Structures"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/uk/go/using-associative-arrays.md"
changelog:
  - 2024-02-03, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## Що та Чому?

Асоціативні масиви, відомі в Go як карти (maps), дозволяють зберігати пари "ключ-значення", де кожен унікальний ключ відображається на значення. Програмісти використовують карти для ефективного отримання, модифікації даних та для підтримки колекції елементів, до яких можна швидко отримати доступ, використовуючи унікальні ключі.

## Як:

Створення та ініціалізація карти в Go може бути здійснена різними способами. Ось основний приклад для початку:

```go
package main

import "fmt"

func main() {
    // Оголошення та ініціалізація карти
    colors := map[string]string{
        "red":   "#FF0000",
        "green": "#00FF00",
        "blue":  "#0000FF",
    }

    fmt.Println(colors)
    // Вивід: map[blue:#0000FF green:#00FF00 red:#FF0000]
}
```

Щоб додати або оновити елементи, вам потрібно присвоїти значення ключу таким чином:

```go
colors["white"] = "#FFFFFF"
fmt.Println(colors)
// Вивід: map[blue:#0000FF green:#00FF00 red:#FF0000 white:#FFFFFF]
```

Отримання значення за ключем є простим:

```go
fmt.Println("Шістнадцятковий код червоного:", colors["red"])
// Вивід: Шістнадцятковий код червоного: #FF0000
```

Щоб видалити елемент, використовуйте функцію `delete`:

```go
delete(colors, "red")
fmt.Println(colors)
// Вивід: map[blue:#0000FF green:#00FF00 white:#FFFFFF]
```

Ітерація по карті виконується за допомогою циклу for:

```go
for color, hex := range colors {
    fmt.Printf("Ключ: %s Значення: %s\n", color, hex)
}
```

Пам'ятайте, карти в Go не мають порядку. Порядок ітерації не гарантовано.

## Поглиблено

В Go карти реалізовані як хеш-таблиці. Кожен запис у карті складається з двох елементів: ключа та значення. Ключ хешується для зберігання запису, що дозволяє виконувати операції за сталу часу для невеликого набору даних і середню часову складність O(1) з належним хешуванням, яка може знизитися до O(n) у найгіршому випадку при багатьох хеш-колізіях.

Важлива примітка для нових програмістів Go полягає в тому, що типи карт є типами посилань. Це означає, коли ви передаєте карту до функції, будь-які зміни, зроблені в карті в межах цієї функції, видимі для викликаючого коду. Це відрізняється, наприклад, від передачі структури функції, де структура копіюється, якщо не передана за вказівником.

Хоча карти неймовірно універсальні та ефективні для більшості випадків використання асоціативних масивів, у додатках, критично важливих до продуктивності, може бути корисно використовувати структури даних з більш передбачуваними характеристиками продуктивності, особливо якщо розподіл ключів може спричинити часті колізії.

Іншою альтернативою для розгляду є `sync.Map`, доступний починаючи з Go 1.9, призначений для випадків використання, коли ключі записуються один раз, але читаються багато разів, пропонуючи поліпшення ефективності в цих сценаріях. Однак для традиційних програм Go звичайне використання карт є ідіоматичним і часто рекомендованим підходом за його простоту та пряму підтримку в мові.
