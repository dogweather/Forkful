---
title:                "Генерація випадкових чисел"
date:                  2024-02-03T17:58:12.384494-07:00
model:                 gpt-4-0125-preview
simple_title:         "Генерація випадкових чисел"
tag:                  "Numbers"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/uk/go/generating-random-numbers.md"
changelog:
  - 2024-02-03, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## Що і чому?

Генерація випадкових чисел у програмуванні стосується створення послідовності чисел, яку не можна розумно передбачити краще, ніж на вгад. Програмісти роблять це з безлічі причин, включаючи симуляції, ігри та застосунки безпеки, де непередбачуваність є ключем до функціональності або секретності.

## Як це зробити:

У Go випадкові числа генеруються за допомогою пакета `math/rand` для псевдовипадкових чисел або `crypto/rand` для криптографічно стійких псевдовипадкових чисел. Давайте розглянемо обидва.

### Використання `math/rand` для Псевдовипадкових Чисел

Спочатку імпортуйте пакет `math/rand` та пакет `time` для ініціалізації генератора. Ініціалізація забезпечує отримання різної послідовності чисел при кожному запуску.

```go
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func main() {
	rand.Seed(time.Now().UnixNano())
	fmt.Println("Випадкове число:", rand.Intn(100)) // Генерує число між 0 і 99
}
```

Приклад виводу: `Випадкове число: 42`

### Використання `crypto/rand` для Криптографічно Стійких Псевдовипадкових Чисел

Для додаткових застосунків, чутливих до безпеки, підходить пакет `crypto/rand`, оскільки він генерує випадкові числа, які важко передбачити, роблячи їх придатними для криптографічних операцій.

```go
package main

import (
	"crypto/rand"
	"fmt"
	"math/big"
)

func main() {
	n, _ := rand.Int(rand.Reader, big.NewInt(100))
	fmt.Println("Безпечне випадкове число:", n)
}
```

Приклад виводу: `Безпечне випадкове число: 81`

## Поглиблений Аналіз

Основна відмінність між пакетами `math/rand` та `crypto/rand` у Go походить від їхнього джерела ентропії та призначених сфер застосування. `math/rand` генерує псевдовипадкові числа на основі початкової ініціалізації; тобто послідовність детермінована та може бути передбачена, якщо відома ініціалізація. Це підходить для сценаріїв, де ключовим є висока продуктивність, а не абсолютна непередбачуваність, як-от симуляції або ігри.

З іншого боку, `crypto/rand` отримує випадковість з базової операційної системи, що робить його придатним для криптографічних використань, де непередбачуваність є вирішальною. Однак, це йде за рахунок продуктивності та складності в обігу чисел, які він генерує (наприклад, з обробкою типу `*big.Int` для цілих чисел).

Історично, поняття генерації випадкових чисел у комп'ютерах завжди танцювало на межі справжнього "випадковості", з ранніми системами, що сильно покладались на детерміновані алгоритми, які імітували випадковість. Як розвивалися комп'ютери, так само еволюціонували ці алгоритми, включаючи більш витончені джерела ентропії з їхнього оточення.

Незважаючи на ці досягнення, пошук ідеальної випадковості в обчисленнях принципово парадоксальний, враховуючи детермінований характер самого комп'ютера. Це є причиною, через яку для більшості застосунків, де прогнозованість могла б бути шкідливою, криптографічно стійкі псевдовипадкові числа з джерел, подібних до `crypto/rand`, є кращим варіантом, незважаючи на їх надлишок.

По суті, підхід Go з двома окремими пакетами для генерації випадкових чисел елегантно вирішує компроміс між продуктивністю та безпекою, дозволяючи розробникам вибирати залежно від їхніх конкретних потреб.
