---
aliases:
- /uk/rust/removing-quotes-from-a-string/
date: 2024-01-26 03:43:21.708049-07:00
description: "\u0412\u0438\u0434\u0430\u043B\u0435\u043D\u043D\u044F \u043B\u0430\u043F\
  \u043E\u043A \u0437 \u0440\u044F\u0434\u043A\u0430 \u0432 Rust \u043F\u043E\u043B\
  \u044F\u0433\u0430\u0454 \u0432 \u0443\u0441\u0443\u043D\u0435\u043D\u043D\u0456\
  \ \u0437\u0430\u0439\u0432\u0438\u0445 \u0441\u0438\u043C\u0432\u043E\u043B\u0456\
  \u0432 \u043B\u0430\u043F\u043E\u043A, \u044F\u043A\u0456 \u043C\u043E\u0436\u0443\
  \u0442\u044C \u0431\u0443\u0442\u0438 \u0434\u043E\u0434\u0430\u043D\u0456 \u043D\
  \u0430\u0432\u043A\u043E\u043B\u043E \u0432\u0430\u0448\u043E\u0433\u043E \u0442\
  \u0435\u043A\u0441\u0442\u043E\u0432\u043E\u0433\u043E \u0434\u0430\u043D\u0438\u0445\
  . \u041F\u0440\u043E\u0433\u0440\u0430\u043C\u0456\u0441\u0442\u0438 \u0440\u043E\
  \u0431\u043B\u044F\u0442\u044C \u0446\u0435,\u2026"
lastmod: 2024-02-18 23:08:59.963430
model: gpt-4-0125-preview
summary: "\u0412\u0438\u0434\u0430\u043B\u0435\u043D\u043D\u044F \u043B\u0430\u043F\
  \u043E\u043A \u0437 \u0440\u044F\u0434\u043A\u0430 \u0432 Rust \u043F\u043E\u043B\
  \u044F\u0433\u0430\u0454 \u0432 \u0443\u0441\u0443\u043D\u0435\u043D\u043D\u0456\
  \ \u0437\u0430\u0439\u0432\u0438\u0445 \u0441\u0438\u043C\u0432\u043E\u043B\u0456\
  \u0432 \u043B\u0430\u043F\u043E\u043A, \u044F\u043A\u0456 \u043C\u043E\u0436\u0443\
  \u0442\u044C \u0431\u0443\u0442\u0438 \u0434\u043E\u0434\u0430\u043D\u0456 \u043D\
  \u0430\u0432\u043A\u043E\u043B\u043E \u0432\u0430\u0448\u043E\u0433\u043E \u0442\
  \u0435\u043A\u0441\u0442\u043E\u0432\u043E\u0433\u043E \u0434\u0430\u043D\u0438\u0445\
  . \u041F\u0440\u043E\u0433\u0440\u0430\u043C\u0456\u0441\u0442\u0438 \u0440\u043E\
  \u0431\u043B\u044F\u0442\u044C \u0446\u0435,\u2026"
title: "\u0412\u0438\u0434\u0430\u043B\u0435\u043D\u043D\u044F \u043B\u0430\u043F\u043E\
  \u043A \u0437\u0456 \u0441\u0442\u0440\u043E\u043A\u0438"
---

{{< edit_this_page >}}

## Що і чому?

Видалення лапок з рядка в Rust полягає в усуненні зайвих символів лапок, які можуть бути додані навколо вашого текстового даних. Програмісти роблять це, коли їм потрібно очистити або нормалізувати рядки, можливо, після аналізу даних з файлу, або коли вони готують їх до іншого формату, де лапки можуть бути проблематичними або зайвими.

## Як це зробити:

```Rust
fn remove_quotes(s: &str) -> String {
    s.trim_matches(|c| c == '\"' || c == '\'').to_string()
}

fn main() {
    let quoted_str = "\"Привіт, Rustaceans!\"";
    let cleaned_str = remove_quotes(quoted_str);
    println!("{}", cleaned_str);
    // Вивід: Привіт, Rustaceans!
}
```

Іноді у вас може бути рядок із змішаними лапками, як ось тут:

```Rust
fn main() {
    let mixed_quoted = "'Rust каже: \"Привіт, Світе!\"'";
    let cleaned_str = remove_quotes(mixed_quoted);
    println!("{}", cleaned_str);
    // Вивід: Rust каже: "Привіт, Світе!"
}
```

Тут видаляються лише зовнішні одинарні лапки.

## Поглиблений огляд

Коли ви видаляєте лапки з рядка, вам може здатися, чому просто не використати `.replace("\"", "")`. На початках роботи з текстом все було менш стандартизовано, і різні системи мали різні способи зберігання та передачі тексту, часто з якоюсь «секвенцією екранування» для спеціальних символів. Метод `trim_matches` Rust більш універсальний, дозволяючи вказати кілька символів для обрізання та чи обрізати з початку (префіксу), кінця (суфіксу) або обох сторін рядка.

Звичайно, є альтернативи. Регулярні вирази - це потужний інструмент для маніпуляцій з рядками, здатний збігатися зі складними шаблонами, і буде занадто складним для простого видалення лапок. Бібліотеки на кшталт `trim_in_place` можуть пропонувати обрізання на місці без необхідності створювати новий об'єкт `String`, що може бути бажаним для застосувань, критичних з точки зору продуктивності.

Під капотом `trim_matches` насправді ітерує через символи рядка з обох кінців, перевіряючи їх на відповідність наданому шаблону, доки не буде знайдено символ, що не відповідає шаблону. Він ефективний для того, що робить, але завжди пам'ятайте, що він працює з юнікодними скалярними значеннями. Якщо ваш рядок може містити багатобайтні юнікодні символи, вам не потрібно турбуватися про те, що він їх розірве.

## Дивіться також

- Документація Rust по маніпуляції з рядками: https://doc.rust-lang.org/book/ch08-02-strings.html
- Крейт `regex` для складних шаблонів: https://crates.io/crates/regex
- Rust на прикладах для практичних сценаріїв програмування: https://doc.rust-lang.org/stable/rust-by-example/std/str.html
