---
title:                "Обробка помилок"
aliases:
- /uk/rust/handling-errors/
date:                  2024-01-26T00:57:43.710179-07:00
model:                 gpt-4-1106-preview
simple_title:         "Обробка помилок"

tag:                  "Good Coding Practices"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/uk/rust/handling-errors.md"
---

{{< edit_this_page >}}

## Що і чому?

Обробка помилок полягає в діях, коли щось іде не так. Програмісти роблять це, щоб впоратися з несподіваним, забезпечуючи стійкість своїх програм на Rust, щоб вони просто не зупинялися через невеликий збій.

## Як це робити:

Rust обробляє помилки двома основними способами: відновлювані й невідновлювані помилки. Давайте розглянемо обидва.

Відновлювані помилки використовують `Result<T, E>`:

```Rust
use std::fs::File;

fn open_file(filename: &str) -> Result<File, std::io::Error> {
    let f = File::open(filename);
    
    match f {
        Ok(file) => Ok(file),
        Err(e) => Err(e),
    }
}

fn main() {
    match open_file("hello.txt") {
        Ok(_file) => println!("Файл успішно відкритий."),
        Err(_e) => println!("Не вдалося відкрити файл."),
    }
}
```

Результат може бути як "Файл успішно відкритий.", так і "Не вдалося відкрити файл.", залежно від вашого `hello.txt`.

Для невідновлюваних помилок ми використовуємо `panic!`:

```Rust
fn main() {
    // Це викличе паніку програми, оскільки файл, ймовірно, не існує.
    let _f = File::open("nowhere.txt").unwrap();
}
```

Запустіть, і ви побачите повідомлення про паніку. Ваша програма зупиняється на місці.

## Поглиблено

Традиційно обробка помилок у програмуванні була досить хаотичною. Rust робить це правильно, з чітким розмежуванням відновлюваних і невідновлюваних помилок.

Перечислення `Result` використовується для відновлюваних помилок. Воно є явним – ви обробляєте варіанти `Ok` або `Err`. У вас також є методи, як `unwrap()` та `expect()`, але це швидкі та брудні обхідні шляхи, які можуть призвести до `panic!`.

`panic!` – це спосіб Rust кричати про те, що сталася дійсно погана річ, і він не може з цим впоратися. Це як невідновлювана помилка, яка негайно зупиняє виконання. Паніка в Rust часто асоціюється з помилками, з якими ви не очікуєте справлятися, наприклад з виходом за межі масиву.

Обробка помилок шляхом повернення `Result` вважається бажаною, коли ви очікуєте мати справу з помилками. Це ідіоматичний Rust, що означає, що це спосіб, який розробники Rust домовилися робити речі. Існує також `Option<T>` для випадків, коли помилка – це просто щось, що є `None` замість `Some(T)`. Це все про очікування несподіваного без страху.

Альтернативи? Звичайно, ви можете використовувати інші бібліотеки для обробки помилок для більших можливостей або ергономічного використання. Наприклад, `anyhow` для простої обробки помилок або `thiserror` для помилок у коді бібліотеки.

## Дивіться також

Цікавитесь глибшим зануренням? Ось куди можна звернутися:

- [Розділ про обробку помилок у Книзі Rust](https://doc.rust-lang.org/book/ch09-00-error-handling.html) - це чудове місце для розуміння філософії обробки помилок в Rust.
- [Rust прикладами: Обробка помилок](https://doc.rust-lang.org/rust-by-example/error.html) - Інтерактивні приклади для практичного використання.

Пам’ятайте, що хороша обробка помилок – це не лише кодування; це турбота про користувачів вашого коду. Веселого кодування!
