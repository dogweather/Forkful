---
title:                "Логування"
date:                  2024-01-26T01:08:35.903604-07:00
model:                 gpt-4-1106-preview
simple_title:         "Логування"
programming_language: "Rust"
category:             "Rust"
tag:                  "Good Coding Practices"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/uk/rust/logging.md"
---

{{< edit_this_page >}}

## Що & Чому?

Логування схоже на ведення журналу для вашої програми; це практика запису подій, помилок, та інших важливих даних під час виконання. Розробники використовують логи для діагностики проблем, моніторингу поведінки системи, та збору відомостей, які сприяють поліпшенням — це основа оперативної інтелектуальної діяльності.

## Як це зробити:

Давайте налаштуємо базовий сценарій логування в Rust за допомогою крейту `log`, який надає фасад для логування, та `env_logger`, реалізацію логування для крейту `log`. Спершу додайте їх до вашого Cargo.toml:

```toml
[dependencies]
log = "0.4.14"
env_logger = "0.9.0"
```

Тепер налаштуйте та ініціалізуйте логер у вашому `main.rs`:

```rust
use log::{info, warn};

fn main() {
    env_logger::init();

    info!("Це повідомлення інформаційного типу.");
    warn!("Це повідомлення із попередженням.");
}
```

Запустіть ваш додаток за допомогою `RUST_LOG=info cargo run`, і ви побачите вивід:

```
INFO: Це повідомлення інформаційного типу.
WARN: Це повідомлення із попередженням.
```

Поекспериментуйте зі змінною оточення `RUST_LOG`, встановлюючи її до `error`, `warn`, `info`, `debug` або `trace` для керування докладністю ваших логів.

## Поглиблено

Концепція логування не є чимось новим; вона існує з ранніх днів обчислювальної техніки. До того, як логування стало поширеним у програмному забезпеченні, розробники покладалися на примітивні методи такі як оператори друку або інструменти для відлагодження для простеження виконання програми. Оскільки програми ставали складнішими, так само зросла і потреба у структурованих підходах до логування.

У Rust крейт `log` абстрагує деталі реалізації логування, дозволяючи розробникам використовувати різні бекенди для логування. Хоча `env_logger` є поширеним вибором, існують альтернативи, такі як `fern`, `slog`, або `tracing`, кожна з власним набором особливостей та опцій конфігурації.

Деякі міркування при реалізації логування включають:

1. **Рівні Логів**: Контроль детальності є ключовим. Крейт `log` в Rust визначає декілька рівнів логів: error, warn, info, debug, та trace, в порядку зменшення серйозності.

2. **Продуктивність**: Логування може впливати на продуктивність. Важливо використовувати його з розумом, пам'ятаючи про уникнення логування у шляхах критичної до продуктивності логіки або надмірно детальних логів у продакшені.

3. **Структуроване Логування**: Сучасна краща практика включає структуроване логування, де логи записуються у машинно-читабельному форматі, такому як JSON. Бібліотеки типу `slog` дозволяють здійснювати структуроване логування у Rust, яке може індексуватись та запитуватись за допомогою систем управління логами як ELK Stack або Splunk.

4. **Асинхронне Логування**: Для мінімізації впливу на основну програму, логування може виконуватися асинхронно. Це зазвичай досягається тим, що бібліотека логування записує до внутрішньої черги у пам'яті, а окремий потік обробляє чергу та записує логи до призначеного місця.

5. **Конфігурація**: Багато фреймворків логування підтримують конфігурацію через змінні оточення, файли конфігурацій та/або код. Ця гнучкість є ключовою для точного налаштування виводу в різних середовищах (розробка, стейджинг, продакшен).

## Дивіться також

- Документація крейту `log`: https://docs.rs/log/
- Документація крейту `env_logger`: https://docs.rs/env_logger/
- Сторінка логування Rust прикладами: https://doc.rust-lang.org/rust-by-example/std_misc/log.html
- Крейт `slog`, альтернативний фреймворк логування: https://github.com/slog-rs/slog
- Tracing, фреймворк для інструментування програм Rust: https://crates.io/crates/tracing