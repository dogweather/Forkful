---
changelog:
- 2024-01-30, gpt-4-0125-preview, translated from English
date: 2024-01-30 19:13:12.642660-07:00
description: "\u0410\u0441\u043E\u0446\u0456\u0430\u0442\u0438\u0432\u043D\u0456 \u043C\
  \u0430\u0441\u0438\u0432\u0438, \u0430\u0431\u043E \u044F\u043A \u0457\u0445 \u043D\
  \u0430\u0437\u0438\u0432\u0430\u044E\u0442\u044C \u0435\u043D\u0442\u0443\u0437\u0456\
  \u0430\u0441\u0442\u0438 Rust - \"\u0445\u0435\u0448-\u043C\u0430\u043F\u0438\"\
  , \u0454 \u043A\u043E\u043B\u0435\u043A\u0446\u0456\u044F\u043C\u0438, \u0449\u043E\
  \ \u0437\u0431\u0435\u0440\u0456\u0433\u0430\u044E\u0442\u044C \u0434\u0430\u043D\
  \u0456 \u0443 \u043F\u0430\u0440\u0430\u0445 \u043A\u043B\u044E\u0447-\u0437\u043D\
  \u0430\u0447\u0435\u043D\u043D\u044F. \u041F\u0440\u043E\u0433\u0440\u0430\u043C\
  \u0456\u0441\u0442\u0438 \u0432\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u043E\u0432\
  \u0443\u044E\u0442\u044C\u2026"
lastmod: '2024-03-13T22:44:48.924811-06:00'
model: gpt-4-0125-preview
summary: "\u0410\u0441\u043E\u0446\u0456\u0430\u0442\u0438\u0432\u043D\u0456 \u043C\
  \u0430\u0441\u0438\u0432\u0438, \u0430\u0431\u043E \u044F\u043A \u0457\u0445 \u043D\
  \u0430\u0437\u0438\u0432\u0430\u044E\u0442\u044C \u0435\u043D\u0442\u0443\u0437\u0456\
  \u0430\u0441\u0442\u0438 Rust - \"\u0445\u0435\u0448-\u043C\u0430\u043F\u0438\"\
  , \u0454 \u043A\u043E\u043B\u0435\u043A\u0446\u0456\u044F\u043C\u0438, \u0449\u043E\
  \ \u0437\u0431\u0435\u0440\u0456\u0433\u0430\u044E\u0442\u044C \u0434\u0430\u043D\
  \u0456 \u0443 \u043F\u0430\u0440\u0430\u0445 \u043A\u043B\u044E\u0447-\u0437\u043D\
  \u0430\u0447\u0435\u043D\u043D\u044F."
title: "\u0412\u0438\u043A\u043E\u0440\u0438\u0441\u0442\u0430\u043D\u043D\u044F \u0430\
  \u0441\u043E\u0446\u0456\u0430\u0442\u0438\u0432\u043D\u0438\u0445 \u043C\u0430\u0441\
  \u0438\u0432\u0456\u0432"
weight: 15
---

## Як використовувати:
У Rust тип `HashMap` з модулю `std::collections` надає функціональність асоціативних масивів. Ось як ви можете працювати з ними:

```Rust
use std::collections::HashMap;

fn main() {
    // Створення нового HashMap
    let mut scores = HashMap::new();

    // Вставлення значень
    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);

    // Доступ до значень
    let team_name = String::from("Blue");
    if let Some(score) = scores.get(&team_name) {
        println!("Бали команди Blue: {}", score); // Вивід: Бали команди Blue: 10
    }

    // Оновлення значення
    scores.entry(String::from("Blue")).and_modify(|e| *e += 5);

    // Ітерація через пари ключ-значення
    for (key, value) in &scores {
        println!("{}: {}", key, value); // Вивід: Blue: 15, Yellow: 50
    }
}
```

## Поглиблений розгляд
`HashMap` у Rust використовує хеш-функцію для відображення ключів на значення, що дозволяє швидко отримувати дані. Проте, ця ефективність має свою ціну: хеш-мапи не зберігають порядок своїх елементів. Це контрастує з іншими реалізаціями асоціативних масивів, такими як у Python (`dict`) або Ruby, які в нових версіях зберігають порядок вставки як особливість. Для випадків, коли порядок пар ключ-значення має значення, розробники Rust можуть розглянути використання `BTreeMap` з модулю `std::collections`, який зберігає порядок, але може пропонувати повільніші вставку та отримання порівняно з `HashMap`. В кінцевому підсумку вибір між `HashMap` і `BTreeMap` залежить від конкретних вимог до порядку та продуктивності.
