---
title:                "Обробка помилок"
date:                  2024-01-26T00:53:15.092950-07:00
model:                 gpt-4-1106-preview
simple_title:         "Обробка помилок"
programming_language: "Gleam"
category:             "Gleam"
tag:                  "Good Coding Practices"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/uk/gleam/handling-errors.md"
---

{{< edit_this_page >}}

## Що та чому?
Обробка помилок полягає у прогнозуванні ситуацій, коли щось може піти не так у вашому коді, та велелюдному управлінні цими випадками. Програмісти роблять це, оскільки це забезпечує стійкість додатків та зручність для користувача, навіть при неочікуваних обставинах.

## Як це зробити:
У Gleam ви часто будете використовувати тип `Result` для обробки помилок. Це перелік (enum) із двома варіантами: `Ok` (для успіху) та `Error` (для помилки). Ось простий приклад:

```Gleam
pub fn might_fail(break_it: Bool) -> Result(Int, String) {
  if break_it {
    Error("Ой-ой! Щось зламалося.".to_string())
  } else {
    Ok(42)
  }
}

pub fn main() {
  let result = might_fail(False)
  case result {
    Ok(value) => value
    Error(message) => {
      io.println(message)
      0
    } 
  }
}
```

Якщо ви запустите `main` з `might_fail(False)`, воно поверне `42`. Якщо ви передасте `True`, це виведе "Ой-ой! Щось зламалося." і поверне `0`.

## Поглиблено
Підхід Gleam до обробки помилок вплинутий його корінням у Erlang. Історично, Erlang використовує філософію "нехай падає", покладаючись на дерева нагляду для управління невдачами процесів. Однак, коли ви пишете код на Gleam, який не входить в процес, що має бути нагляданим, наприклад, у функції бібліотеки, вам захочеться явно обробляти помилки.

Альтернативи використанню `Result` включають використання типу `Option` для випадків, коли щось може бути `None` (нічого) або `Some` (щось), але вони не несуть інформації про помилку. Для сигналізації про помилки у межах процесів можна використовувати механізми передачі повідомлень Erlang.

Обробка помилок у Gleam відображає стиль функціонального програмування, де побічні ефекти (як от помилки) управляються за допомогою типів та відповідності шаблонів, забезпечуючи чіткість та передбачуваність у управлінні помилками.

## Дивіться також
- [Обробка помилок в Erlang](http://erlang.org/doc/reference_manual/errors.html)