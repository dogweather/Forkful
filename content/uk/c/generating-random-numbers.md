---
title:                "Генерація випадкових чисел"
date:                  2024-01-27T20:33:26.023188-07:00
model:                 gpt-4-0125-preview
simple_title:         "Генерація випадкових чисел"
programming_language: "C"
category:             "C"
tag:                  "Numbers"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/uk/c/generating-random-numbers.md"
---

{{< edit_this_page >}}

## Що і чому?

Генерація випадкових чисел у C полягає у створенні послідовностей чисел без будь-якого розпізнавального шаблону, імітуючи концепцію випадковості. Програмісти використовують випадкові числа для низки цілей, включаючи симуляцію даних, криптографічні застосунки та розробку ігор, що робить їх важливою частиною програмування.

## Як:

Щоб генерувати випадкові числа в C, зазвичай використовують функцію `rand()`, яку можна знайти в `stdlib.h`. Однак, важливо ініціалізувати генератор випадкових чисел, щоб забезпечити різноманітність генерованих чисел при різних виконаннях програми. Функція `srand()`, ініціалізована значенням, часто поточним часом, сприяє цьому.

Ось простий приклад генерації випадкового числа від 0 до 99:

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main() {
    // Ініціалізуємо генератор випадкових чисел
    srand((unsigned) time(NULL));

    // Генеруємо випадкове число від 0 до 99
    int randomNumber = rand() % 100;

    // Виводимо випадкове число
    printf("Random Number: %d\n", randomNumber);

    return 0;
}
```

Приклад результату:

```
Random Number: 42
```

Важливо зазначити, що кожне виконання цієї програми створює нове випадкове число, завдяки ініціалізації поточним часом.

## Поглиблений аналіз

Традиційний спосіб генерації випадкових чисел у C за допомогою `rand()` та `srand()`, насправді, не є цілком випадковим. Це псевдовипадковість. Це підходить для багатьох застосунків, але не вистачає у ситуаціях, що вимагають високого ступеня випадковості, наприклад, у серйозних криптографічних застосунках. Послідовність, генерована через `rand()`, цілком визначається посівом, переданим до `srand()`. Отже, якщо посів відомий, послідовність можна передбачити, що зменшує випадковість.

Історично функцію `rand()` критикували за низьку якість випадковості і обмежений діапазон. Сучасні альтернативи включають використання специфічних для пристрою API або  зовнішніх бібліотек, які краще апроксимують справжню випадковість, або, в системах, схожих на UNIX, читання з `/dev/random` або `/dev/urandom` для криптографічних цілей.

Наприклад, використання `/dev/urandom` у C:

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    FILE *fp;
    unsigned int randomNumber;

    // Відкриваємо /dev/urandom для читання
    fp = fopen("/dev/urandom", "r");

    // Читаємо випадкове число
    fread(&randomNumber, sizeof(randomNumber), 1, fp);

    // Виводимо випадкове число
    printf("Random Number: %u\n", randomNumber);

    // Закриваємо файл
    fclose(fp);

    return 0;
}
```

Цей метод читає прямо з пулу ентропії системи, пропонуючи вищу якість випадковості, придатну для більш чутливих застосунків. Однак, цей підхід може мати проблеми з портабельністю на різних платформах, що робить його менш універсальним, ніж використання `rand()`.

Незалежно від методу, розуміння природи випадковості та її впровадження в C є критично важливим для розробки ефективних, безпечних та захоплюючих застосунків.
