---
aliases:
- /uk/c/capitalizing-a-string/
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 17:53:29.837079-07:00
description: "\u0417\u0440\u043E\u0431\u0438\u0442\u0438 \u0440\u044F\u0434\u043E\u043A\
  \ \u0437 \u0432\u0435\u043B\u0438\u043A\u043E\u0457 \u043B\u0456\u0442\u0435\u0440\
  \u0438 \u0432 C \u043E\u0437\u043D\u0430\u0447\u0430\u0454 \u043F\u0435\u0440\u0435\
  \u0442\u0432\u043E\u0440\u0435\u043D\u043D\u044F \u043F\u0435\u0440\u0448\u043E\u0433\
  \u043E \u0441\u0438\u043C\u0432\u043E\u043B\u0443 \u043A\u043E\u0436\u043D\u043E\
  \u0433\u043E \u0441\u043B\u043E\u0432\u0430 \u0432 \u0434\u0430\u043D\u043E\u043C\
  \u0443 \u0440\u044F\u0434\u043A\u0443 \u043D\u0430 \u0432\u0435\u043B\u0438\u043A\
  \u0443 \u043B\u0456\u0442\u0435\u0440\u0443, \u044F\u043A\u0449\u043E \u0446\u0435\
  \ - \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u0430 \u0431\u0443\u043A\u0432\u0430\
  .\u2026"
lastmod: 2024-02-18 23:09:01.158872
model: gpt-4-0125-preview
summary: "\u0417\u0440\u043E\u0431\u0438\u0442\u0438 \u0440\u044F\u0434\u043E\u043A\
  \ \u0437 \u0432\u0435\u043B\u0438\u043A\u043E\u0457 \u043B\u0456\u0442\u0435\u0440\
  \u0438 \u0432 C \u043E\u0437\u043D\u0430\u0447\u0430\u0454 \u043F\u0435\u0440\u0435\
  \u0442\u0432\u043E\u0440\u0435\u043D\u043D\u044F \u043F\u0435\u0440\u0448\u043E\u0433\
  \u043E \u0441\u0438\u043C\u0432\u043E\u043B\u0443 \u043A\u043E\u0436\u043D\u043E\
  \u0433\u043E \u0441\u043B\u043E\u0432\u0430 \u0432 \u0434\u0430\u043D\u043E\u043C\
  \u0443 \u0440\u044F\u0434\u043A\u0443 \u043D\u0430 \u0432\u0435\u043B\u0438\u043A\
  \u0443 \u043B\u0456\u0442\u0435\u0440\u0443, \u044F\u043A\u0449\u043E \u0446\u0435\
  \ - \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u0430 \u0431\u0443\u043A\u0432\u0430\
  .\u2026"
title: "\u0412\u0435\u043B\u0438\u043A\u0456 \u043B\u0456\u0442\u0435\u0440\u0438\
  \ \u0432 \u0440\u044F\u0434\u043A\u0443"
---

{{< edit_this_page >}}

## Що та Чому?

Зробити рядок з великої літери в C означає перетворення першого символу кожного слова в даному рядку на велику літеру, якщо це - маленька буква. Програмісти часто виконують цю операцію, щоб стандартизувати вхідні дані користувача для пошуків, операцій сортування або для відображення, забезпечуючи послідовність та читабельність текстових даних.

## Як:

Для того, щоб зробити рядок з великої літери в C, потрібно мати базове розуміння маніпуляції з символами та перебігу по рядку. Оскільки в C немає вбудованої функції для цього, ви зазвичай перевіряєте кожен символ, відповідно коригуючи його регістр. Нижче наведено просте втілення:

```c
#include <stdio.h>
#include <ctype.h> // Для функцій islower та toupper

void capitalizeString(char *str) {
    if (str == NULL) return; // Перевірка на безпеку
    
    int capNext = 1; // Прапорець, що вказує, чи потрібно робити наступну літеру великою
    for (int i = 0; str[i] != '\0'; i++) {
        if (capNext && islower(str[i])) {
            str[i] = toupper(str[i]); // Робимо символ великим
            capNext = 0; // Скидання прапорця
        } else if (str[i] == ' ') {
            capNext = 1; // Наступний символ повинен бути великим
        }
    }
}

int main() {
    char exampleString[] = "hello world. programming in c!";
    capitalizeString(exampleString);
    printf("Рядок з великої літери: %s\n", exampleString);
    return 0;
}
```

Приклад виводу:
```
Рядок з великої літери: Hello World. Programming In C!
```

Ця програма перебігає по рядку `exampleString`, перевіряючи кожен символ, чи треба його робити з великої літери. Функція `islower` перевіряє, чи є символ маленькою літерою, тоді як `toupper` перетворює його на велику літеру. Прапорець `capNext` визначає, чи слід перетворити наступну зустрінуту літеру, будучи встановленим після кожного пробілу (' ') що знаходиться, і спочатку, щоб зробити перший символ рядка великою літерою.

## Поглиблений Розгляд

Техніка, що демонструється, проста, але не ефективна для дуже великих рядків або коли виконується повторно в додатках, критично важливих для продуктивності. В історичних та реалізаційних контекстах маніпуляція з рядками в C, включаючи великі літери, часто включає пряму маніпуляцію з буфером, відображаючи низькорівневий підхід C та надаючи програмісту повний контроль над компромісами пам’яті та продуктивності.

Існують альтернативні, більш витончені методи для зроблення рядків з великої літери, особливо коли мова йде про локалі та юнікод-символи, де правила великої літери можуть значно відрізнятись від простого сценарію ASCII. Бібліотеки, такі як ICU (International Components for Unicode), надають надійні рішення для цих випадків, але вводять залежності та навантаження, які можуть бути непотрібними для всіх додатків.

Більше того, хоча у наведеному прикладі використовуються функції C Standard Library `islower` та `toupper`, які є частиною `<ctype.h>`, важливо розуміти, що ці функції працюють в діапазоні ASCII. Для додатків, що вимагають обробки символів поза ASCII, наприклад, обробки акцентованих символів в європейських мовах, буде необхідною додаткова логіка або сторонні бібліотеки для точного виконання капіталізації.

На закінчення, хоча метод, окреслений у статті, підходить для багатьох додатків, розуміння його обмежень та доступних альтернатив є життєво важливим для розробки міцного, інтернаціоналізованого програмного забезпечення на C.
