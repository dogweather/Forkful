---
date: 2024-01-26 01:09:19.909409-07:00
description: "\u041B\u043E\u0433\u0443\u0432\u0430\u043D\u043D\u044F \u0432 \u043F\
  \u0440\u043E\u0433\u0440\u0430\u043C\u0443\u0432\u0430\u043D\u043D\u0456 \u0441\u0445\
  \u043E\u0436\u0435 \u043D\u0430 \u0432\u0435\u0434\u0435\u043D\u043D\u044F \u0449\
  \u043E\u0434\u0435\u043D\u043D\u0438\u043A\u0430 \u0434\u043B\u044F \u0432\u0430\
  \u0448\u043E\u0457 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u0438. \u0426\u0435\
  \ \u0441\u0438\u0441\u0442\u0435\u043C\u0430\u0442\u0438\u0447\u043D\u0435 \u0437\
  \u0430\u043F\u0438\u0441\u0443\u0432\u0430\u043D\u043D\u044F \u043F\u043E\u0434\u0456\
  \u0439, \u043F\u043E\u0432\u0456\u0434\u043E\u043C\u043B\u0435\u043D\u044C \u0456\
  \ \u0442\u043E\u0447\u043E\u043A \u0434\u0430\u043D\u0438\u0445, \u044F\u043A\u0456\
  \ \u0434\u0430\u044E\u0442\u044C \u0432\u0430\u043C\u2026"
lastmod: '2024-03-13T22:44:50.238725-06:00'
model: gpt-4-1106-preview
summary: "\u041B\u043E\u0433\u0443\u0432\u0430\u043D\u043D\u044F \u0432 \u043F\u0440\
  \u043E\u0433\u0440\u0430\u043C\u0443\u0432\u0430\u043D\u043D\u0456 \u0441\u0445\u043E\
  \u0436\u0435 \u043D\u0430 \u0432\u0435\u0434\u0435\u043D\u043D\u044F \u0449\u043E\
  \u0434\u0435\u043D\u043D\u0438\u043A\u0430 \u0434\u043B\u044F \u0432\u0430\u0448\
  \u043E\u0457 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u0438."
title: "\u041B\u043E\u0433\u0443\u0432\u0430\u043D\u043D\u044F"
weight: 17
---

## Як робити:
Ruby має вбудований модуль для логування, `Logger`, яким надзвичайно легко користуватися. Ось швидкий приклад, щоб ви могли розпочати:

```ruby
require 'logger'

# Створіть Logger, що виводить до STDOUT
logger = Logger.new(STDOUT)
logger.level = Logger::INFO

# Приклад повідомлень до логу
logger.info("Це інформаційне повідомлення")
logger.warn("Це попередження")
logger.error("Це повідомлення про помилку")
```

Запуск вищенаведеного скрипта дасть приблизно такий результат:

```
I, [2023-03-15T10:00:00.123456 #1234]  INFO -- : Це інформаційне повідомлення
W, [2023-03-15T10:00:01.234567 #1234]  WARN -- : Це попередження
E, [2023-03-15T10:00:02.345678 #1234] ERROR -- : Це повідомлення про помилку
```

Ви можете налаштувати формат логу та рівень, щоб відфільтрувати непотрібний шум, а також направити логи до різних виходів, як-от файл чи навіть зовнішній сервіс логування.

## Поглиблено
Логування - це мов би старовинна традиція в програмуванні. Історично логи були простими текстовими файлами, які вручну оброблялися за допомогою інструментів на кшталт `grep`. Але концепція переросла в цілу екосистему потужних фреймворків та сервісів логування, як-от Log4j, Syslog в Linux або Sematext і Loggly в епоху хмарних технологій.

`Logger` в Ruby - це простий спосіб розпочати, але якщо вам потрібно більше потужності та гнучкості, ви могли б ознайомитися з альтернативами, такими як Lograge чи Semantic Logger. Ці бібліотеки добре працюють з Ruby програмами, пропонуючи більш точний контроль за форматуванням логів, включно зі структурованими логами (формат JSON), кращу продуктивність та безшовну інтеграцію з іншими сервісами.

Кожна бібліотека логування Ruby має свій власний спосіб роботи, але всі вони, в основному, обертаються навколо ідеї інстанса логера, до якого ви надсилаєте повідомлення. Логер обробляє ці повідомлення залежно від встановлених рівнів - DEBUG, INFO, WARN, ERROR, FATAL і UNKNOWN - і вирішує, що з ними робити: вивести їх, зберегти у файл, відправити через мережу і т.д.

## Див. також
Для поглиблення в тему вбудованого модуля логування Ruby, ознайомтеся з офіційною документацією:

Якщо ви зацікавлені у більш розширеному логуванні або хочете дослідити сторонні геми:
- [Lograge](https://github.com/roidrage/lograge)

Для загальних практик та філософії логування (не специфічних для Ruby), ці статті є вічнозеленими читаннями:
- [Книга про надійність сайтів від Google - Розділ 16: Обробка перевантажень](https://sre.google/sre-book/handling-overload/#log-messages)
- [12-факторний додаток - Логи](https://12factor.net/logs)
