---
title:                "Логування"
aliases:
- uk/clojure/logging.md
date:                  2024-01-26T01:04:00.300152-07:00
model:                 gpt-4-1106-preview
simple_title:         "Логування"

tag:                  "Good Coding Practices"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/uk/clojure/logging.md"
---

{{< edit_this_page >}}

## Що і навіщо?
Журналювання є, по суті, програмною аналогією суднового журналу; це спосіб запису подій, які відбуваються під час роботи додатку. Програмісти роблять це, щоб стежити за цими подіями для відладки, шляхів аудиту або отримання уявлень про поведінку системи у виробництві.

## Як робити:
Clojure спирається на можливості журналювання Java, але ви можете використовувати їх більш ідіоматичним способом Clojure. Давайте подивимося, як ви можете використовувати `clojure.tools.logging`, який надає просту абстракцію над кількома фреймворками журналювання:

Спершу додайте залежність для `clojure.tools.logging` та реалізацію журналювання, таку як `log4j` у вашому `project.clj`:

```clojure
:dependencies [[org.clojure/clojure "1.10.3"]
               [org.clojure/tools.logging "1.1.0"]
               [log4j/log4j "1.2.17"]]
```

Тепер давайте записувати деякі повідомлення:

```clojure
(require '[clojure.tools.logging :as log])

(defn compute-answer-to-everything []
  (log/debug "Починається інтенсивне обчислення...")
  (Thread/sleep 3000) ; Симуляція тривалого обчислення
  (log/info "Обчислення завершено. Відповідь – 42.")
  42)

(compute-answer-to-everything)
```
Вивід не покаже повідомлень `DEBUG` за замовчуванням, оскільки рівні журналювання зазвичай встановлюються на `INFO`:

```
INFO  [your-namespace] - Обчислення завершено. Відповідь – 42.
```

Ви можете налаштувати рівні журналювання та апендери у файлі `log4j.properties`, щоб отримати більш детальний вивід за потреби.

## Занурення в глибину
`clojure.tools.logging` у Clojure існує вже деякий час і служить мостом між кодом Clojure та світом журналювання Java. Історично Java пройшла через кілька ітерацій та бібліотек для журналювання, таких як вбудований журналюючий API Java, `log4j`, `slf4j` і `logback`.

У Clojure, хоча ви можете безпосередньо використовувати фреймворки журналювання Java, `clojure.tools.logging` виявляє та делегує виконання будь-якого фреймворку журналювання, який він знаходить у вашому classpath, економлячи вас від тісної прив'язки до певної реалізації. Це може допомогти зробити ваш Clojure код більш переносним та модульним.

Альтернативи `clojure.tools.logging` у екосистемі Clojure включають бібліотеки на кшталт `timbre`, яка є чисто Clojure журналюючою бібліотекою з можливостями, як обертання журналів, фільтрація та асинхронне журналювання з коробки.

Деталі реалізації є вирішальними, коли мова йде про журналювання у багатопотоковому середовищі, такому як Clojure. Тут незмінність та управління побічними ефектами надають певні переваги. Журналювання, як побічний ефект, слід обробляти обережно, щоб уникнути заторів продуктивності та забезпечити безпеку потоків, про що вже піклуються більшість фреймворків журналювання Java.

Нарешті, розгляньте структуроване журналювання, де логи записуються як структуровані дані (як JSON). Це може бути надзвичайно корисним для подальшого аналізу та обробки, особливо коли мова йде про масштабні розподілені системи.

## Дивіться також
Якщо ви хочете дізнатися більше, подумайте про перегляд цих ресурсів:

- Документація Clojure Tools Logging: https://github.com/clojure/tools.logging
- Timbre, бібліотека журналювання Clojure: https://github.com/ptaoussanis/timbre
- Налаштування Log4J у Clojure: http://clojure-doc.org/articles/tutorials/logging_with_log4j.html
- Руководство Logback для складних налаштувань: http://logback.qos.ch/manual/
- Посібник зі структурованого журналювання у Clojure: https://corfield.org/blog/2020/04/28/structured-logging/
