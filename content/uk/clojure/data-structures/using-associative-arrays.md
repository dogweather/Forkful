---
title:                "Використання асоціативних масивів"
aliases:
- /uk/clojure/using-associative-arrays/
date:                  2024-01-30T19:10:53.651429-07:00
model:                 gpt-4-0125-preview
simple_title:         "Використання асоціативних масивів"

tag:                  "Data Structures"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/uk/clojure/using-associative-arrays.md"
changelog:
  - 2024-01-30, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## Що і Чому?

Асоціативні масиви, або хеш-таблиці, у Clojure дозволяють вам зберігати та отримувати доступ до даних за допомогою пар ключ-значення. Вони є вибором номер один для управління структурованими даними, завдяки чому доступ до конкретних елементів стає швидшим без необхідності ітерування через список.

## Як це зробити:

У Clojure створення та маніпулювання асоціативними масивами (хеш-таблицями) є простим. Давайте розглянемо на прикладах.

Щоб створити хеш-таблицю:

```clojure
(def my-map {:name "Alex" :age 30})
```

Ви можете отримати значення, вказавши його ключ:

```clojure
(get my-map :name)
;; "Alex"
```
Або, більш ідіоматично, ви можете використовувати ключ як функцію:

```clojure
(:name my-map)
;; "Alex"
```

Додавання або оновлення записів просте:

```clojure
(def updated-map (assoc my-map :location "New York"))
;; {:name "Alex", :age 30, :location "New York"}

(def incremented-age (update my-map :age inc))
;; {:name "Alex", :age 31}
```

Для видалення ключів використовуйте `dissoc`:

```clojure
(def removed-age (dissoc my-map :age))
;; {:name "Alex"}
```

Щоб ітерувати через мапу:

```clojure
(doseq [[k v] my-map] (println k "->" v))
;; :name -> Alex
;; :age -> 30
```

А для умовного доступу, `find` повертає пару ключ-значення, якщо ключ існує:

```clojure
(find my-map :age)
;; [:age 30]
```

## Поглиблений розгляд

Асоціативні масиви у Clojure, які також часто називають хеш-таблицями, є надзвичайно універсальними і ефективними для управління даними на основі пар ключ-значення. Вони є частиною багатої бібліотеки колекцій Clojure, глибоко вкоріненої в філософію незмінності та функціонального програмування мови. На відміну від масивів або списків, які вимагають складності O(n) для доступу до елементів, хеш-таблиці забезпечують майже сталу складність часу для доступу, що робить їх високоефективними для операцій пошуку.

Хтось може стверджувати, що вектори в Clojure могли б служити подібною метою через індексований доступ, але хеш-таблиці виграють при роботі з не послідовними та маркованими даними, де ключ надає значущий опис замість довільного індексу.

Унікально для Clojure (та її Lisp спадщини), асоціативні масиви є об’єктами першого класу, що означає, що їх можна безпосередньо маніпулювати, передавати функціям і більше, без необхідності спеціального синтаксису або методів доступу. Це рішення щодо дизайну посилює акцент Clojure на простоті та потужності.

Попри надзвичайну корисність хеш-таблиць, варто зазначити, що для дуже великих наборів даних або сценаріїв, де ключі є вкрай динамічними (постійне додавання та видалення), альтернативні структури даних або бази даних можуть запропонувати кращу продуктивність та гнучкість. Однак, для більшості типових сценаріїв використання у додатках Clojure, асоціативні масиви надають надійний та ефективний спосіб управління даними.
