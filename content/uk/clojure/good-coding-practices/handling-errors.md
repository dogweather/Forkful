---
date: 2024-01-26 00:51:57.773581-07:00
description: "\u041E\u0431\u0440\u043E\u0431\u043A\u0430 \u043F\u043E\u043C\u0438\u043B\
  \u043E\u043A - \u0446\u0435 \u043F\u0440\u043E \u0443\u043F\u0440\u0430\u0432\u043B\
  \u0456\u043D\u043D\u044F \u043D\u0435\u043E\u0447\u0456\u043A\u0443\u0432\u0430\u043D\
  \u0438\u043C \u0443 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u0430\u0445 \u2014\
  \ \u043D\u0456\u0431\u0438 \u0431\u0430\u0440\u043C\u0435\u043D, \u044F\u043A\u0438\
  \u0439 \u0432\u043F\u043E\u0440\u044F\u0434\u043A\u043E\u0432\u0443\u0454 \u0445\
  \u0443\u043B\u0456\u0433\u0430\u043D\u0456\u0432. \u041F\u0440\u043E\u0433\u0440\
  \u0430\u043C\u0456\u0441\u0442\u0430\u043C \u043F\u043E\u0434\u043E\u0431\u0430\u0454\
  \u0442\u044C\u0441\u044F, \u043A\u043E\u043B\u0438 \u0432\u0441\u0435 \u0433\u043B\
  \u0430\u0434\u043A\u043E; \u043E\u0431\u0440\u043E\u0431\u043A\u0430\u2026"
lastmod: '2024-03-13T22:44:48.665880-06:00'
model: gpt-4-1106-preview
summary: "\u041E\u0431\u0440\u043E\u0431\u043A\u0430 \u043F\u043E\u043C\u0438\u043B\
  \u043E\u043A - \u0446\u0435 \u043F\u0440\u043E \u0443\u043F\u0440\u0430\u0432\u043B\
  \u0456\u043D\u043D\u044F \u043D\u0435\u043E\u0447\u0456\u043A\u0443\u0432\u0430\u043D\
  \u0438\u043C \u0443 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u0430\u0445 \u2014\
  \ \u043D\u0456\u0431\u0438 \u0431\u0430\u0440\u043C\u0435\u043D, \u044F\u043A\u0438\
  \u0439 \u0432\u043F\u043E\u0440\u044F\u0434\u043A\u043E\u0432\u0443\u0454 \u0445\
  \u0443\u043B\u0456\u0433\u0430\u043D\u0456\u0432."
title: "\u041E\u0431\u0440\u043E\u0431\u043A\u0430 \u043F\u043E\u043C\u0438\u043B\u043E\
  \u043A"
weight: 16
---

## Як це робити:
Clojure, як і її предки Lisp, покладається на виключення для роботи з помилками. Ось як ви показуєте, з чого ви зроблені, коли ситуація зайшла в глухий кут.

Викидання виключення є простим:
```Clojure
(throw (Exception. "Ой! Щось пішло не так."))
```

Перехоплення виключення, ви будете робити це часто:
```Clojure
(try
  ;; ризикований код
  (/ 1 0)
  (catch ArithmeticException e
    (println "Не можна ділити на нуль!"))
  ;; блок finally виконується в будь-якому випадку
  (finally 
    (println "Код для прибирання знаходиться тут.")))
```
Приклад виводу для вищезазначеного блоку catch:
```
Не можна ділити на нуль!
Код для прибирання знаходиться тут.
```

Використання `ex-info` та `ex-data` для більш повного контексту про виключення:
```Clojure
(try
  ;; виклик власного виключення
  (throw (ex-info "Специфічна помилка" {:type :custom-failure}))
  (catch Exception e
    ;; отримання даних з нашого власного виключення
    (println (ex-data e))))
```
Приклад виводу:
```
{:type :custom-failure}
```

## Поглиблене вивчення
Історія обробки помилок у Clojure не радикально відрізняється від інших Lisps або навіть Java (від якої вона успадкувала механізм `try-catch`). Це прагматично; використання виключень є основним шляхом, як і в Java, але Clojure пропонує функціональний смак з `ex-info` та `ex-data` для більш багатих даних про помилки.

Альтернативи для обробки помилок у Clojure включають використання монадичних конструкцій, таких як монада `either` із бібліотек, подібних до `cats`, або core.async для поширення помилок через канали. Однак, вони більш складні та використовуються в специфічних сценаріях.

Історично обробка помилок у мовах програмування еволюціонувала від простого повернення статусу до більш складних механізмів обробки виключень сучасних мов. Clojure вибирає простоту та дотик функціонального програмування, поєднуючи старе з новим.

## Дивіться також
- Посібник Clojure по виключенням: https://clojure.org/guides/exceptions
- Бібліотека “Cats” для більш функціональних підходів: https://github.com/funcool/cats
- “Core.async” для асинхронного програмування: https://github.com/clojure/core.async
