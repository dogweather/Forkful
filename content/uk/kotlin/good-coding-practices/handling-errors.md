---
date: 2024-01-26 00:55:12.679829-07:00
description: "\u041E\u0431\u0440\u043E\u0431\u043A\u0430 \u043F\u043E\u043C\u0438\u043B\
  \u043E\u043A - \u0446\u0435 \u0441\u043F\u043E\u0441\u0456\u0431, \u044F\u043A\u0438\
  \u043C \u0432\u0430\u0448 \u043A\u043E\u0434 \u0441\u043F\u0440\u0430\u0432\u043B\
  \u044F\u0454\u0442\u044C\u0441\u044F \u0456\u0437 \u043F\u0440\u043E\u0431\u043B\
  \u0435\u043C\u0430\u043C\u0438, \u0449\u043E \u0432\u0438\u043D\u0438\u043A\u0430\
  \u044E\u0442\u044C \u043F\u0456\u0434 \u0447\u0430\u0441 \u0432\u0438\u043A\u043E\
  \u043D\u0430\u043D\u043D\u044F, - \u043D\u0456\u0431\u0438 \u043B\u043E\u0432\u0438\
  \u0442\u0438 \u043A\u0440\u0443\u0442\u0438\u0439 \u043C'\u044F\u0447 \u0431\u0435\
  \u0437 \u0439\u043E\u0433\u043E \u0432\u0442\u0440\u0430\u0442\u0438.\u2026"
lastmod: '2024-03-13T22:44:49.231918-06:00'
model: gpt-4-1106-preview
summary: "\u041E\u0431\u0440\u043E\u0431\u043A\u0430 \u043F\u043E\u043C\u0438\u043B\
  \u043E\u043A - \u0446\u0435 \u0441\u043F\u043E\u0441\u0456\u0431, \u044F\u043A\u0438\
  \u043C \u0432\u0430\u0448 \u043A\u043E\u0434 \u0441\u043F\u0440\u0430\u0432\u043B\
  \u044F\u0454\u0442\u044C\u0441\u044F \u0456\u0437 \u043F\u0440\u043E\u0431\u043B\
  \u0435\u043C\u0430\u043C\u0438, \u0449\u043E \u0432\u0438\u043D\u0438\u043A\u0430\
  \u044E\u0442\u044C \u043F\u0456\u0434 \u0447\u0430\u0441 \u0432\u0438\u043A\u043E\
  \u043D\u0430\u043D\u043D\u044F, - \u043D\u0456\u0431\u0438 \u043B\u043E\u0432\u0438\
  \u0442\u0438 \u043A\u0440\u0443\u0442\u0438\u0439 \u043C'\u044F\u0447 \u0431\u0435\
  \u0437 \u0439\u043E\u0433\u043E \u0432\u0442\u0440\u0430\u0442\u0438."
title: "\u041E\u0431\u0440\u043E\u0431\u043A\u0430 \u043F\u043E\u043C\u0438\u043B\u043E\
  \u043A"
weight: 16
---

## Як це робити:
Kotlin надає `try`, `catch`, `finally` та `throw` для управління помилками. Ось як їх використовувати:

```Kotlin
fun main() {
    val numerator = 10
    val denominator = 0

    try {
        val result = numerator / denominator
        println("Результат: $result")
    } catch (e: ArithmeticException) {
        println("На нуль ділити не можна, друже.")
    } finally {
        println("Це станеться незалежно від чого.")
    }
}
```

Вивід:
```
На нуль ділити не можна, друже.
Це станеться незалежно від чого.
```

Якщо у блоку `try` виникає щось не так, виконання переходить до `catch`. Він ловить конкретну помилку, що виникла (`ArithmeticException` у цьому випадку). Блок `finally` виконується після цього — незалежно від результату.

## Більш детально
Блок `try-catch` існує з самого початку програмування — це своєрідна сітка безпеки. Kotlin також пропонує `throw` для ручного кидання винятку в код, і є `finally` для коду, який мусить виконатися — це часто завершальна робота.

Альтернативи включають тип `Result` та використання `try` як виразу.

```Kotlin
val result: Result<Int> = try {
    Result.success(numerator / denominator)
} catch (e: ArithmeticException) {
    Result.failure(e)
}
```
Цей підхід повертає об'єкт `Result` — ви отримуєте або успіх, або невдачу, без драми некерованого винятку.

Реалізація в Kotlin зручна, тому що ви можете використовувати `try` як вираз, що означає, що воно повертає значення. Такі вибори роблять обробку помилок у Kotlin досить гнучкою. Йдеться про вибір правильного інструменту для завдання, точно так само, як ви б вибрали в майстерні.

## Дивіться також
- Документація Kotlin по Винятках: [Обробка винятків у Kotlin](https://kotlinlang.org/docs/exception-handling.html)
- Документація Kotlin типу `Result`: [Kotlin Result](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-result/)
- "Ефективне Java, 3-те видання" Джошуа Блоха — гарні інсайти щодо винятків, хоча і специфічно для Java.
