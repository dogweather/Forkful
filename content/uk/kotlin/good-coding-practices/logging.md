---
date: 2024-01-26 01:09:33.703334-07:00
description: "\u041B\u043E\u0433\u0443\u0432\u0430\u043D\u043D\u044F, \u044F\u043A\
  \ \u043E\u0441\u043D\u043E\u0432\u0430, - \u0446\u0435 \u043F\u0440\u0430\u043A\u0442\
  \u0438\u043A\u0430 \u0437\u0430\u043F\u0438\u0441\u0443 \u043F\u043E\u0434\u0456\
  \u0439 \u0456 \u0434\u0430\u043D\u0438\u0445 \u0437 \u043F\u0440\u043E\u0433\u0440\
  \u0430\u043C\u043D\u043E\u0433\u043E \u0437\u0430\u0441\u0442\u043E\u0441\u0443\u043D\
  \u043A\u0443 \u0432 \u0437\u043E\u0432\u043D\u0456\u0448\u043D\u0456\u0439 \u0432\
  \u0438\u0432\u0456\u0434, \u043D\u0430\u043F\u0440\u0438\u043A\u043B\u0430\u0434\
  , \u0443 \u0444\u0430\u0439\u043B \u0430\u0431\u043E \u043A\u043E\u043D\u0441\u043E\
  \u043B\u044C. \u041F\u0440\u043E\u0433\u0440\u0430\u043C\u0456\u0441\u0442\u0438\
  \ \u0432\u0435\u0434\u0443\u0442\u044C\u2026"
lastmod: '2024-03-13T22:44:49.230201-06:00'
model: gpt-4-1106-preview
summary: "\u041B\u043E\u0433\u0443\u0432\u0430\u043D\u043D\u044F, \u044F\u043A \u043E\
  \u0441\u043D\u043E\u0432\u0430, - \u0446\u0435 \u043F\u0440\u0430\u043A\u0442\u0438\
  \u043A\u0430 \u0437\u0430\u043F\u0438\u0441\u0443 \u043F\u043E\u0434\u0456\u0439\
  \ \u0456 \u0434\u0430\u043D\u0438\u0445 \u0437 \u043F\u0440\u043E\u0433\u0440\u0430\
  \u043C\u043D\u043E\u0433\u043E \u0437\u0430\u0441\u0442\u043E\u0441\u0443\u043D\u043A\
  \u0443 \u0432 \u0437\u043E\u0432\u043D\u0456\u0448\u043D\u0456\u0439 \u0432\u0438\
  \u0432\u0456\u0434, \u043D\u0430\u043F\u0440\u0438\u043A\u043B\u0430\u0434, \u0443\
  \ \u0444\u0430\u0439\u043B \u0430\u0431\u043E \u043A\u043E\u043D\u0441\u043E\u043B\
  \u044C."
title: "\u041B\u043E\u0433\u0443\u0432\u0430\u043D\u043D\u044F"
weight: 17
---

## Як це зробити:
У Kotlin логування можна здійснити з використанням вбудованої функції `println()` для простих випадків або з використанням більш складних бібліотек, таких як SLF4J з Logback або Log4j для складніших потреб.

Нижче наведено базовий приклад з використанням `println()`:

```Kotlin
fun main() {
    println("Просте повідомлення логу: Застосунок запущено.")
    // ... тут деяка логіка застосунку ...
    try {
        // Симуляція помилки
        throw Exception("Симульована помилка")
    } catch (e: Exception) {
        println("Повідомлення логу помилки: " + e.message)
    }
}
```

Вивід:
```
Просте повідомлення логу: Застосунок запущено.
Повідомлення логу помилки: Симульована помилка
```

А ось фрагмент, що використовує SLF4J з налаштованим Logback:

```Kotlin
import org.slf4j.LoggerFactory

private val logger = LoggerFactory.getLogger("MyAppLogger")

fun main() {
    logger.info("Структуроване повідомлення логу: Додаток запущено.")
    // ... тут деяка логіка застосунку ...
    try {
        // Симуляція помилки
        throw Exception("Симульована помилка")
    } catch (e: Exception) {
        logger.error("Структурований лог помилки: ", e)
    }
}
```

Припускаючи відповідну конфігурацію Logback, вивід буде відформатований і може виглядати приблизно так, коли він записується у файл логів:
```
[INFO] - 2023-03-29 14:15:42 - MyAppLogger - Структуроване повідомлення логу: Додаток запущено.
[ERROR] - 2023-03-29 14:15:43 - MyAppLogger - Структурований лог помилки: 
java.lang.Exception: Симульована помилка
   at com.myapp.Main.main(Main.kt:10)
```

## Поглиблений розгляд
Історично, логування у програмному забезпеченні розвивалося разом зі зростанням складності застосунків та систем. Прості оператори виводу були достатніми на ранніх стадіях, коли програми часто запускали та налагоджували самі розробники. Але як системи стали мережевими та працювали в різних середовищах для різних користувачів, надійна та стійка система логування стала ключовою.

Перед тим як Kotlin став популярним, розробники Java широко використовували бібліотеки як Log4j, а згодом SLF4J. Вони надихнули на подібні практики в Kotlin, використовуючи взаємодію Kotlin з бібліотеками Java. SLF4J виступає як шар абстракції, дозволяючи замінити реальну реалізацію логування - зазвичай Logback або Log4j2 є бажаними виборами.

Kotlin також дозволяє використовувати багатоплатформні рішення для логування, які працюють на JVM, JavaScript та Native, наприклад, через механізм `expect`/`actual`, який абстрагує реалізації специфічні для кожної платформи.

На відміну від спеціалізованих бібліотек для логування, println залишається найпростішою формою логування, оскільки не вимагає додаткових налаштувань або залежностей; однак, зазвичай воно не підходить для виробничих додатків через його недостатність можливостей, таких як рівні логів, ротація логів та структуровані формати.

Інші загальні можливості передових фреймворків логування включають:

- Рівні логів (DEBUG, INFO, WARN, ERROR тощо) для категоризації терміновості повідомлень логу.
- Вивід у різні джерела, як консоль, файл, бази даних або мережеві служби.
- Автоматична ротація логів та політики збереження.
- Підтримка розподіленого трасування для архітектури мікросервісів.
- Структуроване логування в форматах як JSON, які добре інтегровані з системами аналітики логів.

Ці інструменти та можливості критично важливі для підтримання надійної, спостережуваної системи особливо в складних, розподілених або високомасштабованих середовищах.

## Дивіться також
Для подальшого вивчення та отримання додаткових знань про логування в Kotlin, ознайомтеся з:

- SLF4J (Simple Logging Facade for Java) [http://www.slf4j.org/](http://www.slf4j.org/)
- Logback, наступник Log4j [http://logback.qos.ch/](http://logback.qos.ch/)
- Log4j 2 [https://logging.apache.org/log4j/2.x/](https://logging.apache.org/log4j/2.x/)
- Документація Kotlin Multiplatform про декларації 'expect' та 'actual': [https://kotlinlang.org/docs/multiplatform.html](https://kotlinlang.org/docs/multiplatform.html)
- Посібник зі структурованого логування в Kotlin: [https://ktor.io/docs/logging.html](https://ktor.io/docs/logging.html)
