---
title:                "Використання асоціативних масивів"
date:                  2024-01-30T19:10:33.415555-07:00
model:                 gpt-4-0125-preview
simple_title:         "Використання асоціативних масивів"

tag:                  "Data Structures"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/uk/cpp/using-associative-arrays.md"
changelog:
  - 2024-01-30, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## Що та чому?

Асоціативні масиви, відомі як `std::map` або `std::unordered_map` у C++, заповнюють прогалину між індексами масивів та даними реального світу, дозволяючи вам використовувати значущі ключі. Вони є найкращим вибором, коли вам потрібні швидкі пошуки, вставки та видалення, використовуючи ключі, а не позиції індексів.

## Як використовувати:

У C++, асоціативні масиви стають доступними з заголовочними файлами `<map>` та `<unordered_map>`. Давайте розглянемо приклади, щоб побачити обидва на практиці.

### Використання `std::map`

`std::map` зберігає елементи відсортованими на основі ключа. Ось як почати:

```C++
#include <iostream>
#include <map>
#include <string>

int main() {
    std::map<std::string, int> ageMap;
    
    // Вставка значень
    ageMap["Alice"] = 30;
    ageMap["Bob"] = 25;
    
    // Доступ до значень
    std::cout << "Вік Боба: " << ageMap["Bob"] << std::endl;
    
    // Ітерація по мапі
    for(const auto &pair : ageMap) {
        std::cout << pair.first << " має " << pair.second << " років." << std::endl;
    }
    
    return 0;
}
```

### Використання `std::unordered_map`

Коли порядок не має значення, але має значення продуктивність, `std::unordered_map` буде вашим другом, забезпечуючи швидшу середню складність для вставок, пошуків та видалень.

```C++
#include <iostream>
#include <unordered_map>
#include <string>

int main() {
    std::unordered_map<std::string, double> productPrice;
    
    // Вставка значень
    productPrice["milk"] = 2.99;
    productPrice["bread"] = 1.99;
    
    // Доступ до значень
    std::cout << "Ціна молока: $" << productPrice["milk"] << std::endl;
    
    // Ітерація по unordered_map
    for(const auto &pair : productPrice) {
        std::cout << pair.first << " коштує $" << pair.second << std::endl;
    }
    
    return 0;
}
```

## Поглиблений розгляд

Асоціативні масиви у C++, особливо `std::map` та `std::unordered_map`, не просто про зберігання елементів. Вони забезпечують основу для складнішого управління даними, дозволяючи виконувати такі операції, як пошук, вставка та видалення за ефективною часовою складністю (логарифмічна для `std::map` та середній випадок постійного часу для `std::unordered_map`). Ця ефективність походить від основних структур даних: збалансованого дерева для `std::map` та хеш-таблиці для `std::unordered_map`.

Історично, до того як ці структури стали частиною стандартної бібліотеки, програмісти мали імплементувати свої версії або користуватися сторонніми бібліотеками, що призводило до непослідовностей і потенційних неефективностей. Включення мап до стандартної бібліотеки C++ не лише стандартизувало їх використання, але й оптимізувало їх для процесорів різних компіляторів і платформ.

Хоча обидві є потужними, вибір між `std::map` та `std::unordered_map` залежить від конкретних умов вашого випадку. Потрібні впорядковані дані і невелика втрата продуктивності вас не лякає? Вибирайте `std::map`. Якщо вам за швидкість і порядок не важливий, `std::unordered_map`, ймовірно, буде кращим варіантом.

Однак, важливо зауважити, що при роботі зі складними структурами даних завжди є компроміси. У деяких особливих випадках інші структури даних або навіть сторонні бібліотеки можуть пропонувати кращу продуктивність або функціональність, яка підходить вашим конкретним потребам. Завжди зважуйте свої варіанти, виходячи з вимог вашого проекту.
