---
title:                "Логування"
date:                  2024-01-26T01:02:22.074328-07:00
model:                 gpt-4-1106-preview
simple_title:         "Логування"

tag:                  "Good Coding Practices"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/uk/elixir/logging.md"
---

{{< edit_this_page >}}

## Що і чому?
Логування у розробці програмного забезпечення - це метод запису подій, які відбуваються під час роботи програми, зазвичай у файл або зовнішню систему. Програмісти це роблять для отримання уявлення про поведінку програмного забезпечення, усунення проблем та збереження історії операцій, що є важливим для налагодження та моніторингу здоров'я додатків.

## Як це зробити:
У мові програмування Elixir основний спосіб запису інформації - використання вбудованого модуля `Logger`. Ось як ви можете це здійснити:

```elixir
defmodule MyApplication do
  require Logger

  def do_something_important(param) do
    Logger.info("Починаємо важливий процес з параметром: #{param}")

    # Симуляція виконання роботи
    :timer.sleep(1000)

    Logger.debug("Процес завершено.")
  rescue
    error -> Logger.error("Сталася помилка: #{inspect(error)}")
  end
end

# Щоб побачити ваші логи, просто викличте функцію:
MyApplication.do_something_important("MyParam")
```

Цей простий фрагмент коду показує, як вести логи різних рівнів (`info`, `debug`, `error`). Коли ви запустите це, ви не побачите повідомлення debug, якщо не налаштуєте рівень Logger на `:debug`. За замовчуванням, Logger в Elixir фільтрує повідомлення логів, які нижче `:info`.

Прикладний вивід на рівні `:info` може виглядати так:
```
14:32:40.123 [info]  Починаємо важливий процес з параметром: MyParam
14:32:41.126 [error] Сталася помилка: %RuntimeError{message: "runtime error"}
```

## Поглиблений аналіз:
`Logger` у Elixir - це вбудований інструмент, який був частиною мови з самого початку. Він був створений під впливом систем логування інших мов BEAM, таких як Erlang. Logger надає різні рівні логування – `:debug`, `:info`, `:warn` та `:error` – і є плаґіновим, що дозволяє підключення різних бекендів для обробки повідомлень логів.

Одна з альтернатив вбудованого Logger для складніших сценаріїв - використання бібліотек логування, таких як `Logstash` або `Sentry` для Elixir, які можуть забезпечити додаткові функції, такі як відстеження помилок і агрегація у більш наочному форматі. Для локальної розробки, розробники Elixir часто покладаються на функціональність вбудованого Logger, за його простоту і інтеграцію з віртуальною машиною BEAM.

Під капотом модуль Logger пропонує асинхронне та синхронне логування. Асинхронне логування, яке є типовим, не блокує виконання вашого додатку під час запису повідомлень. Це забезпечує, що логування не впливає негативно на продуктивність. Однак, синхронне логування можна включити для випадків, коли потрібно гарантувати, що повідомлення логування будуть записані в тому порядку, в якому вони були відправлені.

Конфігурацію Logger можна налаштувати у файлі `config/config.exs` вашого додатка Elixir, де можна встановити рівень логування, формат, метадані та багато іншого. Завжди пам'ятайте про необхідність регулювання рівнів логування та виводу для різних середовищ; ви точно не хочете, щоб велика кількість деталізованих логів захлиснула ваші продуктивні системи.

## Дивіться також:
- Офіційна документація Elixir Logger: https://hexdocs.pm/logger/Logger.html
- Блог-пост про кращі практики логування в Elixir: https://blog.appsignal.com/2020/05/06/elixir-logging-tips-and-tricks.html
- Sentry для Elixir на Hex: https://hex.pm/packages/sentry
- Урок Elixir School про Logger: https://elixirschool.com/en/lessons/specifics/debugging/#logging
