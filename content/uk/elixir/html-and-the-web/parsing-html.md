---
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 19:12:13.193706-07:00
description: "\u041F\u0430\u0440\u0441\u0438\u043D\u0433 HTML \u0443 \u043C\u043E\u0432\
  \u0456 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u0443\u0432\u0430\u043D\u043D\u044F\
  \ Elixir \u043F\u043E\u043B\u044F\u0433\u0430\u0454 \u0443 \u0432\u0438\u0442\u044F\
  \u0433\u0443\u0432\u0430\u043D\u043D\u0456 \u0456\u043D\u0444\u043E\u0440\u043C\u0430\
  \u0446\u0456\u0457 \u0437 HTML-\u0434\u043E\u043A\u0443\u043C\u0435\u043D\u0442\u0456\
  \u0432. \u041F\u0440\u043E\u0433\u0440\u0430\u043C\u0456\u0441\u0442\u0438 \u0440\
  \u043E\u0431\u043B\u044F\u0442\u044C \u0446\u0435 \u0434\u043B\u044F \u043F\u0440\
  \u043E\u0433\u0440\u0430\u043C\u043D\u043E\u0457 \u0432\u0437\u0430\u0454\u043C\u043E\
  \u0434\u0456\u0457 \u0437 \u0432\u0435\u0431-\u2026"
lastmod: '2024-03-13T22:44:48.719944-06:00'
model: gpt-4-0125-preview
summary: "\u041F\u0430\u0440\u0441\u0438\u043D\u0433 HTML \u0443 \u043C\u043E\u0432\
  \u0456 \u043F\u0440\u043E\u0433\u0440\u0430\u043C\u0443\u0432\u0430\u043D\u043D\u044F\
  \ Elixir \u043F\u043E\u043B\u044F\u0433\u0430\u0454 \u0443 \u0432\u0438\u0442\u044F\
  \u0433\u0443\u0432\u0430\u043D\u043D\u0456 \u0456\u043D\u0444\u043E\u0440\u043C\u0430\
  \u0446\u0456\u0457 \u0437 HTML-\u0434\u043E\u043A\u0443\u043C\u0435\u043D\u0442\u0456\
  \u0432."
title: "\u0410\u043D\u0430\u043B\u0456\u0437 HTML"
weight: 43
---

## Як це зробити:
Elixir, з його міцною моделлю конкурентності та парадигмою функціонального програмування, не має вбудованих можливостей для парсингу HTML. Втім, ви можете використовувати популярні сторонні бібліотеки, такі як `Floki`, для цієї мети. Floki робить парсинг HTML інтуїтивно зрозумілим та ефективним, використовуючи можливості зіставлення зразків та пайпінгу Elixir.

Спочатку, додайте Floki до залежностей вашого mix.exs:

```elixir
defp deps do
  [
    {:floki, "~> 0.31.0"}
  ]
end
```

Потім, запустіть `mix deps.get`, щоб встановити нову залежність.

Тепер, давайте проаналізуємо простий HTML-рядок, щоб витягнути дані. Ми шукатимемо заголовки всередині тегів `<h1>`:

```elixir
html_content = """
<html>
  <body>
    <h1>Привіт, Elixir!</h1>
    <h1>Ще один заголовок</h1>
  </body>
</html>
"""

titles = html_content
         |> Floki.find("h1")
         |> Floki.text()

IO.inspect(titles)
```

**Приклад виводу:**

```elixir
["Привіт, Elixir!", "Ще один заголовок"]
```

Щоб заглибитись більше, скажімо, ви хочете витягнути посилання (теги `<a>`) разом з їхніми атрибутами href. Ось як ви можете це зробити:

```elixir
html_content = """
<html>
  <body>
    <a href="https://elixir-lang.org/">Офіційний вебсайт Elixir</a>
    <a href="https://hexdocs.pm/">HexDocs</a>
  </body>
</html>
"""

links = html_content
        |> Floki.find("a")
        |> Enum.map(fn({_, attrs, [text]}) -> {text, List.keyfind(attrs, "href", 0)} end)
        
IO.inspect(links)
```

**Приклад виводу:**

```elixir
[{"Офіційний вебсайт Elixir", {"href", "https://elixir-lang.org/"}}, {"HexDocs", {"href", "https://hexdocs.pm/"}}]
```

Цей підхід дозволяє вам ефективно навігувати і парсити HTML-документи, роблячи завдання екстракції та маніпуляції з веб-даними простими в додатках Elixir.
