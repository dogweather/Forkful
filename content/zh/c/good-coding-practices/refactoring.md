---
aliases:
- /zh/c/refactoring/
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 18:06:55.461141-07:00
description: "\u7F16\u7A0B\u4E2D\u7684\u91CD\u6784\u6D89\u53CA\u5728\u4E0D\u6539\u53D8\
  \u4EE3\u7801\u5916\u5728\u884C\u4E3A\u7684\u524D\u63D0\u4E0B\uFF0C\u5BF9\u73B0\u6709\
  \u4EE3\u7801\u8FDB\u884C\u7ED3\u6784\u4E0A\u7684\u91CD\u65B0\u7EC4\u7EC7\uFF0C\u65E8\
  \u5728\u6539\u5584\u975E\u529F\u80FD\u5C5E\u6027\uFF0C\u5982\u53EF\u8BFB\u6027\uFF0C\
  \u964D\u4F4E\u590D\u6742\u6027\uFF0C\u5E76\u63D0\u9AD8\u53EF\u7EF4\u62A4\u6027\u3002\
  \u7A0B\u5E8F\u5458\u8FDB\u884C\u91CD\u6784\u4EE5\u4FDD\u6301\u4EE3\u7801\u5E93\u7684\
  \u6E05\u6D01\uFF0C\u6700\u5C0F\u5316\u6280\u672F\u503A\u52A1\uFF0C\u5E76\u4F7F\u672A\
  \u6765\u7684\u66F4\u6539\u66F4\u5BB9\u6613\u548C\u66F4\u5B89\u5168\u5730\u5B9E\u65BD\
  \u3002"
lastmod: 2024-02-18 23:08:59.567554
model: gpt-4-0125-preview
summary: "\u7F16\u7A0B\u4E2D\u7684\u91CD\u6784\u6D89\u53CA\u5728\u4E0D\u6539\u53D8\
  \u4EE3\u7801\u5916\u5728\u884C\u4E3A\u7684\u524D\u63D0\u4E0B\uFF0C\u5BF9\u73B0\u6709\
  \u4EE3\u7801\u8FDB\u884C\u7ED3\u6784\u4E0A\u7684\u91CD\u65B0\u7EC4\u7EC7\uFF0C\u65E8\
  \u5728\u6539\u5584\u975E\u529F\u80FD\u5C5E\u6027\uFF0C\u5982\u53EF\u8BFB\u6027\uFF0C\
  \u964D\u4F4E\u590D\u6742\u6027\uFF0C\u5E76\u63D0\u9AD8\u53EF\u7EF4\u62A4\u6027\u3002\
  \u7A0B\u5E8F\u5458\u8FDB\u884C\u91CD\u6784\u4EE5\u4FDD\u6301\u4EE3\u7801\u5E93\u7684\
  \u6E05\u6D01\uFF0C\u6700\u5C0F\u5316\u6280\u672F\u503A\u52A1\uFF0C\u5E76\u4F7F\u672A\
  \u6765\u7684\u66F4\u6539\u66F4\u5BB9\u6613\u548C\u66F4\u5B89\u5168\u5730\u5B9E\u65BD\
  \u3002"
title: "\u91CD\u6784"
---

{{< edit_this_page >}}

## 什么是重构 & 为什么要重构?

编程中的重构涉及在不改变代码外在行为的前提下，对现有代码进行结构上的重新组织，旨在改善非功能属性，如可读性，降低复杂性，并提高可维护性。程序员进行重构以保持代码库的清洁，最小化技术债务，并使未来的更改更容易和更安全地实施。

## 如何进行：

重构可以涉及从为变量重命名以提高清晰度到更改代码结构以获得更好模块化的一系列策略。以下是一个简单的例子，展示了如何重构一段C语言代码以获得更好的清晰度和效率。

重构前：
```c
#include <stdio.h>

int main() {
    int x = 10, y = 20;
    printf("交换前: x = %d, y = %d\n", x, y);
    x = x + y; // x 现在变成了 30
    y = x - y; // y 变成了 10
    x = x - y; // x 变成了 20
    printf("交换后: x = %d, y = %d\n", x, y);
    return 0;
}
```
输出：
```
交换前: x = 10, y = 20
交换后: x = 20, y = 10
```
重构后：
```c
#include <stdio.h>

void swap(int *a, int *b) {
    *a = *a + *b;
    *b = *a - *b;
    *a = *a - *b;
}

int main() {
    int x = 10, y = 20;
    printf("交换前: x = %d, y = %d\n", x, y);
    swap(&x, &y);
    printf("交换后: x = %d, y = %d\n", x, y);
    return 0;
}
```
输出保持不变，但是交换值的功能已经被移动到了一个单独的函数（`swap`）中，提高了可读性和可重用性。

## 深入探讨

重构代码的实践自软件开发存在以来就一直在进行，随着编程范式和语言的演化而演化。在C这种既强大又充满了因其低级性质而导致的效率不高和错误机会的语言中，重构尤为关键。它可以使代码库保持可维护性，而不是变成一团错综复杂的低效之网。

对C语言特有的考虑是微观优化与可读性/可维护性之间的平衡。虽然为了挤出最后一丝性能而手动调整C代码很有诱惑力，但这样的优化可能使代码变得更脆弱，更难以阅读。因此，通常最好是优先考虑清晰、可读的代码，并依赖编译器的优化器在可能的情况下处理性能改进。

此外，C中重构的工具和技术，比如静态代码分析器（例如，Clang Static Analyzer, cppcheck）和模块化编程原则，已经有了显著的进步。然而，由于C的手动内存管理和指针算术，重构如果不小心进行，可能会引入错误。这里，单元测试和代码审查是非常宝贵的技术。

虽然较新的语言提供了更多内置支持安全重构的特性，如自动内存管理和丰富的类型系统，但在需要接近硬件的性能和细粒度控制的场景中，C仍然无与伦比。在这些情况下，重构不那么依赖于语言特性，更多地依赖于有纪律的、深思熟虑的代码重构。
