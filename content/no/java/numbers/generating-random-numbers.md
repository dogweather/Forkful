---
title:                "Generering av tilfeldige tall"
aliases:
- /no/java/generating-random-numbers/
date:                  2024-01-27T20:34:06.295851-07:00
model:                 gpt-4-0125-preview
simple_title:         "Generering av tilfeldige tall"

tag:                  "Numbers"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/no/java/generating-random-numbers.md"
---

{{< edit_this_page >}}

## Hva & Hvorfor?

Å generere tilfeldige tall handler om å produsere uforutsigbare sekvenser eller enkeltverdier innenfor et definert område. Programmerere bruker denne teknikken av en rekke grunner, inkludert simuleringer, spill, sikkerhetsapplikasjoner og prøvetakingsmetoder for å teste algoritmer under forskjellige forhold.

## Hvordan:

I Java kan generering av tilfeldige tall oppnås ved å bruke `Random`-klassen fra `java.util`-pakken, eller `ThreadLocalRandom`- og `SecureRandom`-klassene for spesifikke bruksområder. De følgende eksemplene illustrerer hvordan man bruker disse klassene.

### Bruker `Random`-klassen
`Random`-klassen tilbyr en måte å generere enkle pseudo-tilfeldige tall på.

```Java
import java.util.Random;

public class RandomExample {
    public static void main(String[] args) {
        Random rand = new Random(); // Opprett et Random-objekt

        int randInt = rand.nextInt(50); // Genererer et tilfeldig heltall fra 0 til 49
        double randDouble = rand.nextDouble(); // Genererer et tilfeldig dobbelt fra 0.0 til 1.0
        boolean randBoolean = rand.nextBoolean(); // Genererer en tilfeldig boolean
        
        System.out.println("Tilfeldig Int: " + randInt);
        System.out.println("Tilfeldig Double: " + randDouble);
        System.out.println("Tilfeldig Boolean: " + randBoolean);
    }
}
```

### Bruker `ThreadLocalRandom`-klassen
For samtidige applikasjoner er `ThreadLocalRandom` mer effektiv enn `Random`.

```Java
import java.util.concurrent.ThreadLocalRandom;

public class ThreadLocalRandomExample {
    public static void main(String[] args) {
        int randInt = ThreadLocalRandom.current().nextInt(1, 101); // Fra 1 til 100
        double randDouble = ThreadLocalRandom.current().nextDouble(1.0, 10.0); // Fra 1.0 til 10.0
        
        System.out.println("Tilfeldig Int: " + randInt);
        System.out.println("Tilfeldig Double: " + randDouble);
    }
}
```

### Bruker `SecureRandom`-klassen
For kryptografiske operasjoner tilbyr `SecureRandom` et høyere sikkerhetsnivå.

```Java
import java.security.SecureRandom;

public class SecureRandomExample {
    public static void main(String[] args) {
        SecureRandom secRand = new SecureRandom();
        
        byte[] bytes = new byte[20];
        secRand.nextBytes(bytes); // Fyller bytes med sikre tilfeldige tall
        
        System.out.println("Sikre Tilfeldige Bytes:");
        for (byte b : bytes) {
            System.out.printf("%02x ", b);
        }
    }
}
```

## Dypdykk

Generering av tilfeldige tall har utviklet seg betydelig siden begynnelsen av databehandling. Javas `Random`-klasse bruker en lineær kongruentformel for å generere pseudo-tilfeldige tall, som er deterministiske og ikke egnet for høy-sikkerhetsapplikasjoner. Dette førte til introduksjonen av `SecureRandom`, som bruker mer sofistikerte algoritmer (f.eks. SHA1PRNG) for å produsere kryptografisk sterke tilfeldige tall.

Imidlertid har `Random` og `SecureRandom` sine mangler, som forringelse av ytelsen i flertrådede miljøer. `ThreadLocalRandom`-klassen ble introdusert i Java 7 for å håndtere dette problemet ved å tilby trådslokale tilfeldige tallgeneratorer, noe som betydelig forbedrer ytelsen i samtidige applikasjoner.

Selv om disse klassene dekker de fleste behov, kan utviklere for ekstremt storskala eller spesialiserte krav utforske ytterligere biblioteker eller utvikle egendefinerte løsninger. Det er avgjørende å velge den riktige tilnærmingen basert på bruksområdets sikkerhetsbehov og ytelseskrav.
