---
changelog:
- 2024-03-17, gpt-4-0125-preview, translated from English
date: 2024-03-17 21:50:15.523690-06:00
description: "\u0E01\u0E32\u0E23\u0E1B\u0E23\u0E31\u0E1A\u0E42\u0E04\u0E23\u0E07\u0E2A\
  \u0E23\u0E49\u0E32\u0E07 (Refactoring) \u0E40\u0E1B\u0E47\u0E19\u0E01\u0E23\u0E30\
  \u0E1A\u0E27\u0E19\u0E01\u0E32\u0E23\u0E02\u0E2D\u0E07\u0E01\u0E32\u0E23\u0E1B\u0E23\
  \u0E31\u0E1A\u0E40\u0E1B\u0E25\u0E35\u0E48\u0E22\u0E19\u0E42\u0E04\u0E49\u0E14\u0E02\
  \u0E2D\u0E07\u0E04\u0E38\u0E13\u0E42\u0E14\u0E22\u0E44\u0E21\u0E48\u0E40\u0E1B\u0E25\
  \u0E35\u0E48\u0E22\u0E19\u0E41\u0E1B\u0E25\u0E07\u0E1E\u0E24\u0E15\u0E34\u0E01\u0E23\
  \u0E23\u0E21\u0E20\u0E32\u0E22\u0E19\u0E2D\u0E01\u0E02\u0E2D\u0E07\u0E21\u0E31\u0E19\
  \u2026"
lastmod: '2024-03-17T21:57:56.276489-06:00'
model: gpt-4-0125-preview
summary: "\u0E01\u0E32\u0E23\u0E1B\u0E23\u0E31\u0E1A\u0E42\u0E04\u0E23\u0E07\u0E2A\
  \u0E23\u0E49\u0E32\u0E07 (Refactoring) \u0E40\u0E1B\u0E47\u0E19\u0E01\u0E23\u0E30\
  \u0E1A\u0E27\u0E19\u0E01\u0E32\u0E23\u0E02\u0E2D\u0E07\u0E01\u0E32\u0E23\u0E1B\u0E23\
  \u0E31\u0E1A\u0E40\u0E1B\u0E25\u0E35\u0E48\u0E22\u0E19\u0E42\u0E04\u0E49\u0E14\u0E02\
  \u0E2D\u0E07\u0E04\u0E38\u0E13\u0E42\u0E14\u0E22\u0E44\u0E21\u0E48\u0E40\u0E1B\u0E25\
  \u0E35\u0E48\u0E22\u0E19\u0E41\u0E1B\u0E25\u0E07\u0E1E\u0E24\u0E15\u0E34\u0E01\u0E23\
  \u0E23\u0E21\u0E20\u0E32\u0E22\u0E19\u0E2D\u0E01\u0E02\u0E2D\u0E07\u0E21\u0E31\u0E19\
  \ \u0E21\u0E31\u0E19\u0E40\u0E1B\u0E47\u0E19\u0E40\u0E23\u0E37\u0E48\u0E2D\u0E07\
  \u0E02\u0E2D\u0E07\u0E01\u0E32\u0E23\u0E17\u0E33\u0E04\u0E27\u0E32\u0E21\u0E2A\u0E30\
  \u0E2D\u0E32\u0E14\u0E41\u0E25\u0E30\u0E08\u0E31\u0E14\u0E23\u0E30\u0E40\u0E1A\u0E35\
  \u0E22\u0E1A\u0E01\u0E32\u0E23\u0E17\u0E33\u0E07\u0E32\u0E19\u0E02\u0E2D\u0E07\u0E04\
  \u0E38\u0E13\u0E40\u0E1E\u0E37\u0E48\u0E2D\u0E17\u0E33\u0E43\u0E2B\u0E49\u0E42\u0E04\
  \u0E49\u0E14\u0E19\u0E31\u0E49\u0E19\u0E2D\u0E48\u0E32\u0E19\u0E44\u0E14\u0E49\u0E07\
  \u0E48\u0E32\u0E22\u0E02\u0E36\u0E49\u0E19 \u0E14\u0E39\u0E41\u0E25\u0E23\u0E31\u0E01\
  \u0E29\u0E32\u0E44\u0E14\u0E49\u0E07\u0E48\u0E32\u0E22\u0E02\u0E36\u0E49\u0E19 \u0E41\
  \u0E25\u0E30\u0E02\u0E22\u0E32\u0E22\u0E44\u0E14\u0E49\u0E07\u0E48\u0E32\u0E22\u0E02\
  \u0E36\u0E49\u0E19 \u0E21\u0E31\u0E19\u0E22\u0E31\u0E07\u0E2A\u0E32\u0E21\u0E32\u0E23\
  \u0E16\u0E0A\u0E48\u0E27\u0E22\u0E25\u0E14\u0E1A\u0E31\u0E49\u0E01\u0E41\u0E25\u0E30\
  \u0E1B\u0E23\u0E31\u0E1A\u0E1B\u0E23\u0E38\u0E07\u0E1B\u0E23\u0E30\u0E2A\u0E34\u0E17\
  \u0E18\u0E34\u0E20\u0E32\u0E1E\u0E44\u0E14\u0E49\u0E2D\u0E35\u0E01\u0E14\u0E49\u0E27\
  \u0E22."
title: "\u0E01\u0E32\u0E23\u0E1B\u0E23\u0E31\u0E1A\u0E42\u0E04\u0E23\u0E07\u0E2A\u0E23\
  \u0E49\u0E32\u0E07\u0E42\u0E04\u0E49\u0E14"
weight: 19
---

## วิธีการ:
สมมติว่าคุณมีชิ้นส่วนของโค้ด Haskell ที่ซ้ำซากจำเจเหมือนเพลงโปรดของคุณ นี่คือการดูอย่างรวดเร็วว่าคุณอาจจะปรับโครงสร้างนั้นได้อย่างไรโดยใช้ฟังก์ชั่น

ก่อนการปรับโครงสร้าง:

```haskell
printInvoice :: String -> Float -> String -> IO ()
printInvoice customer total item = do
  putStrLn $ "Customer: " ++ customer
  putStrLn $ "Total: " ++ show total
  putStrLn $ "Item: " ++ item
```

หลังจากการปรับโครงสร้างเล็กน้อย:

```haskell
printDetail :: String -> String -> IO ()
printDetail label value = putStrLn $ label ++ ": " ++ value

printInvoice :: String -> Float -> String -> IO ()
printInvoice customer total item = do
  printDetail "Customer" customer
  printDetail "Total" (show total)
  printDetail "Item" item

-- ตัวอย่างผลลัพธ์:
-- Customer: Alice
-- Total: $42.00
-- Item: Haskell Programming Guide
```

อย่างที่คุณเห็นได้ โดยการสร้างฟังก์ชั่น `printDetail` แยกออกมา เราสามารถหลีกเลี่ยงการซ้ำซากและทำให้ `printInvoice` ชัดเจนและง่ายต่อการจัดการมากขึ้น

## การศึกษาลึก
เมื่อ Haskell เปิดตัวในช่วงปลายยุค 80's ก็ชัดเจนว่าพาราไดม์ฟังก์ชันนัลสามารถนำเสนอมุมมองใหม่ให้กับการปฏิบัติการเขียนโค้ด ดำเนินเวลามาถึงปัจจุบัน และการปรับโครงสร้างใน Haskell นั้นโดยเฉพาะมีความงดงาม ขอบคุณที่ฟังก์ชันเป็นพลเมืองชั้นหนึ่งและมีระบบประเภทที่แข็งแกร่ง คุณสามารถปรับโครงสร้างโดยไม่ต้องกลัวว่าคุณจะทำให้แอปของคุณเสียหาย เนื่องจากคอมไพเลอร์ช่วยสนับสนุนคุณอยู่

ทางเลือกอื่นสำหรับการปรับโครงสร้างด้วยตนเองอาจรวมถึงการใช้เครื่องมืออัตโนมัติ แม้ว่าธรรมชาติของฟังก์ชันและความปลอดภัยของประเภทใน Haskell อาจทำให้สิ่งนี้ไม่นิยมเท่ากับภาษาอื่นๆ ในการทำงาน มันสำคัญที่จะต้องใช้ประโยชน์จากคุณสมบัติของ Haskell เช่น ฟังก์ชั่นของออร์เดอร์ที่สูงขึ้น เพียวริตี้ และความไม่เปลี่ยนแปลงเพื่อทำให้การปรับโครงสร้างเป็นไปอย่างราบรื่น

การปรับโครงสร้างเช่น "การแยกฟังก์ชั่น" ที่เพิ่งแสดงไปนั้นเป็นเรื่องปกติ แต่คุณยังสามารถทำ "การรวมฟังก์ชั่น" "การเปลี่ยนชื่อตัวแปร" และ "การเปลี่ยนลายเซ็นของฟังก์ชั่น" ได้อย่างมั่นใจ ขอบคุณที่ระบบประเภท การอนุมานประเภทที่แข็งแกร่งของ Haskell บางครั้งสามารถจับความผิดพลาดที่อาจหลุดลอดผ่านในภาษาอื่น

## ดูเพิ่มเติม
สำหรับการศึกษาลึกเกี่ยวกับการปรับโครงสร้างใน Haskell อ่านหนังสือ "Refactoring: Improving the Design of Existing Code" โดย Martin Fowler ที่แนะนำแนวคิดที่มีความเกี่ยวข้องกันทั่วไป ลองใช้เครื่องมือ hlint สำหรับคำแนะนำอัตโนมัติในการปรับปรุงโค้ด Haskell ของคุณ นอกจากนี้ แวะไปที่วิกิ Haskell (https://wiki.haskell.org/Refactoring) เพื่อข้อมูลเชิงลึกจากชุมชนและการอ่านเพิ่มเติม
