---
changelog:
- 2024-03-17, gpt-4-0125-preview, translated from English
date: 2024-03-17 21:52:28.607172-06:00
description: "\u0E19\u0E34\u0E1E\u0E08\u0E19\u0E4C\u0E1B\u0E23\u0E01\u0E15\u0E34 (regular\
  \ expressions \u0E2B\u0E23\u0E37\u0E2D regex) \u0E40\u0E1B\u0E47\u0E19\u0E25\u0E33\
  \u0E14\u0E31\u0E1A\u0E02\u0E2D\u0E07\u0E2D\u0E31\u0E01\u0E02\u0E23\u0E30\u0E17\u0E35\
  \u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E01\u0E32\
  \u0E23\u0E04\u0E49\u0E19\u0E2B\u0E32 \u0E0B\u0E36\u0E48\u0E07\u0E43\u0E0A\u0E49\u0E1E\
  \u0E37\u0E49\u0E19\u0E10\u0E32\u0E19\u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A\u0E01\u0E32\
  \u0E23\u0E15\u0E23\u0E07\u0E01\u0E31\u0E19\u0E41\u0E25\u0E30\u0E01\u0E32\u0E23\u0E08\
  \u0E31\u0E14\u0E01\u0E32\u0E23\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u2026"
lastmod: '2024-03-17T21:57:56.472067-06:00'
model: gpt-4-0125-preview
summary: "\u0E19\u0E34\u0E1E\u0E08\u0E19\u0E4C\u0E1B\u0E23\u0E01\u0E15\u0E34 (regular\
  \ expressions \u0E2B\u0E23\u0E37\u0E2D regex) \u0E40\u0E1B\u0E47\u0E19\u0E25\u0E33\
  \u0E14\u0E31\u0E1A\u0E02\u0E2D\u0E07\u0E2D\u0E31\u0E01\u0E02\u0E23\u0E30\u0E17\u0E35\
  \u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E01\u0E32\
  \u0E23\u0E04\u0E49\u0E19\u0E2B\u0E32 \u0E0B\u0E36\u0E48\u0E07\u0E43\u0E0A\u0E49\u0E1E\
  \u0E37\u0E49\u0E19\u0E10\u0E32\u0E19\u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A\u0E01\u0E32\
  \u0E23\u0E15\u0E23\u0E07\u0E01\u0E31\u0E19\u0E41\u0E25\u0E30\u0E01\u0E32\u0E23\u0E08\
  \u0E31\u0E14\u0E01\u0E32\u0E23\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21 \u0E42\u0E1B\
  \u0E23\u0E41\u0E01\u0E23\u0E21\u0E40\u0E21\u0E2D\u0E23\u0E4C\u0E43\u0E0A\u0E49\u0E1B\
  \u0E23\u0E30\u0E42\u0E22\u0E0A\u0E19\u0E4C\u0E08\u0E32\u0E01 regex \u0E43\u0E19\u0E42\
  \u0E1B\u0E23\u0E40\u0E08\u0E01\u0E15\u0E4C Arduino \u0E2A\u0E33\u0E2B\u0E23\u0E31\
  \u0E1A\u0E01\u0E32\u0E23\u0E27\u0E34\u0E40\u0E04\u0E23\u0E32\u0E30\u0E2B\u0E4C\u0E02\
  \u0E49\u0E2D\u0E21\u0E39\u0E25\u0E2D\u0E34\u0E19\u0E1E\u0E38\u0E15\u0E08\u0E32\u0E01\
  \u0E0B\u0E35\u0E40\u0E23\u0E35\u0E22\u0E25, \u0E01\u0E32\u0E23\u0E15\u0E23\u0E27\
  \u0E08\u0E2A\u0E2D\u0E1A\u0E04\u0E27\u0E32\u0E21\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\
  \u0E07\u0E02\u0E2D\u0E07\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E2D\u0E34\u0E19\u0E1E\
  \u0E38\u0E15\u0E08\u0E32\u0E01\u0E1C\u0E39\u0E49\u0E43\u0E0A\u0E49, \u0E2B\u0E23\
  \u0E37\u0E2D\u0E01\u0E32\u0E23\u0E2A\u0E01\u0E31\u0E14\u0E02\u0E49\u0E2D\u0E21\u0E39\
  \u0E25\u0E08\u0E32\u0E01\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21 \u0E0B\u0E36\u0E48\
  \u0E07\u0E0A\u0E48\u0E27\u0E22\u0E40\u0E1E\u0E34\u0E48\u0E21\u0E1B\u0E23\u0E30\u0E2A\
  \u0E34\u0E17\u0E18\u0E34\u0E20\u0E32\u0E1E\u0E41\u0E25\u0E30\u0E04\u0E27\u0E32\u0E21\
  \u0E22\u0E37\u0E14\u0E2B\u0E22\u0E38\u0E48\u0E19\u0E43\u0E19\u0E01\u0E32\u0E23\u0E1B\
  \u0E23\u0E30\u0E21\u0E27\u0E25\u0E1C\u0E25\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25."
title: "\u0E01\u0E32\u0E23\u0E43\u0E0A\u0E49\u0E40\u0E23\u0E01\u0E38\u0E25\u0E32\u0E23\
  \u0E4C\u0E40\u0E2D\u0E47\u0E01\u0E40\u0E1E\u0E23\u0E2A\u0E0A\u0E31\u0E19"
weight: 11
---

## วิธีการ:
Arduino ไม่มีการสนับสนุน regex อย่างตรงไปตรงมาในไลบรารีมาตรฐาน อย่างไรก็ตาม คุณสามารถบรรลุฟังก์ชันคล้ายคลึงกับ regex สำหรับรูปแบบที่ง่ายๆ โดยใช้ฟังก์ชันต่างๆ ของข้อความ หรือสำหรับความต้องการที่ซับซ้อนกว่า สามารถทำการรวมไลบรารีของบุคคลที่สาม เช่น `regex`

### การจับคู่ข้อความพื้นฐานโดยไม่ใช้ Regex
สำหรับความต้องการพื้นฐาน เช่น การหาข้อความย่อย คุณสามารถใช้ฟังก์ชัน `String.indexOf()`:
```cpp
String data = "Sensor value: 12345";
int index = data.indexOf("value:");
if (index != -1) {
  String value = data.substring(index + 6).trim();
  Serial.println(value); // แสดงผล: 12345
}
```

### การใช้ไลบรารีของบุคคลที่สามสำหรับ Regex
เพื่อจัดการกับรูปแบบที่ซับซ้อนกว่า คุณอาจพิจารณาใช้ไลบรารี เช่น `regex` หลังจากติดตั้งไลบรารีแล้ว คุณสามารถใช้งานได้ดังนี้:

1. **การติดตั้ง**: ไลบรารี `regex` อาจไม่พร้อมใช้งานใน Arduino Library Manager โดยทันที ดังนั้นคุณอาจจำเป็นต้องติดตั้งด้วยตนเอง โดยดาวน์โหลดจากแหล่งที่น่าเชื่อถือและเพิ่มเข้าไปในโฟลเดอร์ไลบรารี Arduino ของคุณ

2. **ตัวอย่างการใช้งาน**:
สมมติว่าไลบรารีมีฟังก์ชันที่คล้ายคลึงกับการดำเนินการของ regex มาตรฐาน คุณอาจใช้งานมันดังนี้:

```cpp
#include <regex.h>

void setup() {
  Serial.begin(9600);
  while (!Serial); // รอจนกว่า Serial จะพร้อม
  
  regex_t reg;
  const char* pattern = "[0-9]+"; // ตรงกับลำดับของตัวเลข
  regcomp(&reg, pattern, REG_EXTENDED);
  
  const char* test_str = "Sensor value: 12345";
  
  regmatch_t matches[1];
  if (regexec(&reg, test_str, 1, matches, 0) == 0) {
    // สกัดและพิมพ์ส่วนที่ตรงกัน
    int start = matches[0].rm_so;
    int end = matches[0].rm_eo;
    char match[end-start+1];
    strncpy(match, test_str + start, end-start);
    match[end-start] = '\0';
    
    Serial.print("พบการจับคู่: ");
    Serial.println(match); // แสดงผล: 12345
  } else {
    Serial.println("ไม่พบการจับคู่");
  }
  
  regfree(&reg); // ปล่อยหน่วยความจำที่จัดสรรไว้สำหรับ regex
}

void loop() {
  // ใส่โค้ดหลักของคุณที่นี่ เพื่อทำงานซ้ำๆ:
}
```

**หมายเหตุ**: ไวยากรณ์และฟังก์ชันเฉพาะที่ใช้ที่นี่คือเพื่อการอธิบายเท่านั้น และอาจแตกต่างตามรายละเอียดการดำเนินการจริงของไลบรารี `regex` ที่คุณเลือก ควรอ้างอิงเอกสารของไลบรารีเสมอเพื่อข้อมูลที่แม่นยำและอัปเดต.
