---
changelog:
- 2024-03-17, OpenAIModel.GPT_4_TURBO, translated from English
date: 2024-03-17 17:48:26.721164-06:00
description: "C \u09AD\u09BE\u09B7\u09BE\u09AF\u09BC \u09B8\u09BE\u09AC\u09B8\u09CD\
  \u099F\u09CD\u09B0\u09BF\u0982 \u098F\u0995\u09CD\u09B8\u099F\u09CD\u09B0\u09BE\u0995\
  \u09CD\u099F \u0995\u09B0\u09BE \u09AE\u09BE\u09A8\u09C7 \u09A8\u09BF\u09B0\u09CD\
  \u09A6\u09BF\u09B7\u09CD\u099F \u0995\u09CD\u09B0\u09BE\u0987\u099F\u09C7\u09B0\u09BF\
  \u09AF\u09BC\u09BE, \u09AF\u09C7\u09AE\u09A8 \u0985\u09AC\u09B8\u09CD\u09A5\u09BE\
  \u09A8 \u098F\u09AC\u0982 \u09A6\u09C8\u09B0\u09CD\u0998\u09CD\u09AF\u09C7\u09B0\
  \ \u09AD\u09BF\u09A4\u09CD\u09A4\u09BF\u09A4\u09C7 \u098F\u0995\u099F\u09BF \u09AC\
  \u09A1\u09BC \u09B8\u09CD\u099F\u09CD\u09B0\u09BF\u0982 \u09A5\u09C7\u0995\u09C7\
  \ \u098F\u0995\u099F\u09BF \u099B\u09CB\u099F \u09B8\u09CD\u099F\u09CD\u09B0\u09BF\
  \u0982 (\u09B8\u09BE\u09AC\u09B8\u09CD\u099F\u09CD\u09B0\u09BF\u0982)\u2026"
lastmod: '2024-03-17T18:47:44.529791-06:00'
model: gpt-4-0125-preview
summary: "C \u09AD\u09BE\u09B7\u09BE\u09AF\u09BC \u09B8\u09BE\u09AC\u09B8\u09CD\u099F\
  \u09CD\u09B0\u09BF\u0982 \u098F\u0995\u09CD\u09B8\u099F\u09CD\u09B0\u09BE\u0995\u09CD\
  \u099F \u0995\u09B0\u09BE \u09AE\u09BE\u09A8\u09C7 \u09A8\u09BF\u09B0\u09CD\u09A6\
  \u09BF\u09B7\u09CD\u099F \u0995\u09CD\u09B0\u09BE\u0987\u099F\u09C7\u09B0\u09BF\u09AF\
  \u09BC\u09BE, \u09AF\u09C7\u09AE\u09A8 \u0985\u09AC\u09B8\u09CD\u09A5\u09BE\u09A8\
  \ \u098F\u09AC\u0982 \u09A6\u09C8\u09B0\u09CD\u0998\u09CD\u09AF\u09C7\u09B0 \u09AD\
  \u09BF\u09A4\u09CD\u09A4\u09BF\u09A4\u09C7 \u098F\u0995\u099F\u09BF \u09AC\u09A1\
  \u09BC \u09B8\u09CD\u099F\u09CD\u09B0\u09BF\u0982 \u09A5\u09C7\u0995\u09C7 \u098F\
  \u0995\u099F\u09BF \u099B\u09CB\u099F \u09B8\u09CD\u099F\u09CD\u09B0\u09BF\u0982\
  \ (\u09B8\u09BE\u09AC\u09B8\u09CD\u099F\u09CD\u09B0\u09BF\u0982) \u09A4\u09C8\u09B0\
  \u09BF \u0995\u09B0\u09BE\u0964 \u09AA\u09CD\u09B0\u09CB\u0997\u09CD\u09B0\u09BE\
  \u09AE\u09BE\u09B0\u09B0\u09BE \u09AA\u09CD\u09B0\u09BE\u09AF\u09BC\u09B6\u0987\
  \ \u099F\u09C7\u0995\u09CD\u09B8\u099F \u09AA\u09BE\u09B0\u09CD\u09B8\u09BF\u0982\
  , \u09A1\u09C7\u099F\u09BE \u09AA\u09CD\u09B0\u0995\u09CD\u09B0\u09BF\u09AF\u09BC\
  \u09BE\u0995\u09B0\u09A3 \u09AC\u09BE \u0987\u09A8\u09AA\u09C1\u099F \u09AD\u09CD\
  \u09AF\u09BE\u09B2\u09BF\u09A1\u09C7\u09B6\u09A8\u09C7\u09B0 \u099C\u09A8\u09CD\u09AF\
  \ \u098F\u0987 \u0995\u09BE\u099C\u099F\u09BF \u0995\u09B0\u09C7 \u09A5\u09BE\u0995\
  \u09C7\u09A8, \u09AF\u09BE \u099F\u09C7\u0995\u09CD\u09B8\u099F \u09A1\u09C7\u099F\
  \u09BE \u09A6\u0995\u09CD\u09B7\u09A4\u09BE\u09B0 \u09B8\u09BE\u09A5\u09C7 \u09AE\
  \u09CD\u09AF\u09BE\u09A8\u09BF\u09AA\u09C1\u09B2\u09C7\u099F \u098F\u09AC\u0982\
  \ \u09AC\u09BF\u09B6\u09CD\u09B2\u09C7\u09B7\u09A3 \u0995\u09B0\u09BE\u09B0 \u098F\
  \u0995\u099F\u09BF \u0985\u09AA\u09B0\u09BF\u09B9\u09BE\u09B0\u09CD\u09AF \u09A6\
  \u0995\u09CD\u09B7\u09A4\u09BE\u0964."
title: "\u09B8\u09BE\u09AC\u09B8\u09CD\u099F\u09CD\u09B0\u09BF\u0982 \u09AC\u09C7\u09B0\
  \ \u0995\u09B0\u09BE"
weight: 6
---

## কিভাবে:
সাবস্ট্রিং এক্সট্রাকশনের জন্য বিল্ট-ইন মেথড সরবরাহ করা উচ্চ স্তরের ভাষাগুলির মতো নয়, C ভাষার একটি ম্যানুয়াল পদ্ধতি প্রয়োজন হয় যা এর স্ট্রিং ম্যানিপুলেশন ফাংশনগুলি ব্যবহার করে। এখানে দেখানো হলো C-তে সাবস্ট্রিং কিভাবে এফেক্টিভলি এক্সট্রাক্ট করতে হয়:

### উদাহরণ 1: `strncpy` ব্যবহার করে
```c
#include <stdio.h>
#include <string.h>

int main() {
    char text[] = "Hello, World!";
    char buffer[20];

    // "Hello, World!" থেকে "World" এক্সট্রাক্ট করা
    strncpy(buffer, text + 7, 5);
    buffer[5] = '\0'; // নাল-টার্মিনেশন নিশ্চিত করা

    printf("Extracted substring: %s\n", buffer);
    // আউটপুট: Extracted substring: World
    return 0;
}
```

### উদাহরণ 2: ফাংশন তৈরি করে
বার বার ব্যবহারের জন্য, সাবস্ট্রিং এক্সট্রাক্ট করার জন্য একটি নির্দিষ্ট ফাংশন তৈরি করা আরো দক্ষ হতে পারে:

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void extractSubstring(char *source, int from, int n, char *target) {
    strncpy(target, source + from, n);
    target[n] = '\0'; // নাল-টার্মিনেশন নিশ্চিত করা
}

int main() {
    char text[] = "Programming in C";
    char buffer[50];

    extractSubstring(text, 0, 11, buffer);
    printf("Extracted substring: %s\n", buffer);
    // আউটপুট: Extracted substring: Programming
    return 0;
}
```

## গভীরে ডুব:
C ভাষায় সাবস্ট্রিং এক্সট্রাক্ট করা মূলত পয়েন্টার ম্যানিপুলেশন এবং সাবধানী মেমোরি ম্যানেজমেন্টের মাধ্যমে হ্যান্ডেল করা হয়, যা C ভাষার ডেটা হ্যান্ডলিং পদ্ধতির নীচের স্তরের প্রতিফলিত করে। এই পদ্ধতি C প্রোগ্রামিংয়ের প্রাথমিক দিনগুলিতে ব্যাক ডেটিং করে, যখন সীমিত কম্পিউটিং শক্তির কারণে সম্পদগুলি দক্ষতার সাথে ম্যানেজ করা অত্যন্ত জরুরি ছিল। একটি বিল্ট-ইন সাবস্ট্রিং ফাংশনের অনুপস্থিতি একটি অবহেলা মনে হলেও, এটি C ভাষার দর্শনের উদাহরণ, যা প্রোগ্রামারদের মেমোরি ম্যানেজমেন্টের উপর সম্পূর্ণ নিয়ন্ত্রণ দেয়, প্রায়শই অপ্টিমাইজড কিন্তু জটিল কোডের দিকে নিয়ে যায়।

আধুনিক প্রোগ্রামিং এর জগতে, পাইথন এবং জাভাস্ক্রিপ্টের মতো উচ্চ স্তরের ভাষাগুলি `slice()` বা স্ট্রিং স্লাইসিং ইন্ডিসেস ব্যবহার করে সাবস্ট্রিং এক্সট্রাকশনের জন্য বিল্ট-ইন মেথড সরবরাহ করে। এই উচ্চ স্তরের ভাষাগুলি মেমোরি ম্যানেজমেন্ট পেছনের দিকে হ্যান্ডল করে, ব্যবহারের সহজতা এবং পঠনীয়তার জন্য কিছুটা নিয়ন্ত্রণ ত্যাগ করে।

C প্রোগ্রামারদের জন্য, পয়েন্টার অ্যারিথমেটিক এবং মেমোরি অ্যালোকেশন বুঝতে পারা সাবস্ট্রিং এক্সট্রাকশনের মতো কাজের জন্য অপরিহার্য। যদিও এই পদ্ধতির জন্য স্ট্রিংগুলিকে কীভাবে মেমোরিতে প্রতিনিধিত্ব করা এবং ম্যানিপুলেট করা হয় তা বুঝতে হবে আরো গভীর ধারণা, এটি নিয়ন্ত্রণ এবং দক্ষতার অতুলনীয়, C প্রোগ্রামিং-এর হলমার্ক বৈশিষ্ট্য দেয়, যা এটিকে দশক ধরে পারফরমেন্স-সংবেদনশীল অ্যাপ্লিকেশনগুলিতে প্রাসঙ্গিক রেখেছে। তবে, যেসব কাজে সরাসরি মেমোরি ম্যানেজমেন্টের তেমন একটা চিন্তা নেই, সেসবের জন্য বিল্ট-ইন সাবস্ট্রিং ফাংশনালিটিসমৃদ্ধ ভাষাগুলি একটি সোজাসাপ্টা এবং কম ভুলের সম্মুখীন পদ্ধতি অফার করতে পারে।
