---
changelog:
- 2024-03-17, gpt-4-0125-preview, translated from English
date: 2024-03-17 18:39:01.169345-06:00
description: "\u09AA\u09CD\u09B0\u09CB\u0997\u09CD\u09B0\u09BE\u09AE\u09BF\u0982\u09AF\
  \u09BC\u09C7 \u099C\u099F\u09BF\u09B2 \u09B8\u0982\u0996\u09CD\u09AF\u09BE\u09B0\
  \ \u09B8\u09BE\u09A5\u09C7 \u0995\u09BE\u099C \u0995\u09B0\u09BE \u09AE\u09BE\u09A8\
  \u09C7 \u098F\u09AE\u09A8 \u09B8\u0982\u0996\u09CD\u09AF\u09BE \u09A8\u09BF\u09AF\
  \u09BC\u09C7 \u0995\u09BE\u099C \u0995\u09B0\u09BE \u09AF\u09BE\u09B0\u09BE \u098F\
  \u0995\u099F\u09BF \u09AC\u09BE\u09B8\u09CD\u09A4\u09AC \u098F\u09AC\u0982 \u098F\
  \u0995\u099F\u09BF \u0995\u09BE\u09B2\u09CD\u09AA\u09A8\u09BF\u0995 \u0985\u0982\
  \u09B6 \u09A8\u09BF\u09AF\u09C7 \u0997\u09A0\u09BF\u09A4, \u09B8\u09BE\u09A7\u09BE\
  \u09B0\u09A3\u09A4 `a + bi` \u0986\u0995\u09BE\u09B0\u09C7 \u09AA\u09CD\u09B0\u0995\
  \u09BE\u09B6 \u0995\u09B0\u09BE\u2026"
lastmod: '2024-03-17T18:47:43.467852-06:00'
model: gpt-4-0125-preview
summary: "\u09AA\u09CD\u09B0\u09CB\u0997\u09CD\u09B0\u09BE\u09AE\u09BF\u0982\u09AF\
  \u09BC\u09C7 \u099C\u099F\u09BF\u09B2 \u09B8\u0982\u0996\u09CD\u09AF\u09BE\u09B0\
  \ \u09B8\u09BE\u09A5\u09C7 \u0995\u09BE\u099C \u0995\u09B0\u09BE \u09AE\u09BE\u09A8\
  \u09C7 \u098F\u09AE\u09A8 \u09B8\u0982\u0996\u09CD\u09AF\u09BE \u09A8\u09BF\u09AF\
  \u09BC\u09C7 \u0995\u09BE\u099C \u0995\u09B0\u09BE \u09AF\u09BE\u09B0\u09BE \u098F\
  \u0995\u099F\u09BF \u09AC\u09BE\u09B8\u09CD\u09A4\u09AC \u098F\u09AC\u0982 \u098F\
  \u0995\u099F\u09BF \u0995\u09BE\u09B2\u09CD\u09AA\u09A8\u09BF\u0995 \u0985\u0982\
  \u09B6 \u09A8\u09BF\u09AF\u09C7 \u0997\u09A0\u09BF\u09A4, \u09B8\u09BE\u09A7\u09BE\
  \u09B0\u09A3\u09A4 `a + bi` \u0986\u0995\u09BE\u09B0\u09C7 \u09AA\u09CD\u09B0\u0995\
  \u09BE\u09B6 \u0995\u09B0\u09BE\u2026"
title: "\u099C\u099F\u09BF\u09B2 \u09B8\u0982\u0996\u09CD\u09AF\u09BE\u09B0 \u09B8\
  \u09BE\u09A5\u09C7 \u0995\u09BE\u099C \u0995\u09B0\u09BE"
---

{{< edit_this_page >}}

## কি এবং কেন?

প্রোগ্রামিংয়ে জটিল সংখ্যার সাথে কাজ করা মানে এমন সংখ্যা নিয়ে কাজ করা যারা একটি বাস্তব এবং একটি কাল্পনিক অংশ নিযে গঠিত, সাধারণত `a + bi` আকারে প্রকাশ করা হয়। প্রোগ্রামাররা নেতিবাচক সংখ্যার বর্গমূল, ওয়েভফর্ম বিশ্লেষণ এবং আরো অনেক কিছুর সমস্যা সমাধানের জন্য ইঞ্জিনিয়ারিং, ফিজিক্স, এবং ডেটা বিশ্লেষণের মত বিভিন্ন ডোমেইনে জটিল সংখ্যার সাথে কাজ করেন।

## কিভাবে:

Go তে, জটিল সংখ্যাগুলি বিল্ট-ইন `complex`, `real`, এবং `imag` ফাংশন এবং `complex64` এবং `complex128` টাইপ (যথাক্রমে 64-বিট এবং 128-বিট জটিল সংখ্যা প্রকাশ করে) ব্যবহার করে সামাল দেওয়া হয়। এখানে একটি দ্রুত সূচি পাঠ:

```go
package main

import (
	"fmt"
)

func main() {
	// জটিল সংখ্যা তৈরি করা
	a := complex(2, 3) // 2+3i
	b := complex(1, -1) // 1-1i

	// অ্যারিথমেটিক অপারেশন
	c := a + b
	fmt.Println("Addition:", c) // আউটপুট: Addition: (3+2i)

	d := a * b
	fmt.Println("Multiplication:", d) // আউটপুট: Multiplication: (5+1i)

	// বাস্তব এবং কাল্পনিক অংশ অ্যাক্সেস করা
	realPart := real(a)
	imagPart := imag(a)
	fmt.Printf("Real part: %.1f, Imaginary part: %.1f\n", realPart, imagPart) // আউটপুট: Real part: 2.0, Imaginary part: 3.0

	// কমপ্লেক্স কনজুগেট এবং ম্যাগনিটিউড হিসাব করা যেতে পারে
	conjugate := complex(real(a), -imag(a)) // ম্যানুয়ালি
	fmt.Println("Conjugate of a:", conjugate) // আউটপুট: Conjugate of a: (2-3i)
}

```

এই উদাহরণটি মৌলিক বিষয়গুলি আবরণ করে, কিন্তু জটিল সংখ্যা নিয়ে আপনি অনেক বেশি কাজ করতে পারেন, `math/cmplx` প্যাকেজটি ব্যবহার করে ম্যাগনিটিউড, ফেজ এবং আরও অনেক কিছু খুঁজে পেতে অধিক উন্নত অপারেশন সম্পর্কে ভাবনা চিন্তা করতে পারেন।

## গভীর ডাইভ

জটিল সংখ্যার ধারণাটি 16 শতাব্দী থেকে আসে, তবে 19 শতাব্দীতে প্রশস্ত স্বীকৃতি এবং কঠোর সমর্থন পেয়েছে। কম্পিউটার প্রোগ্রামিং-এ, বিজ্ঞান ও ইঞ্জিনিয়ারিং গণনাতে জটিল অঙ্কনের জন্য জটিল সংখ্যা প্রারম্ভিক দিন থেকেই একটি মৌলিক উপাদান হয়ে আছে। Go এর জটিল সংখ্যাগুলির প্রতি দৃষ্টিভঙ্গি, বিল্ট-ইন সমর্থন এবং `math/cmplx` প্যাকেজের মাধ্যমে সম্পূর্ণ স্ট্যান্ডার্ড লাইব্রেরির সমর্থন সহ তাদের প্রথম শ্রেণির নাগরিক হিসাবে তৈরি করে, প্রোগ্রামিং ভাষার মধ্যে ব্যতিক্রমী। এই ডিজাইন সিদ্ধান্তটি Go এর সরলতা এবং কর্মক্ষমতার উপর গুরুত্ব দেওয়ার প্রতিফলন।

তবে, এটা মনে রাখা উচিত যে Go তে জটিল সংখ্যার সাথে কাজ করা, যদিও শক্তিশালী, সব অ্যাপ্লিকেশানের জন্য সর্বোত্তম পদ্ধতি নাও হতে পারে, বিশেষ করে যেসব অ্যাপ্লিকেশানে সাংকেতিক গণিত বা উচ্চ-সঠিকতা অঙ্কনের প্রয়োজন। বৈজ্ঞানিক কম্পিউটিংয়ে বিশেষায়িত ভাষা এবং পরিবেশ, যেমন পাইথন NumPy এবং SciPy এর মতো লাইব্রেরির সাথে বা MATLAB এর মতো সফ্�্যার, নির্দিষ্ট অ্যাপ্লিকেশানগুলির জন্য আরও বেশি নমনীয়তা এবং বিস্তারিত বৈচিত্র্যের কার্যকারিতা অফার করতে পারে।

যাইহোক, সিস্টেম প্রোগ্রামিং এবং এমন প্রেক্ষাপটে যেখানে একটি বৃহত্তর, কর্মক্ষমতা-সংবেদনশীল অ্যাপ্লিকেশানে জটিল সংখ্যা গণনার সমন্বয় অত্যন্ত জরুরি, Go এর জটিল সংখ্যাগুলির জন্য নেটিভ সমর্থন একটি অনন্য দক্ষ বিকল্প প্রদান করে।
