---
changelog:
- 2024-03-17, gpt-4-0125-preview, translated from English
date: 2024-03-17 17:51:53.548618-06:00
description: "Go \u09A4\u09C7 \u098F\u0995\u099F\u09BF \u09B8\u09CD\u099F\u09CD\u09B0\
  \u09BF\u0982 \u098F\u09B0 \u09A6\u09C8\u09B0\u09CD\u0998\u09CD\u09AF \u0996\u09CB\
  \u099C\u09BE\u09B0 \u09AA\u09CD\u09B0\u0995\u09CD\u09B0\u09BF\u09AF\u09BC\u09BE\
  \ \u09AE\u09C2\u09B2\u09A4 \u098F\u099F\u09BF \u0995\u09A4\u0997\u09C1\u09B2\u09CB\
  \ \u099A\u09B0\u09BF\u09A4\u09CD\u09B0 (characters) \u09A6\u09CD\u09AC\u09BE\u09B0\
  \u09BE \u0997\u09A0\u09BF\u09A4 \u09A4\u09BE \u09A8\u09BF\u09B0\u09CD\u09A7\u09BE\
  \u09B0\u09A3 \u0995\u09B0\u09BE\u0964 \u09AA\u09CD\u09B0\u09CB\u0997\u09CD\u09B0\
  \u09BE\u09AE\u09BE\u09B0\u09B0\u09BE \u09B8\u09CD\u099F\u09CD\u09B0\u09BF\u0982\
  \ \u09B8\u09AE\u09C2\u09B9 \u0995\u09BE\u09B0\u09CD\u09AF\u0995\u09B0\u09AD\u09BE\
  \u09AC\u09C7\u2026"
lastmod: '2024-03-17T18:47:43.464168-06:00'
model: gpt-4-0125-preview
summary: "Go \u09A4\u09C7 \u098F\u0995\u099F\u09BF \u09B8\u09CD\u099F\u09CD\u09B0\u09BF\
  \u0982 \u098F\u09B0 \u09A6\u09C8\u09B0\u09CD\u0998\u09CD\u09AF \u0996\u09CB\u099C\
  \u09BE\u09B0 \u09AA\u09CD\u09B0\u0995\u09CD\u09B0\u09BF\u09AF\u09BC\u09BE \u09AE\
  \u09C2\u09B2\u09A4 \u098F\u099F\u09BF \u0995\u09A4\u0997\u09C1\u09B2\u09CB \u099A\
  \u09B0\u09BF\u09A4\u09CD\u09B0 (characters) \u09A6\u09CD\u09AC\u09BE\u09B0\u09BE\
  \ \u0997\u09A0\u09BF\u09A4 \u09A4\u09BE \u09A8\u09BF\u09B0\u09CD\u09A7\u09BE\u09B0\
  \u09A3 \u0995\u09B0\u09BE\u0964 \u09AA\u09CD\u09B0\u09CB\u0997\u09CD\u09B0\u09BE\
  \u09AE\u09BE\u09B0\u09B0\u09BE \u09B8\u09CD\u099F\u09CD\u09B0\u09BF\u0982 \u09B8\
  \u09AE\u09C2\u09B9 \u0995\u09BE\u09B0\u09CD\u09AF\u0995\u09B0\u09AD\u09BE\u09AC\u09C7\
  \u2026"
title: "\u09B8\u09CD\u099F\u09CD\u09B0\u09BF\u0982 \u098F\u09B0 \u09A6\u09C8\u09B0\
  \u09CD\u0998\u09CD\u09AF \u0996\u09C1\u0981\u099C\u09C7 \u09AA\u09BE\u0993\u09AF\
  \u09BC\u09BE"
---

{{< edit_this_page >}}

## কি এবং কেন?
Go তে একটি স্ট্রিং এর দৈর্ঘ্য খোজার প্রক্রিয়া মূলত এটি কতগুলো চরিত্র (characters) দ্বারা গঠিত তা নির্ধারণ করা। প্রোগ্রামাররা স্ট্রিং সমূহ কার্যকরভাবে ম্যানিপুলেট করতে এই অপারেশনটি নিয়মিত সঞ্চালন করে থাকেন, যা ভ্যালিডেশন, সাবস্ট্রিং এক্সট্রাকশন বা কেবলমাত্র ব্যবহারকারীর ইনপুটের মধ্যে সীমাবদ্ধতা প্রতিপালনে হোক না কেন।

## কীভাবে:
Go তে, স্ট্রিংগুলি অপরিবর্তনীয় বাইটস সিকোয়েন্স হিসেবে বিবেচিত হয়। একটি স্ট্রিং এর দৈর্ঘ্য খুঁজে পাওয়া যায় বিল্ট-ইন `len()` ফাংশন ব্যবহার করে যা বাইটের সংখ্যা ফেরত দেয়, অবশ্যই চরিত্রের সংখ্যা নয়। এখানে এর ব্যবহার কীভাবে করবেন তা দেখানো হলো:

```go
package main

import (
	"fmt"
	"unicode/utf8"
)

func main() {
	// len() ব্যবহার করে বাইটের দৈর্ঘ্য খুঁজে পাওয়া
	str := "Hello, 世界"
	byteLength := len(str)
	fmt.Println("Byte Length:", byteLength) // আউটপুট: Byte Length: 13

	// একটি স্ট্রিং এর মধ্যে চরিত্রের সঠিক সংখ্যা বা runes পাওয়া
	runeLength := utf8.RuneCountInString(str)
	fmt.Println("Rune Length:", runeLength) // আউটপুট: Rune Length: 9
}
```
`len()` ব্যবহার করে প্রথম পদ্ধতিটি সর্বদা প্রত্যাশিত ফলাফল দিতে পারে না যেহেতু এটি বাইট গণনা করে। অ-ASCII চরিত্রযুক্ত স্ট্রিংগুলির জন্য ("世界" এর মত), `unicode/utf8` প্যাকেজ থেকে `RuneCountInString` ব্যবহার করা উচিত ইউনিকোড কোড পয়েন্টগুলি সঠিকভাবে গণনা করার জন্য।

## গভীর ডুব
Go 1 এর আগে, বাইটের সিকোয়েন্স এবং চরিত্রের সিকোয়েন্স হিসাবে স্ট্রিংকে হ্যান্ডেল করার ক্ষেত্রে কোনো কঠোর বিভাজন ছিল না। Go 1 এর পর, স্ট্রিংগুলির জন্য UTF-8 কে স্ট্যান্ডার্ড এনকোডিং স্কিম হিসেবে গ্রহণ করার প্রয়োজন স্পষ্টভাবে বোঝা গেল। `len()` ফাংশন ASCII স্ট্রিংগুলির জন্য নিখুঁত কাজ করে, যেখানে চরিত্রগুলি একটি একক বাইটে প্রতিনিধিত্ব করা হয়। তবে, Go অ্যাপ্লিকেশনগুলি যত বৈশ্বিক হয়ে উঠল এবং বিভিন্ন ভাষা এবং চরিত্র সেট সমর্থনের প্রয়োজন বেড়ে গেল, `len()` এর সরল পদ্ধতির সীমাবদ্ধতা দৃশ্যমান হল।

`utf8.RuneCountInString()` এর পরিচয় এবং ব্যবহার এই সীমাবদ্ধতাগুলির উত্তর দেয় যা ইউনিকোড চরিত্র (Go শব্দজালে runes) গণনা করার একটি উপায় প্রদান করে। এই পদ্ধতিটি নিশ্চিত করে যে দৈর্ঘ্য গণনা UTF-8 এর এনকোডিং বিশেষত্ব থেকে স্বাধীন, যেখানে চরিত্রগুলি একাধিক বাইট জুড়ে থাকতে পারে।

Go এর সাথে সঙ্গতি রেখে এবং দক্ষতা উপলব্ধির লাইনে স্ট্রিংকে রুনসের স্লাইস হিসেবে ট্রিট করার একটি বিকল্প পদ্ধতি থাকতে পারে। তবে, এই পদ্ধতিটি একটি রূপান্তর ধাপের প্রয়োজন এবং ইউনিকোডের সমস্ত জটিলতা (যেমন, মিলে যাওয়া চরিত্র) সহজে সমাধান করে না।

সংক্ষেপে, `len()` বাইটের দৈর্ঘ্যের জন্য উপযুক্ত এবং ASCII টেক্সটের জন্য দক্ষ, অন্যদিকে `utf8.RuneCountInString()` একটি বৈশ্বিক সামঞ্জস্যযুক্ত অ্যাপ্লিকেশনের জন্য আরও নির্ভরযোগ্য পছন্দ। তবে, ডেভেলপারদের এই পছন্দগুলির ফলে পারফরম্যান্স এবং মেমোরি ব্যবহারের ট্রেড-অফ বুঝতে উৎসাহিত করা হয়।
