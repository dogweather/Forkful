---
title:                "लॉगिंग"
date:                  2024-01-26T01:09:42.676946-07:00
model:                 gpt-4-1106-preview
simple_title:         "लॉगिंग"

tag:                  "Good Coding Practices"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/hi/elixir/logging.md"
---

{{< edit_this_page >}}

## क्या और क्यों?
सॉफ्टवेयर विकास में लॉगिंग एक तकनीक है जिसमें कार्यक्रम चलते समय होने वाली घटनाओं को आमतौर पर एक फाइल या बाहरी प्रणाली में दर्ज किया जाता है। प्रोग्रामर इसे सॉफ़्टवेयर के व्यवहार की अंतर्दृष्टि प्राप्त करने, समस्याओं का निदान करने, और ऑपरेशनल इतिहास का रिकॉर्ड रखने के लिए करते हैं जो कि डिबगिंग और एप्लिकेशन की सेहत की निगरानी के लिए महत्वपूर्ण है।

## कैसे करें:
Elixir में, जानकारी लॉग करने का प्राथमिक तरीका बिल्ट-इन `Logger` मॉड्यूल के माध्यम से है। आप कैसे इसका उपयोग कर सकते हैं, यहाँ देखें:

```elixir
defmodule MyApplication do
  require Logger

  def do_something_important(param) do
    Logger.info("महत्वपूर्ण प्रक्रिया की शुरुआत param के साथ: #{param}")

    # काम किया जा रहा है ऐसा अनुकरण करें
    :timer.sleep(1000)

    Logger.debug("प्रक्रिया पूरी हुई।")
  rescue
    error -> Logger.error("एक त्रुटि हुई: #{inspect(error)}")
  end
end

# अपनी लॉग्स देखने के लिए, आप बस फंक्शन को कॉल करें:
MyApplication.do_something_important("MyParam")
```

यह सरल स्निपेट दिखाता है कि कैसे अलग-अलग स्तरों (`info`, `debug`, और `error`) पर लॉग किया जाता है। जब आप यह चलाएंगे, आप `debug` संदेश नहीं देख पाएंगे जब तक आप लॉगर स्तर को `:debug` पर कॉन्फ़िगर नहीं करते। डिफॉल्ट रूप से, Elixir का Logger `:info` से नीचे के लॉग सन्देशों को फिल्टर कर देता है।

`:info` स्तर पर नमूना आउटपुट इस तरह दिख सकता है:
```
14:32:40.123 [info]  महत्वपूर्ण प्रक्रिया की शुरुआत param के साथ: MyParam
14:32:41.126 [error] एक त्रुटि हुई: %RuntimeError{message: "runtime error"}
```

## गहन अध्ययन:
Elixir का `Logger` एक बिल्ट-इन टूल है जो इस भाषा के प्रारम्भिक दिनों से ही भाग रहा है। यह अन्य BEAM भाषाओं जैसे कि Erlang से प्रभावित लॉगिंग प्रणालियों से प्रभावित है। लॉगर विभिन्न स्तरों की लॉगिंग प्रदान करता है – `:debug`, `:info`, `:warn`, और `:error` – और यह प्लगेबल है, जो अलग-अलग बैकेंड्स को लॉग संदेशों को संभालने के लिए जोड़ने की अनुमति देता है।

अधिक जटिल परिस्थितियों के लिए बिल्ट-इन Logger का एक विकल्प `Logstash` या `Sentry` जैसे लॉगिंग लाइब्रेरीज का उपयोग होता है जो Elixir के लिए अतिरिक्त फीचर्स जैसे कि त्रुटि ट्रैकिंग और संयोजन को अधिक दृश्यात्मक प्रारूप में प्रदान कर सकते हैं। स्थानीय विकास के लिए, Elixir डेवलपर्स अक्सर इसकी सादगी और BEAM VM के साथ इंटीग्रेशन के लिए बिल्ट-इन Logger कार्यक्षमता पर निर्भर करते हैं।

अंतर्निहित रूप में, Logger मॉड्यूल असिंक्रोनस और सिंक्रोनस लॉगिंग प्रदान करता है। डिफॉल्ट रूप से असिंक्रोनस लॉगिंग, जो असिंक्रोनस है, आपके एप्लिकेशन की निष्पादन को लॉगिंग संदेशों के दौरान अवरुद्ध नहीं करती। यह सुनिश्चित करती है कि लॉगिंग प्रदर्शन पर नकारात्मक प्रभाव न डाले। हालांकि, जहाँ आपको गारंटी करने की जरूरत हो कि सन्देश भेजे जाने के क्रम में लॉग किए गए हैं, वहाँ सिंक्रोनस लॉगिंग को सक्षम किया जा सकता है।

Logger कॉन्फ़िगरेशन को एक Elixir एप्लिकेशन की `config/config.exs` फ़ाइल में समायोजित किया जा सकता है, जहाँ आप लॉगिंग स्तर, फ़ॉर्मेट, मेटाडेटा और बहुत कुछ सेट कर सकते हैं। हमेशा अलग-अलग वातावरणों के लिए अपने लॉगिंग स्तरों और आउटपुट्स को समायोजित करना याद रखें; आप नहीं चाहेंगे कि विस्तृत डिबग लॉग्स आपके प्रोडक्शन सिस्टम्स को बाढ़ दें।

## देखें भी:
- आधिकारिक Elixir Logger दस्तावेज़ीकरण: https://hexdocs.pm/logger/Logger.html
- Elixir लॉगिं�
