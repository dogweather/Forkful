---
title:                "एरर्स को हैंडल करना"
date:                  2024-01-26T00:58:00.746382-07:00
model:                 gpt-4-1106-preview
simple_title:         "एरर्स को हैंडल करना"

tag:                  "Good Coding Practices"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/hi/rust/handling-errors.md"
---

{{< edit_this_page >}}

## क्या और क्यों?

एरर हैंडलिंग उस समस्या से निपटने के बारे में है जब चीजें गलत दिशा में जाती हैं। प्रोग्रामर्स इसे अप्रत्याशित को संभालने के लिए करते हैं, यह सुनिश्चित करते हुए कि उनके रस्ट प्रोग्राम मजबूत होते हैं और एक हिचकी का सामना करते समय केवल क्रैश नहीं होते हैं।

## कैसे करें:

रस्ट दो प्रमुख तरीकों से एरर्स को हैंडल करता है: पुनर्प्राप्य और अपुनर्प्राप्य एरर्स। चलिए दोनों को देखते हैं।

पुनर्प्राप्य एरर्स के लिए `Result<T, E>` का उपयोग होता है:

```Rust
use std::fs::File;

fn open_file(filename: &str) -> Result<File, std::io::Error> {
    let f = File::open(filename);
    
    match f {
        Ok(file) => Ok(file),
        Err(e) => Err(e),
    }
}

fn main() {
    match open_file("hello.txt") {
        Ok(_file) => println!("File opened successfully."),
        Err(_e) => println!("Failed to open file."),
    }
}
```

आउटपुट "File opened successfully." या "Failed to open file." में से कोई एक हो सकता है, यह आपके `hello.txt` पर निर्भर करता है।

अपुनर्प्राप्य एरर्स के लिए हम `panic!` का उपयोग करते हैं:

```Rust
fn main() {
    // यह प्रोग्राम को पैनिक करने का कारण बनेगा क्योंकि फाइल शायद मौजूद नहीं है।
    let _f = File::open("nowhere.txt").unwrap();
}
```

इसे चलाएं, और आपको एक पैनिक संदेश दिखाई देगा। आपका प्रोग्राम तत्काल रुक जाता है।

## गहराई से जानकारी

पारंपरिक रूप से, प्रोग्रामिंग में एरर हैंडलिंग एक जटिल मुद्दा रहा है। रस्ट इसे पुनर्प्राप्य और अपुनर्प्राप्य एरर्स के बीच स्पष्ट विभेदन के साथ सही करता है।

`Result` एनम पुनर्प्राप्य एरर्स के लिए है। यह स्पष्ट है – आप `Ok` या `Err` वेरिएंट को हैंडल करते हैं। `unwrap()` और `expect()` जैसे मेथड्स भी होते हैं, पर वे `panic!` की ओर जल्दी और गंदे शॉर्टकट हो सकते हैं।

`panic!` रस्ट का तरीका है बताने का कि कुछ वास्तव में बुरा हुआ है, और यह संभाल नहीं सकते। यह एक अपुनर्प्राप्य एरर की तरह होता है जो तुरंत निष्पादन को रोक देता है। जब आपको ऐसी बग्स का सामना करना पड़ता है जिन्हें आप हैंडल करने की उम्मीद नहीं करते, जैसे कि एरे की बाउंड्स से बाहर इंडेक्सिंग, तो रस्ट में अक्सर पैनिक महसूस किया जाता है।

जब आप एरर्स का सामना करने की उम्मीद करते हैं तो `Result` को वापस देने वाली एरर हैंडलिंग पसंद की जाती है। यह रस्ट की विशिष्ट शैली है, जिसका मतलब है यह वह तरीका है जो रस्ट डेवलपर्स ने चीजों को करने के लिए सहमत हुए हैं। `Option<T>` भी है, ऐसी परिस्थितियों के लिए जब एक एरर केवल `None` होते हुए के बजाय `Some(T)` नहीं होता है। यह सब उम्मीद करने वाले के बारे में है बिना डर के।

विकल्प? ज़रूर, आप अधिक तरीकों या आरामदायक उपयोग के लिए अन्य एरर हैंडलिंग क्रेट्स का उपयोग कर सकते हैं। जैसे कि सरल एरर हैंडलिंग के लिए `anyhow` या लाइब्रेरी कोड में एरर्स के लिए `thiserror`।

## और भी जानने के लिए

गहराई से जानने में रूचि है? यहाँ जाने के लिए:

- [रस्ट बुक ऑन एरर हैंडलिंग](https://doc.rust-lang.org/book/ch09-00-error-handling.html) - रस्ट की एरर हैंडलिंग दर्शन को समझने के लिए एक शानदार जगह।
- [रस्ट बाय एक्जाम्पल: एरर हैंडलिंग](https://doc.rust-lang.org/rust-by-example/error.html) - आपके हाथ गंदे करने के लिए इंटरएक्टिव उदाहरण।

याद रखिए, अच्छी एरर हैंडलिंग केवल कोडिंग नहीं है; यह आपके कोड के उपयोगकर्ताओं के लिए देखभाल करना है। हैप्पी कोडिंग!
