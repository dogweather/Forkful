---
changelog:
- 2024-01-30, gpt-4-0125-preview, translated from English
date: 2024-01-30 19:11:08.996748-07:00
description: "\u0938\u0940++ \u092E\u0947\u0902, \u0938\u0939\u093E\u092F\u0915 \u092E\
  \u093E\u0930\u094D\u0917\u0926\u0930\u094D\u0936\u093F\u0915\u093E\u090F\u0902,\
  \ \u091C\u093F\u0938\u0947 `std::map` \u092F\u093E `std::unordered_map` \u0915\u0947\
  \ \u0930\u0942\u092A \u092E\u0947\u0902 \u091C\u093E\u0928\u093E \u091C\u093E\u0924\
  \u093E \u0939\u0948, \u0938\u0930\u0923\u0940 \u0938\u0942\u091A\u0915\u093E\u0902\
  \u0915\u094B\u0902 \u0914\u0930 \u0935\u093E\u0938\u094D\u0924\u0935\u093F\u0915\
  \ \u0935\u093F\u0936\u094D\u0935 \u0921\u0947\u091F\u093E \u0915\u0947 \u092C\u0940\
  \u091A \u0915\u0940 \u0916\u093E\u0908 \u0915\u094B\u2026"
lastmod: '2024-03-13T22:44:52.832289-06:00'
model: gpt-4-0125-preview
summary: "\u0938\u0940++ \u092E\u0947\u0902, \u0938\u0939\u093E\u092F\u0915 \u092E\
  \u093E\u0930\u094D\u0917\u0926\u0930\u094D\u0936\u093F\u0915\u093E\u090F\u0902,\
  \ \u091C\u093F\u0938\u0947 `std::map` \u092F\u093E `std::unordered_map` \u0915\u0947\
  \ \u0930\u0942\u092A \u092E\u0947\u0902 \u091C\u093E\u0928\u093E \u091C\u093E\u0924\
  \u093E \u0939\u0948, \u0938\u0930\u0923\u0940 \u0938\u0942\u091A\u0915\u093E\u0902\
  \u0915\u094B\u0902 \u0914\u0930 \u0935\u093E\u0938\u094D\u0924\u0935\u093F\u0915\
  \ \u0935\u093F\u0936\u094D\u0935 \u0921\u0947\u091F\u093E \u0915\u0947 \u092C\u0940\
  \u091A \u0915\u0940 \u0916\u093E\u0908 \u0915\u094B \u092A\u093E\u091F\u0924\u0947\
  \ \u0939\u0948\u0902, \u091C\u093F\u0938\u0938\u0947 \u0906\u092A \u0938\u093E\u0930\
  \u094D\u0925\u0915 \u0915\u0941\u0902\u091C\u093F\u092F\u094B\u0902 \u0915\u093E\
  \ \u0909\u092A\u092F\u094B\u0917 \u0915\u0930 \u0938\u0915\u0924\u0947 \u0939\u0948\
  \u0902\u0964 \u091C\u092C \u0906\u092A\u0915\u094B \u0938\u0942\u091A\u0915\u093E\
  \u0902\u0915 \u0938\u094D\u0925\u093F\u0924\u093F\u092F\u094B\u0902 \u0915\u0947\
  \ \u092C\u091C\u093E\u090F \u0915\u0941\u0902\u091C\u093F\u092F\u094B\u0902 \u0915\
  \u093E \u0909\u092A\u092F\u094B\u0917 \u0915\u0930\u0924\u0947 \u0939\u0941\u090F\
  \ \u0924\u0947\u091C\u0940 \u0938\u0947 \u0932\u0941\u0915\u0905\u092A\u094D\u0938\
  , \u0921\u093E\u0932\u0928\u0947, \u0914\u0930 \u0939\u091F\u093E\u0928\u0947 \u0915\
  \u0940 \u0906\u0935\u0936\u094D\u092F\u0915\u0924\u093E \u0939\u094B\u0924\u0940\
  \ \u0939\u0948 \u0924\u094B \u0935\u0947 \u091C\u093E\u0928\u0947-\u092E\u093E\u0928\
  \u0947 \u0935\u093F\u0915\u0932\u094D\u092A \u0939\u0948\u0902\u0964."
title: "\u0938\u0939\u092F\u094B\u0917\u0940 \u0905\u0930\u0947\u091C\u093C \u0915\
  \u093E \u0909\u092A\u092F\u094B\u0917 \u0915\u0930\u0928\u093E"
weight: 15
---

## कैसे:
C++ में, सहायक मार्गदर्शिकाएं `<map>` और `<unordered_map>` हेडर्स के साथ जान में आती हैं। चलिए उदाहरणों के माध्यम से देखते हैं दोनों को क्रिया में।

### `std::map` का उपयोग करते हुए
`std::map` तत्वों को कुंजी के आधार पर क्रमबद्ध रखता है। आरंभ करने का यह तरीका है:

```C++
#include <iostream>
#include <map>
#include <string>

int main() {
    std::map<std::string, int> ageMap;
    
    // मानों को डालना
    ageMap["Alice"] = 30;
    ageMap["Bob"] = 25;
    
    // मानों तक पहुँचना
    std::cout << "Bob की उम्र: " << ageMap["Bob"] << std::endl;
    
    // मानचित्र के ऊपर घूमना
    for(const auto &pair : ageMap) {
        std::cout << pair.first << " " << pair.second << " वर्ष का है।" << std::endl;
    }
    
    return 0;
}
```

### `std::unordered_map` का उपयोग करते हुए
जब क्रम मायने नही रखता, लेकिन प्रदर्शन करता है, `std::unordered_map` आपका दोस्त होता है, डालने, लुकअप्स, और हटाने के लिए तेज़ औसत जटिलता प्रदान करता है।

```C++
#include <iostream>
#include <unordered_map>
#include <string>

int main() {
    std::unordered_map<std::string, double> productPrice;
    
    // मानों को डालना
    productPrice["milk"] = 2.99;
    productPrice["bread"] = 1.99;
    
    // मानों तक पहुँचना
    std::cout << "Milk का दाम: $" << productPrice["milk"] << std::endl;
    
    // एक unordered_map के ऊपर घूमना
    for(const auto &pair : productPrice) {
        std::cout << pair.first << " का खर्च $" << pair.second << " है।" << std::endl;
    }
    
    return 0;
}
```

## गहराई से विचार
C++ में सहायक मार्गदर्शिकाएं, विशेषकर `std::map` और `std::unordered_map`, केवल तत्वों के संग्रहण के बारे में नहीं हैं। �वें खोज, डालने, और हटाने जैसी क्रियाओं को कुशल समय जटिलताओं में संभालने की सुविधा प्रदान करके अधिक जटिल डेटा प्रबंधन की आधारशिला रखते हैं (`std::map` के लिए लॉगारिदमिक और `std::unordered_map` के लिए औसत मामले में स्थिर समय)। यह कुशलता `std::map` के लिए एक संतुलित वृक्ष और `std::unordered_map` के लिए एक हैश टेबल, इनके अधीनस्थ डेटा संरचनाओं से आती है।

ऐतिहासिक रूप से, इन्हें मानक पुस्तकालय का हिस्सा बनने से पहले, प्रोग्रामर को उनके स्वयं के संस्करणों को लागू करना पड़ता था या तृतीय-पक्ष पुस्तकालयों का उपयोग करना पड़ता था, जिससे असंगतियां और संभावित अकुशलताएं पैदा होती थीं। मानचित्रों को C++ के मानक पुस्तकालय में शामिल करने से उनका उपयोग न केवल मानकीकृत हुआ बल्कि विभिन्न कम्पाइलरों और प्लेटफ़ॉर्मों में प्रदर्शन के लिए उन्हें अनुकूलित भी किया गया।

जबकि दोनों ही शक्तिशाली हैं, `std::map` और `std::unordered_map` के बीच चयन आपके उपयोग के मामले की विशिष्टताओं पर निर्भर करता है। क्रमबद्ध डेटा की आवश्यकता है और हल्की प्रदर्शन की ट्रेड-ऑफ़ से समझौता कर सकते हैं? `std::map` के साथ जाएं। अगर आप गति के पीछे हैं और क्रम की परवाह नहीं करते, `std::unordered_map` शायद आपके लिए बेहतर विकल्प है। 

हालांकि, महत्वपूर्ण है कि जब जटिल डेटा संरचनाओं के साथ काम कर रहे हों, तो हमेशा ट्रेड-ऑफ़्स होते हैं। कुछ विशेष मामलों में, अन्य डेटा संरचनाएं या यहाँ तक कि तृतीय-पक्ष पुस्तकालय आपकी विशेष आवश्यकताओं के लिए बेहतर प्रदर्शन या कार्यक्षमता प्रदान कर सकते हैं। अपनी परियोजना की आवश्यकताओं के आधार पर हमेशा अपने विकल्पों का वजन करें।
