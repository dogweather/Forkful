---
title:                "सहयोगी अरेज़ का उपयोग करना"
aliases:
- /hi/cpp/using-associative-arrays/
date:                  2024-01-30T19:11:08.996748-07:00
model:                 gpt-4-0125-preview
simple_title:         "सहयोगी अरेज़ का उपयोग करना"

tag:                  "Data Structures"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/hi/cpp/using-associative-arrays.md"
changelog:
  - 2024-01-30, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## क्या और क्यों?

सी++ में, सहायक मार्गदर्शिकाएं, जिसे `std::map` या `std::unordered_map` के रूप में जाना जाता है, सरणी सूचकांकों और वास्तविक विश्व डेटा के बीच की खाई को पाटते हैं, जिससे आप सार्थक कुंजियों का उपयोग कर सकते हैं। जब आपको सूचकांक स्थितियों के बजाए कुंजियों का उपयोग करते हुए तेजी से लुकअप्स, डालने, और हटाने की आवश्यकता होती है तो वे जाने-माने विकल्प हैं।

## कैसे:

C++ में, सहायक मार्गदर्शिकाएं `<map>` और `<unordered_map>` हेडर्स के साथ जान में आती हैं। चलिए उदाहरणों के माध्यम से देखते हैं दोनों को क्रिया में।

### `std::map` का उपयोग करते हुए

`std::map` तत्वों को कुंजी के आधार पर क्रमबद्ध रखता है। आरंभ करने का यह तरीका है:

```C++
#include <iostream>
#include <map>
#include <string>

int main() {
    std::map<std::string, int> ageMap;
    
    // मानों को डालना
    ageMap["Alice"] = 30;
    ageMap["Bob"] = 25;
    
    // मानों तक पहुँचना
    std::cout << "Bob की उम्र: " << ageMap["Bob"] << std::endl;
    
    // मानचित्र के ऊपर घूमना
    for(const auto &pair : ageMap) {
        std::cout << pair.first << " " << pair.second << " वर्ष का है।" << std::endl;
    }
    
    return 0;
}
```

### `std::unordered_map` का उपयोग करते हुए

जब क्रम मायने नही रखता, लेकिन प्रदर्शन करता है, `std::unordered_map` आपका दोस्त होता है, डालने, लुकअप्स, और हटाने के लिए तेज़ औसत जटिलता प्रदान करता है।

```C++
#include <iostream>
#include <unordered_map>
#include <string>

int main() {
    std::unordered_map<std::string, double> productPrice;
    
    // मानों को डालना
    productPrice["milk"] = 2.99;
    productPrice["bread"] = 1.99;
    
    // मानों तक पहुँचना
    std::cout << "Milk का दाम: $" << productPrice["milk"] << std::endl;
    
    // एक unordered_map के ऊपर घूमना
    for(const auto &pair : productPrice) {
        std::cout << pair.first << " का खर्च $" << pair.second << " है।" << std::endl;
    }
    
    return 0;
}
```

## गहराई से विचार

C++ में सहायक मार्गदर्शिकाएं, विशेषकर `std::map` और `std::unordered_map`, केवल तत्वों के संग्रहण के बारे में नहीं हैं। �वें खोज, डालने, और हटाने जैसी क्रियाओं को कुशल समय जटिलताओं में संभालने की सुविधा प्रदान करके अधिक जटिल डेटा प्रबंधन की आधारशिला रखते हैं (`std::map` के लिए लॉगारिदमिक और `std::unordered_map` के लिए औसत मामले में स्थिर समय)। यह कुशलता `std::map` के लिए एक संतुलित वृक्ष और `std::unordered_map` के लिए एक हैश टेबल, इनके अधीनस्थ डेटा संरचनाओं से आती है।

ऐतिहासिक रूप से, इन्हें मानक पुस्तकालय का हिस्सा बनने से पहले, प्रोग्रामर को उनके स्वयं के संस्करणों को लागू करना पड़ता था या तृतीय-पक्ष पुस्तकालयों का उपयोग करना पड़ता था, जिससे असंगतियां और संभावित अकुशलताएं पैदा होती थीं। मानचित्रों को C++ के मानक पुस्तकालय में शामिल करने से उनका उपयोग न केवल मानकीकृत हुआ बल्कि विभिन्न कम्पाइलरों और प्लेटफ़ॉर्मों में प्रदर्शन के लिए उन्हें अनुकूलित भी किया गया।

जबकि दोनों ही शक्तिशाली हैं, `std::map` और `std::unordered_map` के बीच चयन आपके उपयोग के मामले की विशिष्टताओं पर निर्भर करता है। क्रमबद्ध डेटा की आवश्यकता है और हल्की प्रदर्शन की ट्रेड-ऑफ़ से समझौता कर सकते हैं? `std::map` के साथ जाएं। अगर आप गति के पीछे हैं और क्रम की परवाह नहीं करते, `std::unordered_map` शायद आपके लिए बेहतर विकल्प है। 

हालांकि, महत्वपूर्ण है कि जब जटिल डेटा संरचनाओं के साथ काम कर रहे हों, तो हमेशा ट्रेड-ऑफ़्स होते हैं। कुछ विशेष मामलों में, अन्य डेटा संरचनाएं या यहाँ तक कि तृतीय-पक्ष पुस्तकालय आपकी विशेष आवश्यकताओं के लिए बेहतर प्रदर्शन या कार्यक्षमता प्रदान कर सकते हैं। अपनी परियोजना की आवश्यकताओं के आधार पर हमेशा अपने विकल्पों का वजन करें।
