---
aliases:
- /hi/java/refactoring/
date: 2024-01-26 01:40:42.404346-07:00
description: "\u0930\u093F\u092B\u0948\u0915\u094D\u091F\u0930\u093F\u0902\u0917 \u0935\
  \u093F\u0926\u094D\u092F\u092E\u093E\u0928 \u0915\u0902\u092A\u094D\u092F\u0942\u091F\
  \u0930 \u0915\u094B\u0921 \u0915\u094B \u092A\u0941\u0928\u0930\u094D\u0917\u0920\
  \u0928 \u0915\u0930\u0928\u0947\u2014\u092B\u0948\u0915\u094D\u091F\u0930\u093F\u0902\
  \u0917 \u0915\u094B \u092C\u0926\u0932\u0928\u0947\u2014\u0915\u0940 \u092A\u094D\
  \u0930\u0915\u094D\u0930\u093F\u092F\u093E \u0939\u0948, \u092A\u0930\u0902\u0924\
  \u0941 \u0907\u0938\u0915\u0947 \u092C\u093E\u0939\u0930\u0940 \u0935\u094D\u092F\
  \u0935\u0939\u093E\u0930 \u0915\u094B \u092C\u0926\u0932\u0947 \u092C\u093F\u0928\
  \u093E\u0964 \u092A\u094D\u0930\u094B\u0917\u094D\u0930\u093E\u092E\u0930 \u0907\
  \u0938\u0947 \u0938\u0949\u092B\u094D\u091F\u0935\u0947\u092F\u0930 \u0915\u0947\
  \u2026"
lastmod: 2024-02-18 23:09:03.130397
model: gpt-4-0125-preview
summary: "\u0930\u093F\u092B\u0948\u0915\u094D\u091F\u0930\u093F\u0902\u0917 \u0935\
  \u093F\u0926\u094D\u092F\u092E\u093E\u0928 \u0915\u0902\u092A\u094D\u092F\u0942\u091F\
  \u0930 \u0915\u094B\u0921 \u0915\u094B \u092A\u0941\u0928\u0930\u094D\u0917\u0920\
  \u0928 \u0915\u0930\u0928\u0947\u2014\u092B\u0948\u0915\u094D\u091F\u0930\u093F\u0902\
  \u0917 \u0915\u094B \u092C\u0926\u0932\u0928\u0947\u2014\u0915\u0940 \u092A\u094D\
  \u0930\u0915\u094D\u0930\u093F\u092F\u093E \u0939\u0948, \u092A\u0930\u0902\u0924\
  \u0941 \u0907\u0938\u0915\u0947 \u092C\u093E\u0939\u0930\u0940 \u0935\u094D\u092F\
  \u0935\u0939\u093E\u0930 \u0915\u094B \u092C\u0926\u0932\u0947 \u092C\u093F\u0928\
  \u093E\u0964 \u092A\u094D\u0930\u094B\u0917\u094D\u0930\u093E\u092E\u0930 \u0907\
  \u0938\u0947 \u0938\u0949\u092B\u094D\u091F\u0935\u0947\u092F\u0930 \u0915\u0947\
  \u2026"
title: "\u0915\u094B\u0921 \u0915\u0940 \u0938\u092B\u093E\u0908"
---

{{< edit_this_page >}}

## क्या और क्यों?
रिफैक्टरिंग विद्यमान कंप्यूटर कोड को पुनर्गठन करने—फैक्टरिंग को बदलने—की प्रक्रिया है, परंतु इसके बाहरी व्यवहार को बदले बिना। प्रोग्रामर इसे सॉफ्टवेयर के अशाब्दिक गुणधर्मों को सुधारने के लिए करते हैं, पठनीयता बढ़ाने, जटिलता को कम करने, और कोड को भविष्य की साहसिक कार्यों के लिए अधिक रखरखाव योग्य बनाने के लिए।

## कैसे करें:
आइए एक साधारण Java क्लास पर विचार करते हैं जिसकी खराब संगठनात्मकता और स्पष्टता की कमी के कारण रिफैक्टरिंग की आवश्यकता है।

```java
public class Calculator {
    public int calc(int op1, int op2, String operation) {
        if (operation.equals("add")) {
            return op1 + op2;
        } else if (operation.equals("subtract")) {
            return op1 - op2;
        } // अन्य ऑपरेशन...
    }
}
```

रिफैक्टरिंग के बाद, हमारे पास है:

```java
public class Calculator {
    public int add(int operand1, int operand2) {
        return operand1 + operand2;
    }

    public int subtract(int operand1, int operand2) {
        return operand1 - operand2;
    }

    // अन्य ऑपरेशन...
}
```

रिफैक्टरिंग करके, हमने पठनीयता के लिए विधि नामों और पैरामीटरों में सुधार किया है और एक ही विधि के भीतर एक शर्तीय शाखा की आवश्यकता को हटा दिया है। प्रत्येक ऑपरेशन अब स्पष्ट रूप से अपने उद्देश्य को बताता है।

## गहराई में:
रिफैक्टरिंग की जड़ें Smalltalk समुदाय में हैं, जिसमें कोड पठनीयता और ऑब्जेक्ट-ओरिएंटेड डिजाइन पर जोर दिया गया है, लेकिन इसे वास्तव में ९० के दशक के अंत और ०० के दशक के शुरू में Java विश्व में उछाल मिला, विशेष रूप से Martin Fowler की मौलिक पुस्तक, "Refactoring: Improving the Design of Existing Code" के प्रकाशन के बाद।

रिफैक्टरिंग के विकल्प जैसे कि कोड को खरोंच से लिखना हैं। हालांकि, रिफैक्टरिंग अक्सर पसंद की जाती है क्योंकि इसमें ऐसे क्रमिक परिवर्तन शामिल होते हैं जो एप्लिकेशन की कार्यक्षमता को बाधित नहीं करते।

Java (या किसी भी प्रोग्रामिंग भाषा) में रिफैक्टरिंग करते समय कार्यान्वयन विवरण कोड स्मेल्स—कोड में गहरे इश्यू के संकेतकों—को समझने के आसपास घूमते हैं। कुछ स्मेल्स में लंबी विधियाँ, बड़ी क्लासेस, डुप्लिकेट कोड, और प्रिमिटिव्स का अत्यधिक उपयोग शामिल हैं। Extract Method, Move Method, या Replace Temp with Query जैसे रिफैक्टरिंग पैटर्न लागू करके, डेवलपर्स इन स्मेल्स को व्यवस्थित रूप से संबोधित कर सकते हैं, साथ ही साथ यह सुनिश्चित करते हैं कि कोड हर समय कार्यात्मक रहे।

ऑटोमेटेड टूल्स, जैसे कि IntelliJ IDEA का रिफैक्टरिंग समर्थन, या Eclipse के लिए प्लगइन्स, चर नामों, विधियों, और क्लासों का नाम बदलना, विधियों या चरों को निकालना, और विभिन्न पैकेजों या नेमस्पेसों में विधियों या क्लासों को स्थानांतरित करने जैसी रिफैक्टरिंग को स्वचालित करने से प्रक्रिया में सहायता कर सकते हैं।

## देखें भी:
- Martin Fowler का "Refactoring: Improving the Design of Existing Code": https://martinfowler.com/books/refactoring.html
- Refactoring.Guru पर रिफैक्टरिंग तकनीकें: https://refactoring.guru/refactoring/techniques
- Eclipse में ऑटोमेटेड रिफैक्टरिंग: https://www.eclipse.org/eclipse/news/4.18/jdt.php
- IntelliJ IDEA की रिफैक्टरिंग सुविधाएं: https://www.jetbrains.com/idea/features/refactoring.html

प्रत्येक संसाधन या तो रिफैक्टरिंग के सिद्धांतों को समझने के लिए एक आधार प्रदान करता है या इन सिद्धांतों को व्यवहार में लाने के लिए लाभ उठाने योग्य उपकरण प्रदान करता है।
