---
title:                "कोड की सफाई"
date:                  2024-01-26T01:39:23.086692-07:00
model:                 gpt-4-0125-preview
simple_title:         "कोड की सफाई"
programming_language: "Haskell"
category:             "Haskell"
tag:                  "Good Coding Practices"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/hi/haskell/refactoring.md"
---

{{< edit_this_page >}}

## क्या और क्यों?
रिफेक्टरिंग कोड को बिना इसके बाहरी व्यवहार को बदले हुए ट्वीक करने की प्रक्रिया है। यह सब आपके कोड को साफ-सुथरा करने और व्यवस्थित करने के बारे में है ताकि कोड को पढ़ना, मेंटेन करना, और विस्तारित करना आसान हो जाए। यह बग्स को दूर करने और प्रदर्शन में सुधार करने में भी मदद कर सकता है।

## कैसे करें:
मान लीजिए आपके पास Haskell कोड का एक भाग है जो आपके पसंदीदा गीत से ज्यादा बार खुद को दोहरा रहा है। यहां एक झलक है कि आप फ़ंक्शंस का उपयोग करके इसे कैसे रिफैक्टर कर सकते हैं।

रिफेक्टरिंग से पहले:

```haskell
printInvoice :: String -> Float -> String -> IO ()
printInvoice customer total item = do
  putStrLn $ "Customer: " ++ customer
  putStrLn $ "Total: " ++ show total
  putStrLn $ "Item: " ++ item
```

थोड़ी बहुत रिफैक्टरिंग के बाद:

```haskell
printDetail :: String -> String -> IO ()
printDetail label value = putStrLn $ label ++ ": " ++ value

printInvoice :: String -> Float -> String -> IO ()
printInvoice customer total item = do
  printDetail "Customer" customer
  printDetail "Total" (show total)
  printDetail "Item" item

-- नमूना आउटपुट:
-- Customer: Alice
-- Total: $42.00
-- Item: Haskell Programming Guide
```

जैसा कि आप देख सकते हैं, एक अलग `printDetail` फ़ंक्शन में आम पैटर्न को निकालकर, हम पुनरावृत्ति से बचते हैं और `printInvoice` को अधिक स्पष्ट और प्रबंधित करने में आसान बनाते हैं।

## गहराई से विश्लेषण
जब हास्केल ८० के दशक के अंत में दृश्य पर आया, तो यह स्पष्ट था कि कार्यात्मक पैराडाइम कोडिंग प्रथाओं में कुछ नई सांस ला सकता है। आगे बढ़ते हुए, और हास्केल में रिफेक्टरिंग विशेष रूप से सुंदर है क्योंकि फ़ंक्शंस पहली-श्रेणी के नागरिक होते हैं और इसकी मजबूत स्थिर प्रकार प्रणाली होती है। आप अपने ऐप को तोड़ने का डर किए बिना रिफैक्टर कर सकते हैं क्योंकि कंपाइलर आपकी पीठ थपथपाता है।

स्वचालित उ� करने वाले उपकरणों के लिए वैकल्पिक विकल्प हो सकते हैं, हालांकि हास्केल की कार्यात्मक प्रकृति और प्रकार सुरक्षा कुछ समय में इसे अन्य भाषाओं की तुलना में कम प्रचलित बना सकती है। कार्यान्वयन-वार, यह महत्वपूर्ण है कि हास्केल की विशेषताओं जैसे कि उच्च-क्रम फ़ंक्शंस, पवित्रता, और अचलता का लाभ उठाया जाए ताकि रिफैक्टरिंग को चिकना बनाया जा सके।

"फ़ंक्शन निकालें", जैसे कि अभी प्रदर्शित किया गया है, आम हैं, लेकिन आप प्रकार प्रणाली के लिए धन्यवाद के साथ "फ़ंक्शन में इनलाइन", "वैरिएबल का नाम बदलें", और "फ़ंक्शन सिग्नेचर बदलें" भी कर सकते हैं। हास्केल का शक्तिशाली प्रकार अनुमान कभी-कभी अन्य भाषाओं में पारित होने वाली त्रुटियों को पकड़ सकता है।

## अधिक जानकारी के लिए
हास्केल में रिफेक्टरिंग के गहरे विश्लेषण के लिए, "रिफेक्टरिंग: मौज�ा कोड के डिज़ाइन को सुधारना" नामक पुस्तक के साथ पढ़ें, जहां अव�ारें सार्वभौमिक रूप से लागू होते हैं। अपने हास्केल कोड में सुधार के लिए स्वचालित संकेतों के लिए hlint उपकरण की जाँच करें। साथ ही, समुदाय की अंतर्दृष्टि और आगे पढ़ने के लिए हास्केल विकी (https://wiki.haskell.org/Refactoring) पर जाएँ।
