---
title:                "लॉगिंग"
date:                  2024-01-26T01:09:48.279703-07:00
model:                 gpt-4-1106-preview
simple_title:         "लॉगिंग"
programming_language: "Clojure"
category:             "Clojure"
tag:                  "Good Coding Practices"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/hi/clojure/logging.md"
---

{{< edit_this_page >}}

## क्या और क्यों?
लॉगिंग मूल रूप से सॉफ्टवेयर के जहाज की लॉग के समान है; यह एक ऐसा तरीका है जो एप्लिकेशन चलते समय होने वाली घटनाओं को रिकॉर्ड करता है। प्रोग्रामर्स इसे डीबगिंग, ऑडिट ट्रेल्स, या उत्पादन में सिस्टम के व्यवहार की अंतर्दृष्टि प्राप्त करने के लिए करते हैं।

## कैसे करें:
क्लोजर जावा की लॉगिंग सुविधाओं पर निर्भर करता है, लेकिन आप उन्हें अधिक मूलभूत क्लोजर तरीके से टैप कर सकते हैं। आइए देखें कि कैसे आप `clojure.tools.logging` का उपयोग कर सकते हैं, जो कई लॉगिंग फ्रेमवर्क्स पर एक सरल अमूर्तता प्रदान करता है:

सबसे पहले, अपने `project.clj` में `clojure.tools.logging` और `log4j` जैसे लॉगिंग क्रियान्वयन के लिए एक निर्भरता जोड़ें:

```clojure
:dependencies [[org.clojure/clojure "1.10.3"]
               [org.clojure/tools.logging "1.1.0"]
               [log4j/log4j "1.2.17"]]
```

अब, कुछ संदेश लॉग करते हैं:

```clojure
(require '[clojure.tools.logging :as log])

(defn compute-answer-to-everything []
  (log/debug "Starting intense computation...")
  (Thread/sleep 3000) ; एक लंबी गणना का अनुकरण
  (log/info "Computation done. The answer is 42.")
  42)

(compute-answer-to-everything)
```
आउटपुट `DEBUG` संदेश को डिफ़ॉल्ट रूप से नहीं दिखाएगा, क्योंकि लॉग स्तर आमतौर पर `INFO` पर सेट होते हैं:

```
INFO  [your-namespace] - Computation done. The answer is 42.
```

आप `log4j.properties` फ़ाइल में लॉग स्तरों और एपेंडर्स को कॉन्फ़िगर करके अधिक विस्तृत आउटपुट प्राप्त कर सकते हैं, यदि आवश्यक हो।

## गहराई से डूबकी
क्लोजर का `clojure.tools.logging` काफी समय से है और यह क्लोजर कोड और जावा लॉगिंग दुनिया के बीच एक पुल के रूप में सेवा करता है। ऐतिहासिक रूप से, जावा में जावा के बिल्ट-इन लॉगिंग API, `log4j`, `slf4j`, और `logback` जैसी कई इंटरेशन्स और लाइब्रेरियों के जरिए लॉगिंग हुई है।

क्लोजर में, हालांकि आप सीधे जावा के लॉगिंग फ्रेमवर्क्स का उपयोग कर सकते हैं, `clojure.tools.logging` जो भी लॉगिंग फ्रेमवर्क आपके classpath में मिलता है, उसकी पहचान करता है और उसे डेलिगेट करता है, जिससे आप एक विशिष्ट क्रियान्वयन से कड़ाई से बंधे नहीं होते हैं। यह आपके क्लोजर कोड को अधिक पोर्टेबल और मॉड्यूलर बनाए रखने में मदद कर सकता है।

क्लोजर इकोसिस्टम के भीतर `clojure.tools.logging` के विकल्पों में `timbre` जैसे लाइब्रेरीज शामिल हैं, जो एक शुद्ध क्लोजर लॉगिंग लाइब्रेरी है जिसमें लॉग रोटेशन, फ़िल्टरिंग, और बॉक्स से बाहर एसिंक्रोनस लॉगिंग जैसी विशेषताएं हैं।

क्लोजर जैसे मल्टी-थ्रेडेड वातावरण में लॉगिंग करते समय क्रियान्वयन विवरण महत्वपूर्ण होते हैं। यहाँ, अपरिवर्तनीयता और साइड-इफ़ेक्ट प्रबंधन विशेष लाभ प्रदान करते हैं। लॉगिंग, एक साइड-इफ़ेक्ट के रूप में, ध्यान से संभाला जाना चाहिए ताकि प्रदर्शन में बाधा और थ्रेड-सेफ्टी सुनिश्चित की जा सके, जो अधिकतर जावा लॉगिंग फ्रेमवर्क्स पहले से ही देखभाल करते हैं।

अंत में, संरचित लॉगिंग पर विचार करें, जहाँ लॉग्स को संरचित डेटा (जैसे JSON) के रूप में लिखा जाता है। यह बाद में विश्लेषण और प्रोसेसिंग के लिए अत्यधिक उपयोगी हो सकता है, विशेष रूप से बड़े-पैमाने के वितरित सिस्टम्स से निपटने के समय।

## यह भी देखें
यदि आप और जानकारी के लिए उत्सुक हैं, तो इन संसाधनों को देखें:

- क्लोजर टूल्स लॉगिंग दस्तावेज़ीकरण: https://github.com/clojure/tools.logging
- टिम्बर, एक क्लोजर लॉगिंग लाइब्रेरी: https://github.com/ptaoussanis/timbre
- क्लोजर में लॉग4जे कॉन्फ़िगर करना: http://clojure-doc.org/articles/tutorials/logging_with_log4j.html
- उन्नत सेटअप के लिए लॉगबैक मैनुअल: http://logback.qos.ch/manual/
- क्लोजर में संरचित लॉगिंग पर गाइड: https://corfield.org/blog/2020/04/28/structured-logging/