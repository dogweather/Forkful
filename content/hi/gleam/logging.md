---
title:                "लॉगिंग"
date:                  2024-01-26T01:07:23.061495-07:00
model:                 gpt-4-1106-preview
simple_title:         "लॉगिंग"
programming_language: "Gleam"
category:             "Gleam"
tag:                  "Good Coding Practices"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/hi/gleam/logging.md"
---

{{< edit_this_page >}}

## क्या और क्यों?
लॉगिंग वास्तव में हमारे प्रोग्राम्स में होने वाली घटनाओं को रिकॉर्ड करने का तरीका है। यह एक छोटे काले बॉक्स की तरह है; जब चीजें गलत होती हैं (और विश्वास करें, वह होंगी ही), लॉग्स यह पता लगाने में अमूल्य सिद्ध होते हैं कि क्या हुआ, समस्याओं का निदान करने, और प्रदर्शन का अनुकूलन करने के लिए।

## कैसे करें:
Gleam में, आप आमतौर पर एक लॉगिंग लाइब्रेरी को शामिल करेंगे—इसमें कोई समर्पित लॉगिंग तंत्र नहीं होता। मान लीजिए हम एक काल्पनिक `gleam_logger` क्रेट का उपयोग कर रहे हैं। यहाँ आप इसे कैसे एकीकृत कर सकते हैं:

```gleam
import gleam_logger

pub fn main() {
  gleam_logger.info("App is starting up!")
  let result = intense_calculation()

  case result {
    Ok(value) -> 
      gleam_logger.debug("Calculation successful", value)
    Error(err) -> 
      gleam_logger.error("Calculation failed", err)
  }
}
```

आपके लॉग्स में अपेक्षित आउटपुट कुछ इस प्रकार दिखेगा:

```
INFO: App is starting up!
DEBUG: Calculation successful 42
ERROR: Calculation failed Reason: Divide by zero
```

## गहन जानकारी
लॉगिंग की कला प्रोग्रामिंग के शुरुआती दिनों से है। सिस्टम ऑपरेटर्स कंप्यूटर से लिटरली लॉग्स प्राप्त करते थे - सुनिश्चित करते हुए कि सब कुछ सहजता से चल रहा है। आगे बढ़ते हुए, लॉगिंग डिजिटल हो गई है, और सॉफ्टवेर विकास का एक मुख्य हिस्सा बन गई है।

जबकि Gleam, एक अपेक्षाकृत नई भाषा है जो Erlang इकोसिस्टम को लक्ष्य करती है, के पास एक निर्मित लॉगिंग फ्रेमवर्क नहीं है, आप परिपक्व Erlang लॉगिंग सुविधाओं या अन्य समुदाय-प्रदत्त लाइब्रेरीज का लाभ उठा सकते हैं। प्रत्येक में विभिन्न विशेषताओं और ट्रेडऑफ्स हैं: कुछ संरचित लॉगिंग प्रदान कर सकते हैं, अन्य अधिक सिंपल टेक्स्ट आउटपुट के लिए होते हैं।

अब, एक लॉगिंग तंत्र को लागू करने का प्रश्न: क्या यह सरल है? पहली नजर में, हां। लेकिन परतों को वापस छीलें, और आप समवर्तीता, I/O बॉटलनेक्स, लॉग रोटेशन, प्रारूप मानकीकरण (संरचित लॉगिंग के लिए JSON सोचें), स्तर फिल्टरिंग, और संभवतः वितरित ट्रेसिंग को संभालने में देख रहे हैं। प्लस, एक कार्यात्मक पैराडाइम में, आप आम तौर पर चाहते हैं कि पार्श्व प्रभाव (जैसे कि लॉगिंग) को एक अनुमानित और नियंत्रित तरीके से संभाला जाए।

## इसे भी देखें
यहां आप Gleam में लॉगिंग की गुटिका और इसके आसपास के इकोसिस्टम के बारे में और जान सकते हैं:
- [Erlang का :logger दस्तावेज़ीकरण](http://erlang.org/doc/apps/kernel/logger_chapter.html): चूंकि Gleam Erlang में संकलित होता है, यह सीधे लागू होता है।
- [Gleam का मानक पुस्तकालय दस्तावेज़](https://hexdocs.pm/gleam_stdlib/): किसी भी लॉगिंग उपयोगिताओं के अपडेट्स के लिए जो जोड़े जा सकते हैं।
- [Awesome Gleam](https://github.com/gleam-lang/awesome-gleam): एक चयनित सूची संसाधनों की, जिसमें लॉगिंग लाइब्रेरीज शामिल हो सकती हैं जैसे कि वह उपलब्ध हो जाती हैं।
