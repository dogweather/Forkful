---
aliases:
- /hi/c/calculating-a-date-in-the-future-or-past/
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 17:55:03.161751-07:00
description: "\u092D\u0935\u093F\u0937\u094D\u092F \u092F\u093E \u0905\u0924\u0940\
  \u0924 \u092E\u0947\u0902 \u090F\u0915 \u0924\u093E\u0930\u0940\u0916 \u0915\u0940\
  \ \u0917\u0923\u0928\u093E \u0915\u0930\u0928\u093E \u0907\u0938\u0915\u093E \u0905\
  \u0930\u094D\u0925 \u0939\u0948 \u0915\u093F\u0938\u0940 \u0928\u093F\u0930\u094D\
  \u0926\u093F\u0937\u094D\u091F \u0924\u093E\u0930\u0940\u0916 \u0915\u093E \u0928\
  \u093F\u0930\u094D\u0927\u093E\u0930\u0923 \u090F\u0915 \u0926\u093F\u0928, \u092E\
  \u0939\u0940\u0928\u0947, \u092F\u093E \u0935\u0930\u094D\u0937 \u0915\u0940 \u0928\
  \u093F\u0936\u094D\u091A\u093F\u0924 \u0938\u0902\u0916\u094D\u092F\u093E \u0915\
  \u094B \u0915\u093F\u0938\u0940 \u0926\u093F\u092F\u0947 \u0917\u090F \u0924\u093E\
  \u0930\u0940\u0916 \u0938\u0947\u2026"
lastmod: 2024-02-18 23:09:04.237851
model: gpt-4-0125-preview
summary: "\u092D\u0935\u093F\u0937\u094D\u092F \u092F\u093E \u0905\u0924\u0940\u0924\
  \ \u092E\u0947\u0902 \u090F\u0915 \u0924\u093E\u0930\u0940\u0916 \u0915\u0940 \u0917\
  \u0923\u0928\u093E \u0915\u0930\u0928\u093E \u0907\u0938\u0915\u093E \u0905\u0930\
  \u094D\u0925 \u0939\u0948 \u0915\u093F\u0938\u0940 \u0928\u093F\u0930\u094D\u0926\
  \u093F\u0937\u094D\u091F \u0924\u093E\u0930\u0940\u0916 \u0915\u093E \u0928\u093F\
  \u0930\u094D\u0927\u093E\u0930\u0923 \u090F\u0915 \u0926\u093F\u0928, \u092E\u0939\
  \u0940\u0928\u0947, \u092F\u093E \u0935\u0930\u094D\u0937 \u0915\u0940 \u0928\u093F\
  \u0936\u094D\u091A\u093F\u0924 \u0938\u0902\u0916\u094D\u092F\u093E \u0915\u094B\
  \ \u0915\u093F\u0938\u0940 \u0926\u093F\u092F\u0947 \u0917\u090F \u0924\u093E\u0930\
  \u0940\u0916 \u0938\u0947\u2026"
title: "\u092D\u0935\u093F\u0937\u094D\u092F \u092F\u093E \u0905\u0924\u0940\u0924\
  \ \u092E\u0947\u0902 \u0926\u093F\u0928\u093E\u0902\u0915 \u0915\u0940 \u0917\u0923\
  \u0928\u093E"
---

{{< edit_this_page >}}

## क्या और क्यों?
भविष्य या अतीत में एक तारीख की गणना करना इसका अर्थ है किसी निर्दिष्ट तारीख का निर्धारण एक दिन, महीने, या वर्ष की निश्चित संख्या को किसी दिये गए तारीख से जोड़कर या घटाकर करना। कार्यक्रमकर्ता इसे घटनाओं की योजना बनाने, अनुस्मारक उत्पन्न करने, या समाप्ति तारीखों को संभालने जैसे कार्यों के लिए करते हैं, जिससे यह कैलेंडर प्रणालियों से लेकर वित्तीय सॉफ्टवेयर तक विभिन्न अनुप्रयोगों में एक आवश्यक कार्यक्षमता बन जाती है।

## कैसे:
जबकि C मानक पुस्तकालय सीधे तौर पर तारीख अंकगणित के लिए फंक्शन प्रदान नहीं करता है, आप `time.h` पुस्तकालय का उपयोग करके तारीखों को संशोधित कर सकते हैं, विशेष रूप से `time_t` डेटा प्रकार और `struct tm` के साथ काम करते हुए। यहाँ वर्तमान तारीख में दिन जोड़ने का एक सरलीकृत उदाहरण है:

```c
#include <stdio.h>
#include <time.h>

void addDays(struct tm* date, int daysToAdd) {
    const time_t ONE_DAY = 24 * 60 * 60; // एक दिन में सेकंड
    // tm संरचना को time_t में परिवर्तित करें, दिन जोड़ें, और वापस परिवर्तित करें
    time_t date_seconds = mktime(date) + (daysToAdd * ONE_DAY);
    *date = *localtime(&date_seconds);
}

int main() {
    time_t now;
    time(&now);
    struct tm futureDate = *localtime(&now);

    int daysToAdd = 10; // जोड़ने के लिए वांछित दिनों को समायोजित करें
    addDays(&futureDate, daysToAdd);

    printf("Future Date: %d-%d-%d\n", futureDate.tm_year + 1900, futureDate.tm_mon + 1, futureDate.tm_mday);

    return 0;
}
```

यह कोड वर्तमान तारीख में निर्दिष्ट संख्या में दिन जोड़ता है और भविष्य की तारीख प्रिंट करता है। ध्यान दें कि यह दृष्टिकोण अधिसंख्य सेकेंड और दिन की बचत समय समायोजनों को `mktime` और `localtime` द्वारा संभालता है।

नमूना आउटपुट:

```
Future Date: 2023-04-23
```

ध्यान रखें, यह उदाहरण दिनों को जोड़ता है, लेकिन अधिक जटिल गणनाओं (जैसे महीने या वर्ष, लीप वर्षों को ध्यान में रखते हुए) के लिए, आपको अधिक सोफ़िस्टीकेटेड लॉजिक या C++ में `date.h` जैसे पुस्तकालय या C में थर्ड-पार्टी पुस्तकालयों की आवश्यकता होगी।

## गहन अवलोकन
C का उपयोग करके time.h पुस्तकालय के साथ तारीखों को संशोधित करना यूनिक्स युग के बाद से सेकंड्स में समय के सीधे मैनिपुलेशन को शामिल करता है (00:00, जन 1, 1970, UTC), इसके बाद उन सेकंड्स को अधिक मानव-पठनीय तारीख प्रारूप में (`struct tm`) वापस परिवर्तित करना। यह दृष्टिकोण सरल है लेकिन मूलभूत क्रियाओं के लिए प्रभावी है और पार-मंच होने के नाते और C मानक पुस्तकालय का हिस्सा होने का लाभ उठाता है।

हालाँकि, इस विधि की सादगी एक सीमा भी है। अधिक जटिल तारीख गणनाओं (जैसे कि भिन्न महीने की लंबाई, लीप वर्ष, और समय क्षेत्रों को ध्यान में रखना) को जल्दी से गैर-तुच्छ बनाना। पायथन के साथ `datetime` या जावा के साथ `java.time` जैसी भाषाएँ तारीख अंकगणित के लिए अधिक सहज APIs प्रदान करती हैं, स्पष्टता और उपयोग में आसानी के लिए ऑब्जेक्ट-ओरिएंटेड सिद्धांतों को अपनाती हैं।

व्यवहार में, C में विस्तृत तारीख संशोधन की आवश्यकता वाली परियोजनाओं पर काम करते समय, डेवलपर्स अक्सर थर्ड-पार्टी पुस्तकालयों की ओर रुख करते हैं जो अधिक मजबूत समाधान प्रदान करते हैं। ये पुस्तकालय समय क्षेत्र संभालने, स्वरूपण विकल्पों, और अधिक सूक्ष्म तारीख अंकगणित क्षमताओं सहित व्यापक तारीख और समय कार्यक्षमता प्रदान कर सकते हैं, जिससे डेवलपर का कार्य सरल हो जाता है।

अधिक आधुनिक विकल्पों की उपलब्धता के बावजूद, C मानक पुस्तकालय का उपयोग करके तारीखों को संशोधित करने का तरीका समझना एक मूल्यवान कौशल बना रहता है। यह गहरी अंतर्दृष्टि प्रदान करता है कि कंप्यूटर समय को कैसे प्रस्तुत और काम करते हैं, एक मौलिक अवधारणा जो विशिष्ट प्रोग्रामिंग भाषाओं से परे है।
