---
title:                "एक अस्थायी फ़ाइल बनाना"
date:                  2024-02-03T17:57:03.226168-07:00
model:                 gpt-4-0125-preview
simple_title:         "एक अस्थायी फ़ाइल बनाना"
tag:                  "Files and I/O"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/hi/c/creating-a-temporary-file.md"
changelog:
  - 2024-02-03, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## क्या और क्यों?
C में एक अस्थायी फ़ाइल बनाना फ़ाइल उत्पन्न करने की प्रक्रिया है जिसे एक छोटी अवधि के लिए उपयोग किया जाना है, आमतौर पर डेटा प्रोसेसिंग या स्टोरेज के लिए स्क्रेच स्पेस के रूप में। प्रोग्रामर इसे अस्थायी डेटा का प्रबंधन करने के लिए करते हैं ताकि कार्यक्रम की स्थायी स्टोरेज पर प्रभाव न पड़े या संवेदनशील डेटा का उपयोग के बाद मिटाना सुनिश्चित करें।

## कैसे?
C प्रोग्रामिंग भाषा में एक अस्थायी फ़ाइल बनाना `tmpfile()` और `mkstemp()` जैसे फ़ंक्शन्स का उपयोग कर सकता है।

**`tmpfile()` का उपयोग करते हुए**: यह फ़ंक्शन एक अनूठी अस्थायी फ़ाइल बनाता है जो स्वतः ही मिटा दी जाती है जब कार्यक्रम समाप्त होता है या फ़ाइल बंद होती है।

```c
#include <stdio.h>

int main() {
    FILE *temp = tmpfile();
    if (temp == NULL) {
        perror("अस्थायी फ़ाइल बनाने में विफल");
        return 1;
    }

    // अस्थायी फ़ाइल में डेटा लिखना
    fputs("यह एक परीक्षण है।\n", temp);

    // पुनः पढ़ने के लिए रिवाइंड करें और जो हमने लिखा है उसे पढ़ें
    rewind(temp);
    char buffer[1024];
    while (fgets(buffer, sizeof(buffer), temp) != NULL) {
        printf("%s", buffer);
    }

    // स्वतः मिटा दिया जाता है बंद होने पर या प्रोग्राम समाप्ति पर
    fclose(temp);

    return 0;
}
```
**नमूना आउटपुट:**
```
यह एक परीक्षण है।
```

**`mkstemp()` का उपयोग करते हुए**: यह अस्थायी फ़ाइल के स्थान और उसकी अनुमतियों पर अधिक नियंत्रण प्रदान करता है। इसके लिए एक टेम्पलेट स्ट्रिंग की आवश्यकता होती है जो `XXXXXX` से समाप्त होती है जिसे फिर यह एक अनूठी श्रृंखला से बदल देता है ताकि नाम संघर्षों से बच सके।

```c
#include <unistd.h>
#include <stdio.h>
#include <fcntl.h>

int main() {
    char template[] = "/tmp/mytemp-XXXXXX";
    int fd = mkstemp(template);

    if (fd == -1) {
        perror("अस्थायी फ़ाइल बनाने में विफल");
        return 1;
    }
    
    printf("अस्थायी फ़ाइल बनाई गई: %s\n", template);

    // mkstemp() के साथ बनाई गई अस्थायी फ़ाइलों को मैन्युअल रूप से मिटा देना चाहिए
    unlink(template);

    close(fd);
    return 0;
}
```
**नमूना आउटपुट:**
```
अस्थायी फ़ाइल बनाई गई: /tmp/mytemp-abc123
```

## गहराई से विचार
अस्थायी फ़ाइलों की अवधारणा C तक सीमित नहीं है बल्कि कई प्रोग्रामिंग परिवेशों में एक आम कार्यक्षमता है  क्योंकि यह अस्थायी डेटा को संभालने में उपयोगिता प्रदान करती है। ISO C मानक में मानकीकृत `tmpfile()` फ़ंक्शन, एक मानक निर्देशिका में एक अनूठा नाम के साथ फ़ाइल बनाता है, लेकिन इसका अस्तित्व क्षणभंगुर होता है, जिससे यह सुरक्षित या अस्थायी संचालनों के लिए आदर्श होता है।

`tmpfile()` की एक उल्लेखनीय सीमा डिफॉल्ट अस्थायी निर्देशिका पर इसकी निर्भरता है, जो सभी अनुप्रयोगों के लिए उपयुक्त नहीं हो सकती है विशेषकर अनुमतियों या सुरक्षा के संदर्भ में। इसके विपरीत, `mkstemp()` निर्देशिका का निर्दिष्टीकरण करने की अनुमति देता है और प्रदान किए गए टेम्पलेट स्ट्रिंग को संशोधित करके अनूठे फ़ाइलनामों के साथ सुरक्षित फ़ाइल निर्माण सुनिश्चित करता है, मैनुअल फ़ाइल प्रबंधन की कीमत पर अधिक बहुमुखी समाधान प्रदान करता है।

हालांकि, अस्थायी फ़ाइलें बनाना, यदि ठीक से संभाला न जाए, तो सुरक्षा कमजोरियों जैसे कि रेस कंडीशन को परिचय कर सकता है। उदाहरण के लिए, `tmpfile()` और `mkstemp()` विभिन्न पहलुओं को संबोधित करते हैं (स्वचालित विलोपन और सुरक्षित नाम निर्माण क्रमशः), लेकिन न तो एक रामबाण है। डेवलपर्स को अपने एप्लिकेशन की सुरक्षा आवश्यकताओं के विशेषिकाओं पर विचार करना चाहिए, जिसमें अस्थायी फ़ाइलों द्वारा पेश की गई संभावित कमजोरियों शामिल हैं, और इन फ़ंक्शन्स द्वारा प्रदान की गई सुरक्षा के अतिरिक्त अन्य सुरक्षात्मक उपायों को लागू करने की आवश्यकता हो सकती है।

प्रोग्रामिंग की व्यापक परिदृश्य में, अस्थायी डेटा हैंडलिंग के लिए बेहतर प्रदर्शन या सुरक्षा प्रदान कर सकने वाले वैकल्पिक रूप में स्मृति में स्टोरेज (जैसे, गतिशील डेटा संरचनाओं या स्मृति-मैप्ड फ़ाइलों का उपयोग करके) शामिल हो सकते हैं। फिर भी, भौतिक अस्थायी फ़ाइलें कई परिदृश्यों में एक महत्वपूर्ण उपकरण बनी हुई हैं, विशेष रूप से बड़े डेटा सेटों के लिए या जब अंतः-प्रक्रिया संचार शामिल होता है।
