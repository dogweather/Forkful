---
title:                "एक टेक्स्ट फ़ाइल लिखना"
aliases:
- hi/c/writing-a-text-file.md
date:                  2024-02-03T18:16:15.165434-07:00
model:                 gpt-4-0125-preview
simple_title:         "एक टेक्स्ट फ़ाइल लिखना"
tag:                  "Files and I/O"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/hi/c/writing-a-text-file.md"
changelog:
  - 2024-02-03, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## क्या और क्यों?

C में एक टेक्स्ट फ़ाइल लिखना इसे लेखन मोड में बनाने या खोलने और फिर C के फ़ाइल I/O फ़ंक्शन्स का उपयोग करके उसमें टेक्स्ट डेटा सहेजने की प्रक्रिया होती है। प्रोग्रामर्स यह डेटा को स्थायी रूप से सहेजने के लिए करते हैं, जैसे कि लॉग इवेंट्स, कॉन्फ़िगरेशन सेटिंग्स, या उपयोगकर्ता उत्पादित सामग्री, जो अनुप्रयोगों को सत्रों के आर-पार स्थिति, प्राथमिकताएँ, या उपयोगकर्ता प्रगति को बनाए रखने की अनुमति देती है।

## कैसे:

C में एक फ़ाइल में टेक्स्ट लिखने के लिए, आपको मुख्य रूप से `fopen()`, `fprintf()`, `fputs()`, और `fclose()` फ़ंक्शन्स से परिचित होना चाहिए। नीचे एक साधारण उदाहरण दिया गया है जो एक फ़ाइल बनाने और उसमें लिखने को दर्शाता है:

```c
#include <stdio.h>

int main() {
    FILE *filePointer;
    // एक फ़ाइल को लेखन मोड में खोलता है। यदि फ़ाइल मौजूद नहीं है, तो यह बना दी जाएगी।
    filePointer = fopen("example.txt", "w");
    
    if(filePointer == NULL) {
        printf("फ़ाइल नहीं खोली जा सकी\n");
        return 1; // यदि फ़ाइल पॉइंटर NULL लौटाया गया तो कार्यक्रम बाहर निकल जाएगा।
    }
    
    // फ़ाइल में लिखना
    fprintf(filePointer, "यह फ़ाइल में लिखने का एक उदाहरण है।\n");
    fputs("यहाँ एक और पंक्ति का टेक्स्ट है।\n", filePointer);
    
    // परिवर्तनों को सहेजने के लिए फ़ाइल बंद करना
    fclose(filePointer);
    
    printf("फ़ाइल सफलतापूर्वक लिखी गई\n");
    return 0;
}
```

सफल निष्पादन पर नमूना आउटपुट:
```
फ़ाइल सफलतापूर्वक लिखी गई
```

इस प्रोग्राम को चलाने के बाद, आपको समान निर्देशिका में `example.txt` नामक एक फ़ाइल मिलेगी, जिसमें `fprintf()` और `fputs()` के माध्यम से लिखा गया टेक्स्ट होगा।

## गहराई से:

फ़ाइलों और फ़ाइल सिस्टमों की अवधारणा कंप्यूटर सिस्टमों के लिए मौलिक रही है, जिनका प्रबंधन ऑपरेटिंग सिस्टमों का एक महत्वपूर्ण पहलू है। C में, फ़ाइलों को संभाला जाता है मानक I/O लाइब्रेरी फ़ंक्शन्स के एक सेट का उपयोग करके, जो फ़ाइलों को बाइट्स की धाराओं के रूप में व्यवहार करने की दर्शन पर आधारित है। यह अमूर्तन फ़ाइलों से पढ़ने और फ़ाइलों में लिखने का एक सीधा और कुशल तरीका प्रदान करता है, हालांकि यह पायथन या रूबी जैसी अधिक आधुनिक भाषाओं में उपलब्ध दृष्टिकोणों की तुलना में कम स्तरीय प्रतित हो सकता है।

ऐतिहासिक रूप से, C में ये फ़ाइल I/O ऑपरेशन कई प्रोग्रामिंग भाषाओं में फ़ाइल मैनिपुलेशन के लिए आधार रखते हैं, जिसमें ऑपरेटिंग सिस्टम के फ़ाइल प्रबंधन सिस्टमों के साथ एक निकट-संबंध इंटरफ़ेस पेश किया गया है। यह न केवल फ़ाइल विशेषताओं और I/O ऑपरेशनों पर बारीकी से नियंत्रण प्रदान करता है, बल्कि सावधान रहे बिना प्रोग्रामर्स के लिए पिटफॉल्स भी प्रदान करता है, जैसे कि संसाधनों का मैन्युअल रूप से प्रबंधन (यानी, हमेशा फ़ाइलों को बंद करना) और बफ़रिंग मुद्दे।

जबकि C में बुनियादी फ़ाइल I/O फ़ंक्शन्स शक्तिशाली हैं और कई कार्यों के लिए पर्याप्त हैं, वे आधुनिक भाषाओं द्वारा प्रदान की गई आसानी और उच्च-स्तरीय अमूर्तिकरण से कमी हैं। Python जैसी भाषाएँ मेमोरी प्रबंधन और फ़ाइल बंद करने को स्वचालित करती हैं (उदाहरण के लिए `with` स्टेटमेंट्स का उपयोग करती हैं), जिससे बूटस्ट्रैप कोड को काफी कम किया जा सकता है और संसाधन लीक्स का जोखिम कम हो जाता है। जटिल फ़ाइल मैनिपुलेशन या उच्च-स्तरीय अमूर्तिकरणों (जैसे फ़ाइल लॉक्स, असमकालिक I/O, या फ़ाइल सिस्टम इवेंट्स की निगरानी) की आवश्यकता वाले अनुप्रयोगों के लिए, इन सुविधाओं की पेशकश करने वाले लाइब्रेरीज़ की तलाश करना या ऐसी संरचनाओं का स्वाभाविक रूप से समर्थन करने वाली भाषा चुनना बेहतर हो सकता है।

फिर भी, C में फ़ाइल I/O को समझना अमूल्य है, जो उच्च-स्तरीय भाषाओं द्वारा इन सुविधाओं को कैसे लागू किया जाता है, इसकी अंतर्दृष्टि प्रदान करता है और जब प्रदर्शन और नियंत्रण सर्वोपरि होते हैं, तब कुशल, निम्न-स्तरीय कोड लिखने के उपकरण प्रदान करता है।
