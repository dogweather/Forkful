---
title:                "इंटरैक्टिव शेल (REPL) का उपयोग करना"
date:                  2024-02-03T18:11:31.522628-07:00
model:                 gpt-4-0125-preview
simple_title:         "इंटरैक्टिव शेल (REPL) का उपयोग करना"
tag:                  "Testing and Debugging"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/hi/go/using-an-interactive-shell-repl.md"
changelog:
  - 2024-02-03, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## क्या और क्यों?

एक इंटरैक्टिव शेल, या रीड-एवैल-प्रिंट लूप (REPL), आपको रियल-टाइम में Go कोड के साथ प्रयोग करने, आदेशों को निष्पादित करने और तत्काल प्रतिक्रिया प्राप्त करने की अनुमति देता है। यह दृष्टिकोण सीखने, डिबगिंग और प्रोटोटाइपिंग के लिए व्यापक रूप से उपयोग में आता है, क्योंकि यह पारंपरिक संपादित-संकलन-चलाने के चक्र को दरकिनार करता है, विकास प्रक्रिया को तेज और अधिक सहज बनाता है।

## कैसे:

हालांकि Go में बिल्ट-इन REPL शामिल नहीं है, समुदाय ने `gore` जैसे टूल्स बनाए हैं जो इस गैप को भरते हैं। सबसे पहले, `gore` को इंस्टॉल करें इस रन कमांड के द्वारा:

```
$ go get -u github.com/motemen/gore
```

एक बार इंस्टॉल हो जाने पर, `gore` को लॉन्च करें यह अपने टर्मिनल में `gore` टाइप करके:

```
$ gore
```

आपको एक प्रॉम्प्ट दिखाई देगा जो Go आदेशों को स्वीकार करने के लिए तैयार है। आइए एक सरल उदाहरण आज़माते हैं:

```
gore> :import fmt
gore> fmt.Println("Hello, Go REPL!")
```

आपको निम्नलिखित आउटपुट दिखाई देगा:

```
Hello, Go REPL!
```

वेरिएबल्स और फ़ंक्शन डेफिनिशन्स अपेक्षित रूप से काम करते हैं। आप एक फंक्शन घोषित कर सकते हैं:

```
gore> :import math
gore> areaCircle := func(radius float64) float64 {
...> return math.Pi * radius * radius
...> }
gore> fmt.Println("Area of circle with radius 4:", areaCircle(4))
```

और तुरंत आउटपुट प्राप्त करें:

```
Area of circle with radius 4: 50.26548245743669
```

## गहन अध्ययन:

REPL की अवधारणा प्राचीन है, यह 1960 के दशक की Lisp मशीनों तक वापस जाती है, जो एक इंटरैक्टिव प्रोग्रामिंग अनुभव प्रदान करती है। पायथन या जावास्क्रिप्ट जैसी भाषाओं के विपरीत, Go को एक REPL के बिना डिज़ाइन किया गया था, इसके बजाय प्रदर्शन और सादगी के लिए संकलित बाइनरीज पर ध्यान केंद्रित करता है। यह Go की सादगी के दर्शन और पैमाने योग्य और रखरखाव योग्य सॉफ्टवेयर के लिए इसकी डिजाइन को दर्शाता है।

हालांकि, `gore` या `goplay` जैसे टूल्स Go समुदाय की संसाधनशीलता को दिखाते हैं जो इस गैप को पाटने में सहायक हैं। ये टूल्स Go कोड को गतिशील रूप से पार्स करते हैं और `go/eval` पैकेज या इसी तरह के तंत्रों का उपयोग करके इसे रियल-टाइम में निष्पादित करते हैं, हालांकि कुछ सीमाएं होती हैं जो एक देशी REPL वातावरण की तुलना में होती हैं। ये सीमाएँ Go के टाइप सिस्टम और संकलन मॉडल से उत्पन्न होती हैं, जो ऑन-द-फ्लाई मूल्यांकन को चुनौतीपूर्ण बना सकती हैं।

जबकि REPL वातावरण शिक्षा और त्वरित परीक्षणों के लिए असाधारण उपयोगी होते हैं, Go ईकोसिस्टम आमतौर पर अधिकांश विकास कार्यों के लिए पारंपरिक संकलन-और-चलाने की प्रक्रियाओं की ओर झुकाव रखता है। विज़ुअल स्टूडियो कोड या GoLand जैसे Go सपोर्ट वाले IDEs और एडिटर्स, परीक्षण और डिबगिंग के लिए एकीकृत टूल्स प्रदान करते हैं जो पेशेवर विकास के लिए REPL की आवश्यकता को काफी हद तक कम करते हैं।

हालांकि, खोजपरक प्रोग्रामिंग, प्रोटोटाइपिंग, या सीखने के लिए, REPLs जैसे कि `gore` एक मूल्यवान विकल्प प्रदान करते हैं, जो अन्य भाषाओं में REPLs के आदी प्रोग्रामर्स को Go में इसी तरह का अनुभव का आनंद लेने की अनुमति देते हैं।
