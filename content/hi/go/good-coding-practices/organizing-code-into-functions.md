---
title:                "कोड को फंक्शन्स में व्यवस्थित करना"
aliases:
- hi/go/organizing-code-into-functions.md
date:                  2024-02-03T18:08:07.143546-07:00
model:                 gpt-4-0125-preview
simple_title:         "कोड को फंक्शन्स में व्यवस्थित करना"
tag:                  "Good Coding Practices"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/hi/go/organizing-code-into-functions.md"
changelog:
  - 2024-02-03, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## क्या और क्यों?

Go में कोड को फंक्शन्स में व्यवस्थित करना इसे विशिष्ट कार्यों को करने के लिए पुन: प्रयोज्य, मॉड्यूलर ब्लॉकों में तोड़ने का कार्य करता है। यह दृष्टिकोण कोड की पठनीयता, रख-रखाव, और टीम सहयोग को बढ़ावा देता है क्योंकि यह प्रोग्रामर्स को विभिन्न फंक्शन्स पर एक साथ काम करने में सक्षम बनाता है।

## कैसे:

Go में, आप एक फंक्शन को `func` कीवर्ड के साथ परिभाषित करते हैं, उसके बाद फंक्शन का नाम, पैरामीटर्स (यदि कोई हो), और रिटर्न प्रकार आता है। एक सरल उदाहरण के साथ चलिए देखते हैं:

```go
package main

import "fmt"

// दो संख्याओं का जोड़ कैलकुलेट करने के लिए एक फंक्शन की परिभाषा दें
func addNumbers(a int, b int) int {
    return a + b
}

func main() {
    sum := addNumbers(5, 7)
    fmt.Println("जोड़ है:", sum)
    // आउटपुट: जोड़ है: 12
}
```

फंक्शन्स मल्टीपल मूल्य भी लौटा सकते हैं, जो कि कई अन्य भाषाओं की तुलना में एक अनोखी विशेषता है। आप यह इस प्रकार उपयोग कर सकते हैं:

```go
// दो संख्याओं को स्वैप करने के लिए एक फंक्शन की परिभाषा दें
func swap(a, b int) (int, int) {
    return b, a
}

func main() {
    x, y := swap(10, 20)
    fmt.Println("स्वैप के बाद x, y:", x, y)
    // आउटपुट: स्वैप के बाद x, y: 20 10
}
```

आप पैरामीटर प्रकार से पहले एलिप्सिस `...` का उपयोग करके अज्ञात संख्या के तर्कों वाले फंक्शन्स को भी परिभाषित कर सकते हैं। यह लचीले फंक्शन्स बनाने में उपयोगी है:

```go
// अज्ञात संख्या की पूर्णांकों का जोड़ गणना करने के लिए एक फंक्शन की परिभाषा दें
func sum(numbers ...int) int {
    total := 0
    for _, number := range numbers {
        total += number
    }
    return total
}

func main() {
    total := sum(1, 2, 3, 4, 5)
    fmt.Println("कुल है:", total)
    // आउटपुट: कुल है: 15
}
```

## गहराई से समझना

कोड को फंक्शन्स में व्यवस्थित करने की अवधारणा केवल Go तक सीमित नहीं है—यह एक मौलिक प्रोग्रामिंग सिद्धांत है। हालांकि, Go कुछ परंपराओं और सामर्थ्यों को पेश करता है जो इसके फंक्शन प्रबंधन को विशिष्ट बनाते हैं। उदाहरण के लिए, फंक्शन्स से मल्टीपल मूल्यों को लौटाने की क्षमता अपेक्षाकृत अनोखी है और खासकर पॉइंटर्स या अपवाद संभाल के उपयोग की आवश्यकता वाले कार्यों के साथ डील करते वक्त साफ़, समझने में आसान कोड की ओर ले जा सकता है।

इसके अलावा, Go का फर्स्ट-क्लास फंक्शन्स के लिए समर्थन—फंक्शन्स जिन्हें अन्य फंक्शन्स के लिए तर्कों के रूप में पास किया जा सकता है, फंक्शन्स से मूल्यों के रूप में लौटाया जा सकता है, और चर को सौंपा जा सकता है—फ़ंक्शनल प्रोग्रामिंग पैटर्न्स के लिए भाषा के समर्थन को बढ़ाता है। यह विशेषता विशेष रूप से उच्च-आर्डर फंक्शन्स बनाने में उपयोगी है जो अन्य फंक्शन्स को संभालते हैं या संयोजित करते हैं।

हालांकि, कोड को फंक्शन्स में व्यवस्थित करते समय "कम होते हुए लाभ के नियम" का ध्यान रखना आवश्यक है। अत्यधिक मॉड्यूलरीकरण से कोड को समझना और रख-रखाव करना कठिन हो सकता है। इसके अलावा, जबकि Go का सरल तरीका को एरर हैंडलिंग (एरर्स को सामान्य रिटर्न मूल्यों के रूप में लौटाना) साफ एरर प्रचार को फंक्शन कॉल्स की कई परतों के माध्यम से प्रोत्साहित करता है, यह दोहरावदार एरर हैंडलिंग कोड की ओर ले जा सकता है। एरर हैंडलिंग फ्रेमवर्क्स या अन्य भाषाओं से "ट्राई-कैच" दृष्�कोण (हालांकि मूल रूप से समर्थित नहीं) को पैकेज कार्यान्वयनों के माध्यम से अपनाना कभी-कभी उपयोग मामले के आधार पर अधिक सुरुचिपूर्ण समाधान प्रदान कर सकता है।

Go में फंक्शन्स और मॉड्यूलरीकरण का उपयोग कितना व्यापक रूप से करना है, यह निर्णय अमूर्तीकरण, रखरखाव, प्रदर्शन, और पठनीय एरर हैंडलिंग की आवश्यकता के संतुलन को देखते हुए किया जाना चाहिए, जिससे Go की सरल, फिर भी शक्तिशाली विशेषताओं का सबसे अधिक लाभ उठाया जा सके।
