---
title:                "कमांड लाइन तर्कों को पढ़ना"
aliases:
- /hi/go/reading-command-line-arguments/
date:                  2024-02-03T18:07:21.526536-07:00
model:                 gpt-4-0125-preview
simple_title:         "कमांड लाइन तर्कों को पढ़ना"
tag:                  "Files and I/O"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/hi/go/reading-command-line-arguments.md"
changelog:
  - 2024-02-03, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## क्या और क्यों?

Go में कमांड लाइन आर्ग्युमेंट्स को पढ़ना शामिल है, जिसमें प्रोग्राम को टर्मिनल या कमांड प्रॉम्प्ट से दिए गए आर्ग्युमेंट्स को निकालना पड़ता है। प्रोग्रामर इसे कोड में परिवर्तन किए बिना प्रोग्राम के निष्पादन को अनुकूलित करने के लिए करते हैं, जिससे एप्लिकेशंस अधिक लचीले और उपयोगकर्ता-संचालित हो जाते हैं।

## कैसे:

Go, `os` पैकेज के माध्यम से, विशेष रूप से `os.Args` का उपयोग करके, कमांड-लाइन आर्ग्युमेंट्स तक सीधी पहुँच प्रदान करता है, जो एक स्ट्रिंग्स की एरे है। यहाँ एक सरल उदाहरण है जो हमें शुरुआत करने में मदद करता है:

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    // os.Args कमांड-लाइन आर्ग्युमेंट्स तक पहूँच प्रदान करता है
    fmt.Println("कमांड-लाइन आर्ग्युमेंट्स:", os.Args)

    if len(os.Args) > 1 {
        // आर्ग्युमेंट्स के माध्यम से लूप लगाएँ, पहला एक छोड़कर (प्रोग्राम का नाम)
        for i, arg := range os.Args[1:] {
            fmt.Printf("आर्ग्युमेंट %d: %s\n", i+1, arg)
        }
    } else {
        fmt.Println("कोई कमांड-लाइन आर्ग्युमेंट्स प्रदान नहीं किए गए.")
    }
}
```

`go run yourprogram.go arg1 arg2` के साथ चलाने पर नमूना आउटपुट कुछ इस प्रकार दिख सकता है:

```
कमांड-लाइन आर्ग्युमेंट्स: [/tmp/go-build123456789/b001/exe/yourprogram arg1 arg2]
आर्ग्युमेंट 1: arg1
आर्ग्युमेंट 2: arg2
```

इसमें प्रोग्राम का नाम सहीत सभी आर्ग्युमेंट्स को प्रिंट किया जाता है (अक्सर इंडेक्स 0 पर), फिर प्रदान किए गए प्रत्येक आर्ग्युमेंट पर इटरेट्स करता है, उन्हें प्रिंट करता है। अधिक नियंत्रित आर्ग्युमेंट पार्सिंग के लिए, आप कमांड-लाइन विकल्पों को पार्स करने के लिए `flag` पैकेज पर विचार कर सकते हैं।

## गहराई में जानकारी

ऐतिहासिक रूप से, कमांड-लाइन आर्ग्युमेंट्स तक पहुँचना C प्रोग्रामिंग जितना पुराना अभ्यास है, जहाँ `argc` और `argv[]` एक समान उद्देश्य सेवा करते हैं। Go में, `os.Args` इसे सरल लेकिन जानबूझकर आधारभूत बनाते हैं। अधिक जटिल परिदृश्यों के लिए, जैसे कि झंडे या विकल्पों को संभालना, Go `flag` पैकेज प्रदान करता है जिसमें मजबूत पार्सिंग क्षमताएं होती हैं। जब आपका एप्लिकेशन केवल स्थितिजन्य आर्ग्युमेंट्स से अधिक की आवश्यकता रखता हो, तो इसे "बेहतर" विकल्प माना जा सकता है।

कुछ स्क्रिप्टिंग भाषाओं के विपरीत जो कमांड-लाइन आर्ग्युमेंट्स को सहयोगी अर्रेजस या ऑब्जेक्ट्स में बिल्ट-इन पार्सिंग करती हैं, Go का दृष्टिकोण प्रोग्रामरों को आवश्यकतानुसार मैन्युअली `os.Args` का उपयोग करके पार्सिंग संभालने या अधिक उन्नत परिदृश्यों के लिए `flag` पैकेज का लाभ उठाने की आवश्यकता देता है। यह डिज़ाइन Go के दर्शन को दर्शाता है जो कोर भाषा को सरल रखते हुए सामान्य कार्यों के लिए शक्तिशाली मानक लाइब्रेरीज प्रदान करती है। हालांकि यह बिल्ट-इन पार्सिंग के अभ्यस्त लोगों के लिए थोड़ी सी सीखने की अवस्था पेश कर सकती है, यह अधिक लचीलापन प्रदान करती है और कमांड-लाइन आर्ग्युमेंट हैंडलिंग की गहरी समझ को प्रोत्साहित करती है।
