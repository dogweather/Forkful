---
title:                "עריכת קבצים במקום עם שורות פקודה חד-שורתיות"
date:                  2024-01-27T16:22:15.809686-07:00
model:                 gpt-4-0125-preview
simple_title:         "עריכת קבצים במקום עם שורות פקודה חד-שורתיות"

tag:                  "Data and Text Processing"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/he/bash/editing-files-in-place-with-cli-one-liners.md"
---

{{< edit_this_page >}}

## מה ולמה?

דמיינו שזה עתה גיליתם שאתם צריכים לבצע עדכון מסווג למספר קובצי תצורה הממוקמים בשרת שלכם. תוכלו לפתוח כל קובץ, לבצע את השינויים באופן ידני, ולשמור אותם. או, תוכלו לבצע עריכה במקום ישירות מהממשק שורת הפקודה (CLI) שלכם, מיומנות שחוסכת זמן, מפחיתה שגיאות, ומאוטמטת משימות חוזרות. טכניקה זו שימושית במיוחד לעדכונים מערכתיים, תיקונים, או שינויי המונים שבהם עריכה ידנית עשויה להיות לא מעשית או נתונה לטעויות.

## איך לעשות:

כאשר מדובר בעריכת קבצים במקום באמצעות Bash, שני כלים בולטים באים לפעולה: `sed` ו-`awk`. בואו נבחן כיצד להשתמש בכלים החזקים האלה עם דוגמאות קידוד.

### שימוש ב-`sed` להחלפת טקסט פשוטה

הפקודה הבאה מחליפה את המופע הראשון של "text1" עם "text2" ב-`file.txt`:

```Bash
sed -i 's/text1/text2/' file.txt
```

להחלפה גלובלית (כל המופעים), הייתם מוסיפים `g` בסוף:

```Bash
sed -i 's/text1/text2/g' file.txt
```

לשינוי מספר קבצים בו זמנית:

```Bash
sed -i 's/text1/text2/g' file1.txt file2.txt file3.txt
```

### שימוש ב-`awk` עבור מניפולציות מורכבות יותר

`awk` הוא כלי נוסף הבולט ביכולות התכנות שלו, במיוחד שימושי לעיבוד טקסט שכרוך בנתונים מבוססי שדות.

שינוי השדה השני בכל שורה ל-`newValue` ב-`data.csv`, מופרד בפסיקים:

```Bash
awk -i inplace -F, '{$2="newValue"; print $0}' OFS=, data.csv
```

### גיבוי לפני הקפיצה

עצה מעשית אחת: תמיד תיצרו גיבוי לפני עריכה במקום. `sed` מקל על כך עם אופציית ה-`-i` הבאה אחרי סיומת כדי ליצור גיבוי.

```Bash
sed -i.bak 's/text1/text2/g' file.txt
```

פקודה זו יוצרת גיבוי של `file.txt` המקורי כ-`file.txt.bak` לפני ביצוע ההחלפה.

## צלילה עמוקה

היכולת לערוך קבצים ישירות משורת הפקודה התפתחה כצעד הגיוני בהתקדמות פילוסופיית Unix: לאפשר למשתמשים לנהל ולטפל בנתונים בצורה יעילה עם כמה שפחות לחיצות מקשים. עם זאת, הכוח הזה בא עם מגבלותיו.

### הקשר ההיסטורי

כלים כמו `sed` ו-`awk` קיימים מראשית ימי Unix, נוצרו כחלק מפילוסופיית הערכת הכלים שלה, עם דגש על פקודות מתמחות, שניתן לשלבן. הכללתם בנשקיה של Unix הייתה תגובה לצורך בעיבוד טקסט יעיל בנוף ששלטו בו ממשקים מבוססי שורת פקודה.

### חלופות

אף על פי ש-`sed` ו-`awk` חזקים, הם לא האפשרויות היחידות. Perl ו-Python, לדוגמה, מציעים אפשרויות שורת פקודה (`-p` ו-`-i`, בהתאמה) שמאפשרות יכולות עריכה במקום דומות עם תחביר שנתפס כקריא יותר לפעולות מורכבות.

```Bash
perl -pi -e 's/text1/text2/g' file.txt
```

```Bash
python -c "import fileinput, sys; [sys.stdout.write(line.replace('text1', 'text2')) for line in fileinput.input(files='file.txt', inplace=True)]"
```

לכל חלופה יתרונותיה: היכולות הרבות של Perl לכתוב בשורה אחת הן עצומות, ותחביר Python נתפס כנגיש יותר לאלו שלא מבינים עמוקות בכלים לעיבוד טקסט מבוסס Unix.

### פרטי יישום

עריכה במקום לא באמת "במקום" במובן הטכני. גם `sed -i` וגם `awk -i inplace` פועלים על ידי יצירת קובץ זמני שבו הפלט המעובד מאוחסן לפני שהוא מחליף את הקובץ המקורי. גישה זו מבטיחה שהקובץ לא יתקלקל במידה והתהליך יופסק. ההשלכות הן בעיקר על משאבים והרשאות: עליכם להיות בעלי מספיק מקום בדיסק לקובץ הזמני וההרשאות ליצירת קבצים בתיקיית הקובץ המטרה שלכם.

למרות שפקודות עריכה במקום חזקות, יש להשתמש בהן בזהירות. regex מוטעה יכול להביא לאובדן נתונים, דבר המדגיש את חשיבות הגיבויים. למרות הפיתוחים הפוטנציאליים, שליטה בפקודות הללו יכולה לשפר משמעותית את היכולת שלכם לבצע שינויים מהירים ויעילים בקבצים ישירות משורת הפקודה, מתוך חיזוק פילוסופיית Unix של השתמשות בכלים פשוטים אך חזקים להשגת משימות מורכבות.
