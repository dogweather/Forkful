---
title:                "מציאת אורך של מחרוזת"
date:                  2024-02-03T17:57:49.662691-07:00
model:                 gpt-4-0125-preview
simple_title:         "מציאת אורך של מחרוזת"
tag:                  "Strings"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/he/go/finding-the-length-of-a-string.md"
changelog:
  - 2024-02-03, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## מה ולמה?
מציאת אורך של מחרוזת ב-Go היא עניין של קביעת מספר התווים שהיא מכילה. מתכנתים בוצעים את הפעולה הזו שוטף כדי להתמנות ביעילות עם מחרוזות, אם זה לצורך אימות, חילוץ תת-מחרוזות, או פשוט כדי לאכוף מגבלות בקלטי משתמש.

## איך לעשות:
ב-Go, מחרוזות נטפלות כסדרות בתים אי-שינויים. ניתן למצוא את אורך המחרוזת באמצעות הפונקציה הפנימית `len()`, אשר מחזירה את מספר הבתים, ולא בהכרח את מספר התווים. כך משתמשים בה:

```go
package main

import (
	"fmt"
	"unicode/utf8"
)

func main() {
	// שימוש ב-len() כדי למצוא את אורך הבתים
	str := "Hello, 世界"
	byteLength := len(str)
	fmt.Println("אורך בתים:", byteLength) // פלט: אורך בתים: 13

	// כדי לקבל בדיוק את מספר התווים או הרונים במחרוזת
	runeLength := utf8.RuneCountInString(str)
	fmt.Println("אורך רונים:", runeLength) // פלט: אורך רונים: 9
}
```
השיטה הראשונה באמצעות `len()` עלולה לא לתת תמיד את התוצאה הצפויה מאחר שהיא סופרת בתים. למחרוזות שמכילות תווים שאינם ASCII (כמו "世界"), יש להשתמש ב-`RuneCountInString` מהחבילה `unicode/utf8` במקום, כדי לספור נקודות קוד Unicode בדיוק.

## חקירה עמוקה
לפני Go 1, לא היה גבול ברור לטיפול במחרוזות כסדרות בתים לעומת סדרות תווים. לאחר Go 1, האימוץ של UTF-8 כסכימת הקידוד התקנית למחרוזות דרש גישות ברורות יותר. הפונקציה `len()` עובדת באופן מושלם עבור מחרוזות ASCII, שם התווים מיוצגים בבית בודד. עם זאת, ככל שיישומי Go הפכו גלובליים יותר, והצורך לתמוך במגוון שפות וערכות תווים גדל, הגישה הפשטנית של `len()` הציגה מגבלות.

ההצגה והשימוש ב-`utf8.RuneCountInString()` מגיבים למגבלות אלו על ידי הצגת דרך לספור תווי Unicode אמיתיים (רונים במונחי Go). שיטה זו מבטיחה שחישוב האורך אינו תלוי בפרטי הקידוד של UTF-8, שבו תווים עשויים להתפרש על פני מספר בתים.

גישה חלופית לטיול ועיבוד מחרוזות, שנושאת את דגל הסינכרון והיעילות של Go, עשויה להעדיף טיפול במחרוזות כחתיכות של רונים. עם זאת, שיטה זו דורשת שלב המרה ולא פותרת באופן מיידי את כל המורכבויות של Unicode (לדוגמה, תווים משלימים).

לסיכום, בעוד ש-`len()` מתאימה לאורך בבתים ויעילה עבור טקסט ASCII, `utf8.RuneCountInString()` היא בחירה יותר אמינה עבור יישום גלובלי תואם. עם זאת, מפתחים מוזמנים להבין את הפשרות בביצועים ובשימוש בזיכרון שהבחירות הללו מערבות.
