---
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 18:14:54.175960-07:00
description: "\u05E2\u05D1\u05D5\u05D3\u05D4 \u05E2\u05DD \u05DE\u05E1\u05E4\u05E8\
  \u05D9\u05DD \u05DE\u05E8\u05D5\u05DB\u05D1\u05D9\u05DD \u05D1\u05EA\u05DB\u05E0\
  \u05D5\u05EA \u05DB\u05D5\u05DC\u05DC\u05EA \u05D8\u05D9\u05E4\u05D5\u05DC \u05D1\
  \u05DE\u05E1\u05E4\u05E8\u05D9\u05DD \u05E9\u05D9\u05E9 \u05DC\u05D4\u05DD \u05D7\
  \u05DC\u05E7 \u05DE\u05DE\u05E9\u05D9 \u05D5\u05D7\u05DC\u05E7 \u05DE\u05D3\u05D5\
  \u05DE\u05D4, \u05E9\u05D1\u05D3\u05E8\u05DA \u05DB\u05DC\u05DC \u05DE\u05D1\u05D5\
  \u05D8\u05D0\u05D9\u05DD \u05DB- `a + bi`. \u05DE\u05EA\u05DB\u05E0\u05EA\u05D9\u05DD\
  \ \u05DE\u05EA\u05DE\u05D5\u05D3\u05D3\u05D9\u05DD \u05E2\u05DD \u05DE\u05E1\u05E4\
  \u05E8\u05D9\u05DD \u05DE\u05E8\u05D5\u05DB\u05D1\u05D9\u05DD \u05D1\u05EA\u05D7\
  \u05D5\u05DE\u05D9\u05DD\u2026"
lastmod: '2024-03-13T22:44:38.479396-06:00'
model: gpt-4-0125-preview
summary: "\u05E2\u05D1\u05D5\u05D3\u05D4 \u05E2\u05DD \u05DE\u05E1\u05E4\u05E8\u05D9\
  \u05DD \u05DE\u05E8\u05D5\u05DB\u05D1\u05D9\u05DD \u05D1\u05EA\u05DB\u05E0\u05D5\
  \u05EA \u05DB\u05D5\u05DC\u05DC\u05EA \u05D8\u05D9\u05E4\u05D5\u05DC \u05D1\u05DE\
  \u05E1\u05E4\u05E8\u05D9\u05DD \u05E9\u05D9\u05E9 \u05DC\u05D4\u05DD \u05D7\u05DC\
  \u05E7 \u05DE\u05DE\u05E9\u05D9 \u05D5\u05D7\u05DC\u05E7 \u05DE\u05D3\u05D5\u05DE\
  \u05D4, \u05E9\u05D1\u05D3\u05E8\u05DA \u05DB\u05DC\u05DC \u05DE\u05D1\u05D5\u05D8\
  \u05D0\u05D9\u05DD \u05DB- `a + bi`."
title: "\u05E2\u05D1\u05D5\u05D3\u05D4 \u05E2\u05DD \u05DE\u05E1\u05E4\u05E8\u05D9\
  \u05DD \u05DE\u05E8\u05D5\u05DB\u05D1\u05D9\u05DD"
weight: 14
---

## איך:
ב-Go, מספרים מרוכבים מטופלים באמצעות הפונקציות המובנות `complex`, `real`, ו-`imag`, יחד עם טיפוסי `complex64` ו-`complex128` (שמייצגים מספרים מרוכבים של 64 ביט ו-128 ביט בהתאמה). הנה מדריך מהיר להתחלה:

```go
package main

import (
	"fmt"
)

func main() {
	// יצירת מספרים מרוכבים
	a := complex(2, 3) // 2+3i
	b := complex(1, -1) // 1-1i

	// פעולות חשבוניות
	c := a + b
	fmt.Println("חיבור:", c) // פלט: חיבור: (3+2i)

	d := a * b
	fmt.Println("כפל:", d) // פלט: כפל: (5+1i)

	// גישה לחלקים הממשי והמדומה
	realPart := real(a)
	imagPart := imag(a)
	fmt.Printf("חלק ממשי: %.1f, חלק מדומה: %.1f\n", realPart, imagPart) // פלט: חלק ממשי: 2.0, חלק מדומה: 3.0

	// ניתן לחשב שוזר מרוכב וגודל
	conjugate := complex(real(a), -imag(a)) // באופן ידני
	fmt.Println("שוזר של a:", conjugate) // פלט: שוזר של a: (2-3i)
}
```

דוגמא זו מכסה את הבסיסים, אך יש הרבה יותר שניתן לעשות עם מספרים מרוכבים, כולל ה利用 של החבילה `math/cmplx` לפעולות מתקדמות יותר כמו מציאת הגודל, השלב ועוד הרבה.

## עיון מעמיק
הרעיון של מספרים מרוכבים חוזר למאה ה-16, אך רק קיבל הכרה רחבה ופורמליזציה מחמירה במאה ה-19. בתכנות מחשבים, מספרים מרוכבים היוו תמיד בסיס לחישוב אריתמטי מורכב בחישובים מדעיים והנדסיים מהימים הראשונים. הגישה של Go למספרים מרוכבים, על ידי הפיכתם למציאות ראשונית עם תמיכה מובנת ותמיכה מקיפה של ספריית התקן דרך החבילה `math/cmplx`, מצטיינת בין שפות התכנות. החלטת העיצוב הזו משקפת את דגש Go על פשטות וביצועים.

עם זאת, שווה לציין שעבודה עם מספרים מרוכבים ב-Go, למרות שהיא עוצמתית, לא תמיד תהיה הגישה הטובה ביותר לכל היישומים, במיוחד אלה שדורשים מתמטיקה סימבולית או חשבון בדיוק גבוה. שפות וסביבות המתמחות בחישוב מדעי, כמו Python עם ספריות כמו NumPy ו-SciPy, או תוכנות כמו MATLAB, עשויות להציע גמישות רבה יותר וטווח רחב יותר של פונקציונליות ליישומים מסוימים.

עם זאת, לתכנות מערכות ובהקשרים שבהם אינטגרציה של חישובי מספרים מרוכבים לתוך יישום גדול יותר, רגיש לביצועים, היא קריטית, תמיכת Go המקורית במספרים מרוכבים מספקת אופציה יעילה במיוחד.
