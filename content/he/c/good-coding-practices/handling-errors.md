---
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 17:59:04.045204-07:00
description: "\u05D8\u05D9\u05E4\u05D5\u05DC \u05D1\u05E9\u05D2\u05D9\u05D0\u05D5\u05EA\
  \ \u05D1\u05E9\u05E4\u05EA C \u05DE\u05E9\u05DE\u05E2\u05D5\u05EA\u05D5 \u05D0\u05D9\
  \u05EA\u05D5\u05E8 \u05D5\u05D4\u05EA\u05DE\u05D5\u05D3\u05D3\u05D5\u05EA \u05E2\
  \u05DD \u05EA\u05E0\u05D0\u05D9\u05DD \u05D7\u05E8\u05D9\u05D2\u05D9\u05DD \u05D4\
  \u05DE\u05EA\u05E2\u05D5\u05E8\u05E8\u05D9\u05DD \u05D1\u05DE\u05D4\u05DC\u05DA\
  \ \u05D1\u05D9\u05E6\u05D5\u05E2 \u05D4\u05EA\u05D5\u05DB\u05E0\u05D9\u05EA. \u05DE\
  \u05EA\u05DB\u05E0\u05EA\u05D9\u05DD \u05E2\u05D5\u05E9\u05D9\u05DD \u05D6\u05D0\
  \u05EA \u05DB\u05D3\u05D9 \u05DC\u05DE\u05E0\u05D5\u05E2 \u05EA\u05E7\u05DC\u05D5\
  \u05EA, \u05E7\u05E8\u05D9\u05E1\u05D5\u05EA, \u05D5\u05D4\u05EA\u05E0\u05D4\u05D2\
  \u05D5\u05EA \u05D1\u05DC\u05EA\u05D9\u2026"
lastmod: '2024-03-13T22:44:40.140062-06:00'
model: gpt-4-0125-preview
summary: "\u05D8\u05D9\u05E4\u05D5\u05DC \u05D1\u05E9\u05D2\u05D9\u05D0\u05D5\u05EA\
  \ \u05D1\u05E9\u05E4\u05EA C \u05DE\u05E9\u05DE\u05E2\u05D5\u05EA\u05D5 \u05D0\u05D9\
  \u05EA\u05D5\u05E8 \u05D5\u05D4\u05EA\u05DE\u05D5\u05D3\u05D3\u05D5\u05EA \u05E2\
  \u05DD \u05EA\u05E0\u05D0\u05D9\u05DD \u05D7\u05E8\u05D9\u05D2\u05D9\u05DD \u05D4\
  \u05DE\u05EA\u05E2\u05D5\u05E8\u05E8\u05D9\u05DD \u05D1\u05DE\u05D4\u05DC\u05DA\
  \ \u05D1\u05D9\u05E6\u05D5\u05E2 \u05D4\u05EA\u05D5\u05DB\u05E0\u05D9\u05EA."
title: "\u05D8\u05D9\u05E4\u05D5\u05DC \u05D1\u05E9\u05D2\u05D9\u05D0\u05D5\u05EA"
weight: 16
---

## איך לעשות זאת:
ב-C אין תמיכה מובנית לחריגים כמו בחלק מהשפות האחרות. במקום זאת, היא מתבססת על מספר אסטרטגיות קונבנציונליות לטיפול בשגיאות, כמו החזרת ערכים מיוחדים מפונקציות והגדרת משתנים גלובליים כמו `errno`.

**החזרת ערכים מיוחדים**

פונקציות יכולות לציין שגיאות על ידי החזרת ערך מסוים שלא סביר שיהיה תוצאה חוקית. הנה דוגמא עם מספרים שלמים:

```c
#include <stdio.h>

int inverse(int number, double *result) {
    if (number == 0) {
        return -1; // מקרה שגיאה
    } else {
        *result = 1.0 / number;
        return 0; // הצלחה
    }
}

int main() {
    double result;
    if (inverse(0, &result) < 0) {
        printf("Error: Division by zero.\n");
    } else {
        printf("The inverse is: %f\n", result);
    }
    
    return 0;
}
```

**פלט:**
```
Error: Division by zero.
```

**בדיקת `errno`**

עבור פונקציות ספרייה, בפרט אלו המתקשרות עם המערכת או המערכת ההפעלה (כמו קלט/פלט של קבצים), `errno` מוגדרת כאשר מתרחשת שגיאה. כדי להשתמש בה, יש לכלול את `errno.h` ולבדוק את `errno` לאחר כשל חשוד:

```c
#include <stdio.h>
#include <errno.h>
#include <string.h>

int main() {
    FILE *file = fopen("nonexistent.txt", "r");
    if (file == NULL) {
        printf("Error opening file: %s\n", strerror(errno));
    }
    
    return 0;
}
```

**פלט:**
```
Error opening file: No such file or directory
```

## עיון נוסף
מסורתית, עיצובה המינימליסטי של שפת התכנות C לא כלל מנגנון טיפול בחריגים מובנה, משקף את מקורותיה בתכנות מערכות ברמה נמוכה שבה ביצוע ושליטה קרובה לחומרה הן קריטיות. במקום זאת, C מאמצת גישה יותר ידנית לטיפול בשגיאות התואמת את פילוסופיתה של הענקת שליטה מקסימלית למתכנתים, גם על חשבון הנוחות.

למרות שגישה זו מתיישבת היטב עם מטרות העיצוב של C, היא יכולה גם להוביל לקוד בדיקת שגיאות מרובה ולפספוסים אפשריים של בדיקות שגיאה, דבר ששפות מודרניות פותרות עם מנגנונים מובנים לטיפול בחריגים. לדוגמה, חריגים בשפות כמו Java או C# מאפשרים עיבוד מרכזי של שגיאות, דבר ההופך את הקוד לנקי יותר ואת ניהול השגיאות לפשוט יותר. עם זאת, חריגים מצריכים גם הם עלות ומורכבות משלהם, שעשויות לא להיות אידיאליות לתכנות ברמה של מערכת שבה C מצטיינת.

למרות החפיפות שלה, גישת הטיפול הידנית בשגיאות ב-C השפיעה על עיצוב ניהול השגיאות בשפות רבות אחרות, מציעה מודל שבו המפורשות של תנאי השגיאה יכולה להוביל לקוד יותר ניתן לניבוי ולניפוי. עבור מערכות קריטיות, שבהן יש לנהל תקלות באופן חסידותי, פרדיגמת טיפול השגיאות של C - בשילוב עם מיטב המתודולוגיות המודרניות כמו ספריות טיפול בשגיאות וקונבנציות - מבטיחות עמידות ואמינות.
