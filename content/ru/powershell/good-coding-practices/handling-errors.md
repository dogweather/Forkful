---
changelog:
- 2024-01-28, gpt-4-0125-preview, translated from English
date: 2024-01-28 23:58:48.403760-07:00
description: "\u041E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u043E\u0448\u0438\
  \u0431\u043E\u043A \u0432 PowerShell \u043E\u0437\u043D\u0430\u0447\u0430\u0435\u0442\
  \ \u043F\u0440\u0435\u0434\u0441\u043A\u0430\u0437\u0430\u043D\u0438\u0435 \u043D\
  \u0435\u0443\u0434\u0430\u0447 \u0438 \u0443\u043F\u0440\u0430\u0432\u043B\u0435\
  \u043D\u0438\u0435 \u0438\u043C\u0438 \u0433\u043B\u0430\u0434\u043A\u043E. \u041F\
  \u0440\u043E\u0433\u0440\u0430\u043C\u043C\u0438\u0441\u0442\u044B \u0434\u0435\u043B\
  \u0430\u044E\u0442 \u044D\u0442\u043E, \u0447\u0442\u043E\u0431\u044B \u043F\u0440\
  \u0435\u0434\u043E\u0442\u0432\u0440\u0430\u0442\u0438\u0442\u044C \u0441\u0431\u043E\
  \u0438 \u0438 \u043F\u0440\u0435\u0434\u043E\u0441\u0442\u0430\u0432\u0438\u0442\
  \u044C\u2026"
lastmod: '2024-03-13T22:44:45.465539-06:00'
model: gpt-4-0125-preview
summary: "\u041E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u043E\u0448\u0438\
  \u0431\u043E\u043A \u0432 PowerShell \u043E\u0437\u043D\u0430\u0447\u0430\u0435\u0442\
  \ \u043F\u0440\u0435\u0434\u0441\u043A\u0430\u0437\u0430\u043D\u0438\u0435 \u043D\
  \u0435\u0443\u0434\u0430\u0447 \u0438 \u0443\u043F\u0440\u0430\u0432\u043B\u0435\
  \u043D\u0438\u0435 \u0438\u043C\u0438 \u0433\u043B\u0430\u0434\u043A\u043E."
title: "\u041E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u043E\u0448\u0438\u0431\
  \u043E\u043A"
weight: 16
---

## Как это сделать:
```PowerShell
# Базовый Try-Catch для обработки исключений
try {
    # Код, который может вызвать ошибку
    $result = 1 / 0
} catch {
    # Что делать, если произошла ошибка
    Write-Host "Ой, произошла ошибка: $_"
}

# Вывод специального сообщения об ошибке
try {
    Get-Item "nonexistentfile.txt" -ErrorAction Stop
} catch {
    Write-Host "Файл не найден."
}

# Использование переменной $Error для проверки последней ошибки
```

## Подробное погружение
PowerShell прошел долгий путь с момента своего создания как Monad. Обработка ошибок стала более надежной со временем, предлагая функции, похожие на функции других языков программирования. Синтаксис `try-catch-finally` - это одна из таких кросс-заимствований из языков, подобных C#. До его появления скрипт-программисты в значительной мере полагались на проверку условий и использование автоматической переменной `$Error`.

В PowerShell также существуют два основных типа ошибок: завершающие и не завершающие. Завершающие ошибки остановят скрипт, если только они не пойманы в блоке `try-catch`, в то время как не завершающие не остановят, если только вы не укажете `-ErrorAction Stop`. Это различие критично, поскольку оно предоставляет тонкий контроль над обработкой ошибок, позволяя решать, стоит ли ошибка действительно остановки всего скрипта или ее можно просто зарегистрировать и игнорировать.

Обработка ошибок в PowerShell позволяет использовать блок `finally`, который выполняется в любом случае - независимо от того, произошла ошибка или нет. Это отлично подходит для задач очистки.

Когда вы глубоко погружены в написание скриптов, вы также можете обрабатывать конкретные типы исключений, что дает вам еще более тонкий контроль.

В качестве альтернативы, есть старый добрый параметр `-ErrorVariable` для захвата ошибок без генерации исключения. И переменная `$?` говорит вам, была ли последняя операция успешной. Это удобные инструменты, хотя и немного менее чистые, чем надежный `try-catch`.

## См. также
- [about_Try_Catch_Finally](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_try_catch_finally?view=powershell-7.2)
