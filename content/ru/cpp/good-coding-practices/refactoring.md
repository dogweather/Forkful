---
changelog:
- 2024-01-29, gpt-4-0125-preview, translated from English
date: 2024-01-29 00:01:51.601844-07:00
description: "\u0420\u0435\u0444\u0430\u043A\u0442\u043E\u0440\u0438\u043D\u0433 \u2014\
  \ \u044D\u0442\u043E \u043F\u0440\u043E\u0446\u0435\u0441\u0441 \u0438\u0437\u043C\
  \u0435\u043D\u0435\u043D\u0438\u044F \u0432\u043D\u0443\u0442\u0440\u0435\u043D\u043D\
  \u0435\u0439 \u0441\u0442\u0440\u0443\u043A\u0442\u0443\u0440\u044B \u043A\u043E\
  \u043C\u043F\u044C\u044E\u0442\u0435\u0440\u043D\u043E\u0439 \u043F\u0440\u043E\u0433\
  \u0440\u0430\u043C\u043C\u044B \u0431\u0435\u0437 \u0438\u0437\u043C\u0435\u043D\
  \u0435\u043D\u0438\u044F \u0435\u0435 \u0432\u043D\u0435\u0448\u043D\u0435\u0433\
  \u043E \u043F\u043E\u0432\u0435\u0434\u0435\u043D\u0438\u044F. \u041F\u0440\u043E\
  \u0433\u0440\u0430\u043C\u043C\u0438\u0441\u0442\u044B \u0434\u0435\u043B\u0430\u044E\
  \u0442 \u044D\u0442\u043E \u0434\u043B\u044F \u0442\u043E\u0433\u043E,\u2026"
lastmod: '2024-03-13T22:44:45.623147-06:00'
model: gpt-4-0125-preview
summary: "\u0420\u0435\u0444\u0430\u043A\u0442\u043E\u0440\u0438\u043D\u0433 \u2014\
  \ \u044D\u0442\u043E \u043F\u0440\u043E\u0446\u0435\u0441\u0441 \u0438\u0437\u043C\
  \u0435\u043D\u0435\u043D\u0438\u044F \u0432\u043D\u0443\u0442\u0440\u0435\u043D\u043D\
  \u0435\u0439 \u0441\u0442\u0440\u0443\u043A\u0442\u0443\u0440\u044B \u043A\u043E\
  \u043C\u043F\u044C\u044E\u0442\u0435\u0440\u043D\u043E\u0439 \u043F\u0440\u043E\u0433\
  \u0440\u0430\u043C\u043C\u044B \u0431\u0435\u0437 \u0438\u0437\u043C\u0435\u043D\
  \u0435\u043D\u0438\u044F \u0435\u0435 \u0432\u043D\u0435\u0448\u043D\u0435\u0433\
  \u043E \u043F\u043E\u0432\u0435\u0434\u0435\u043D\u0438\u044F."
title: "\u0420\u0435\u0444\u0430\u043A\u0442\u043E\u0440\u0438\u043D\u0433"
weight: 19
---

## Как это делать:
Представьте, что у вас есть функция, которая делает слишком много, как этот громоздкий метод, который инициализирует объект и также выполняет логирование:

```C++
#include <iostream>

class Widget {
public:
    void init(bool verbose) {
        // Логика инициализации
        // ...

        // Подробное логирование
        if (verbose) {
            std::cout << "Виджет инициализирован!" << std::endl;
        }
    }
};

// Использование:
Widget w;
w.init(true);
```

Вывод:
```
Виджет инициализирован!
```

Рефакторинг этого для более чистых, более сфокусированных методов может выглядеть так:

```C++
#include <iostream>

class Widget {
public:
    void init() {
        // Только логика инициализации
        // ...
    }

    void logInitialization() const {
        std::cout << "Виджет инициализирован!" << std::endl;
    }
};

// Использование:
Widget w;
w.init();
w.logInitialization();
```

Это изменение не изменило то, что делает программа, но сделало класс `Widget` более модульным, а его использование более понятным.

## Углубленное изучение
Концепция рефакторинга, как мы ее знаем сегодня, зародилась в сообществах программистов на Smalltalk в 1980-х годах и была широко популяризирована книгой Мартина Фаулера "Рефакторинг: Улучшение дизайна существующего кода" от 1999 года. Сегодня рефакторинг является ключевой частью современной разработки программного обеспечения, интегрированной в различные методологии разработки, такие как Agile и TDD (Разработка через тестирование).

Когда мы говорим об альтернативах рефакторингу, мы входим в область переписывания или перепроектирования. Рефакторинг является стратегическим и инкрементным, в то время как переписывание может отказаться от существующего кода в пользу нового решения. Перепроектирование, в свою очередь, может включать более значительные изменения, включая изменение функциональности, что не является целью для чистого рефакторинга.

Детали реализации рефакторинга могут быть очень детализированными. Существует множество "запахов кода", которые могут побудить к рефакторингу, такие как длинные методы, большие классы или дублированный код. Существуют автоматизированные инструменты, которые могут помочь в рефакторинге, например, "Clang-Tidy" для C++, который может обнаруживать проблемы и даже применять некоторые исправления.

Более того, для рефакторинга требуется надежный набор тестов, чтобы убедиться, что функциональность остается неизменной. Без тестов вы, по сути, летите вслепую и рискуете с регрессиями.

## См. также
Для более глубокого понимания рефакторинга и для просмотра большего количества примеров, вы можете обратить внимание на:

- Классический текст Мартина Фаулера "Рефакторинг: Улучшение дизайна существующего кода" для основополагающих идей и стратегий.
- Документацию `Clang-Tidy` на https://clang.llvm.org/extra/clang-tidy/ для поддержки автоматизированного рефакторинга в C++.
- "Эффективная работа с устаревшим кодом" Майкла Фезерса, который предоставляет техники для безопасного рефакторинга в контексте неидеальных существующих кодовых баз.
