---
aliases:
- /ru/cpp/using-associative-arrays/
changelog:
- 2024-01-30, gpt-4-0125-preview, translated from English
date: 2024-01-30 19:10:40.290041-07:00
description: "\u0410\u0441\u0441\u043E\u0446\u0438\u0430\u0442\u0438\u0432\u043D\u044B\
  \u0435 \u043C\u0430\u0441\u0441\u0438\u0432\u044B, \u0438\u0437\u0432\u0435\u0441\
  \u0442\u043D\u044B\u0435 \u0432 C++ \u043A\u0430\u043A `std::map` \u0438\u043B\u0438\
  \ `std::unordered_map`, \u0437\u0430\u043A\u0440\u044B\u0432\u0430\u044E\u0442 \u043F\
  \u0440\u043E\u0431\u0435\u043B \u043C\u0435\u0436\u0434\u0443 \u0438\u043D\u0434\
  \u0435\u043A\u0441\u0430\u043C\u0438 \u043C\u0430\u0441\u0441\u0438\u0432\u043E\u0432\
  \ \u0438 \u0434\u0430\u043D\u043D\u044B\u043C\u0438 \u0440\u0435\u0430\u043B\u044C\
  \u043D\u043E\u0433\u043E \u043C\u0438\u0440\u0430,\u2026"
lastmod: 2024-02-18 23:08:57.349404
model: gpt-4-0125-preview
summary: "\u0410\u0441\u0441\u043E\u0446\u0438\u0430\u0442\u0438\u0432\u043D\u044B\
  \u0435 \u043C\u0430\u0441\u0441\u0438\u0432\u044B, \u0438\u0437\u0432\u0435\u0441\
  \u0442\u043D\u044B\u0435 \u0432 C++ \u043A\u0430\u043A `std::map` \u0438\u043B\u0438\
  \ `std::unordered_map`, \u0437\u0430\u043A\u0440\u044B\u0432\u0430\u044E\u0442 \u043F\
  \u0440\u043E\u0431\u0435\u043B \u043C\u0435\u0436\u0434\u0443 \u0438\u043D\u0434\
  \u0435\u043A\u0441\u0430\u043C\u0438 \u043C\u0430\u0441\u0441\u0438\u0432\u043E\u0432\
  \ \u0438 \u0434\u0430\u043D\u043D\u044B\u043C\u0438 \u0440\u0435\u0430\u043B\u044C\
  \u043D\u043E\u0433\u043E \u043C\u0438\u0440\u0430,\u2026"
title: "\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u0435\
  \ \u0430\u0441\u0441\u043E\u0446\u0438\u0430\u0442\u0438\u0432\u043D\u044B\u0445\
  \ \u043C\u0430\u0441\u0441\u0438\u0432\u043E\u0432"
---

{{< edit_this_page >}}

## Что и зачем?

Ассоциативные массивы, известные в C++ как `std::map` или `std::unordered_map`, закрывают пробел между индексами массивов и данными реального мира, позволяя использовать значимые ключи. Они являются предпочтительным выбором, когда требуется быстрый поиск, вставка и удаление, используя ключи, а не позиции индексов.

## Как использовать:

В C++, ассоциативные массивы оживают с помощью заголовков `<map>` и `<unordered_map>`. Давайте рассмотрим примеры, чтобы увидеть их в действии.

### Использование `std::map`

`std::map` хранит элементы, отсортированные на основе ключа. Вот как начать:

```C++
#include <iostream>
#include <map>
#include <string>

int main() {
    std::map<std::string, int> ageMap;
    
    // Вставка значений
    ageMap["Alice"] = 30;
    ageMap["Bob"] = 25;
    
    // Доступ к значениям
    std::cout << "Возраст Боба: " << ageMap["Bob"] << std::endl;
    
    // Перебор map
    for(const auto &pair : ageMap) {
        std::cout << pair.first << " имеет возраст " << pair.second << " лет." << std::endl;
    }
    
    return 0;
}
```

### Использование `std::unordered_map`

Когда порядок не имеет значения, но важна производительность, `std::unordered_map` ваш выбор, предлагая более быструю среднюю сложность для вставок, поиска и удалений.

```C++
#include <iostream>
#include <unordered_map>
#include <string>

int main() {
    std::unordered_map<std::string, double> productPrice;
    
    // Вставка значений
    productPrice["milk"] = 2.99;
    productPrice["bread"] = 1.99;
    
    // Доступ к значениям
    std::cout << "Цена молока: $" << productPrice["milk"] << std::endl;
    
    // Перебор unordered_map
    for(const auto &pair : productPrice) {
        std::cout << pair.first << " стоит $" << pair.second << std::endl;
    }
    
    return 0;
}
```

## Глубокое погружение

Ассоциативные массивы в C++, особенно `std::map` и `std::unordered_map`, не просто о хранении элементов. Они обеспечивают основу для более сложного управления данными, позволяя осуществлять операции поиска, вставки и удаления за эффективное время (логарифмическая сложность для `std::map` и константа в среднем случае для `std::unordered_map`). Эффективность обусловлена используемыми внутренними структурами данных: сбалансированным деревом для `std::map` и хеш-таблицей для `std::unordered_map`.

Исторически, до их включения в стандартную библиотеку, программисты должны были реализовывать собственные версии или использовать сторонние библиотеки, что приводило к несоответствиям и потенциальным неэффективностям. Включение карт в стандартную библиотеку C++ не только стандартизировало их использование, но и оптимизировало для повышения производительности на разных компиляторах и платформах.

Хотя оба варианта мощные, выбор между `std::map` и `std::unordered_map` зависит от конкретики вашего случая. Нужны упорядоченные данные и небольшая потеря производительности не критична? Используйте `std::map`. Если вам важна скорость и порядок не важен, `std::unordered_map` вероятно будет лучшим выбором.

Однако важно отметить, что при работе со сложными структурами данных всегда есть компромиссы. В некоторых узкоспециализированных случаях другие структуры данных или даже сторонние библиотеки могут предложить лучшую производительность или функциональность, подходящую для ваших конкретных потребностей. Всегда взвешивайте свои варианты на основе требований вашего проекта.
