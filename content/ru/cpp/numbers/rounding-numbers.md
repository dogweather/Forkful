---
changelog:
- 2024-01-29, gpt-4-0125-preview, translated from English
date: 2024-01-29 00:03:08.472238-07:00
description: "\u041E\u043A\u0440\u0443\u0433\u043B\u0435\u043D\u0438\u0435 \u0447\u0438\
  \u0441\u0435\u043B \u043E\u0437\u043D\u0430\u0447\u0430\u0435\u0442 \u043A\u043E\
  \u0440\u0440\u0435\u043A\u0442\u0438\u0440\u043E\u0432\u043A\u0443 \u0437\u043D\u0430\
  \u0447\u0435\u043D\u0438\u044F \u0434\u043E \u0431\u043B\u0438\u0436\u0430\u0439\
  \u0448\u0435\u0433\u043E \u0446\u0435\u043B\u043E\u0433\u043E \u0438\u043B\u0438\
  \ \u0437\u0430\u0434\u0430\u043D\u043D\u043E\u0439 \u0442\u043E\u0447\u043D\u043E\
  \u0441\u0442\u0438. \u0420\u0430\u0437\u0440\u0430\u0431\u043E\u0442\u0447\u0438\
  \u043A\u0438 \u0434\u0435\u043B\u0430\u044E\u0442 \u044D\u0442\u043E \u0447\u0442\
  \u043E\u0431\u044B \u0443\u043F\u0440\u043E\u0441\u0442\u0438\u0442\u044C, \u0441\
  \u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C\
  \u2026"
lastmod: '2024-03-13T22:44:45.598730-06:00'
model: gpt-4-0125-preview
summary: "\u041E\u043A\u0440\u0443\u0433\u043B\u0435\u043D\u0438\u0435 \u0447\u0438\
  \u0441\u0435\u043B \u043E\u0437\u043D\u0430\u0447\u0430\u0435\u0442 \u043A\u043E\
  \u0440\u0440\u0435\u043A\u0442\u0438\u0440\u043E\u0432\u043A\u0443 \u0437\u043D\u0430\
  \u0447\u0435\u043D\u0438\u044F \u0434\u043E \u0431\u043B\u0438\u0436\u0430\u0439\
  \u0448\u0435\u0433\u043E \u0446\u0435\u043B\u043E\u0433\u043E \u0438\u043B\u0438\
  \ \u0437\u0430\u0434\u0430\u043D\u043D\u043E\u0439 \u0442\u043E\u0447\u043D\u043E\
  \u0441\u0442\u0438."
title: "\u041E\u043A\u0440\u0443\u0433\u043B\u0435\u043D\u0438\u0435 \u0447\u0438\u0441\
  \u0435\u043B"
weight: 13
---

## Как это сделать:
C++ предлагает несколько способов округления чисел, таких как `floor()`, `ceil()` и `round()`:

```C++
#include <iostream>
#include <cmath> // для функций округления

int main() {
    double num = 3.14;

    std::cout << "floor: " << std::floor(num) << "\n"; // Вывод: floor: 3
    std::cout << "ceil: " << std::ceil(num) << "\n";   // Вывод: ceil: 4
    std::cout << "round: " << std::round(num) << "\n"; // Вывод: round: 3

    // Для фиксированной точности, например, округление до двух знаков после запятой:
    double precise_num = 3.146;
    double multiplier = 100.0;
    double rounded = std::round(precise_num * multiplier) / multiplier;

    std::cout << "округлено до двух знаков после запятой: " << rounded << "\n"; // Вывод: округлено до двух знаков после запятой: 3.15

    return 0;
}
```

## Погружение в тему
До C++11 округление осуществлялось с помощью ручных методик или нестандартных библиотек. Сегодня `<cmath>` предоставляет надежные методы. `floor()` округляет вниз, `ceil()` округляет вверх, в то время как `round()` округляет до ближайшего целого числа, обрабатывая даже случаи срединного округления (случаи 0.5) путем округления до четного числа.

Понимание поведения этих функций крайне важно; например, отрицательные числа могут стать камнем преткновения (`std::round(-2.5)` дает `-2.0`).

Альтернативы? Приведение к типу int после добавления 0.5 для положительных чисел было классическим трюком, но ошибается с отрицательными и не является агностично типовым. Библиотеки типа Boost могут предложить более тонкие подходы, в то время как расширения языка или внутренние функции компилятора могут быть оптимизированы для конкретного оборудования.

## Смотрите также
- Справочник по C++ для `<cmath>`: https://en.cppreference.com/w/cpp/header/cmath
- Стандарт IEEE для арифметики с плавающей запятой (IEEE 754): https://ieeexplore.ieee.org/document/4610935
- Библиотека числовых преобразований Boost: https://www.boost.org/doc/libs/release/libs/numeric/conversion/
