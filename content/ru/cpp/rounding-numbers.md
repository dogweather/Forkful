---
title:                "Округление чисел"
aliases:
- ru/cpp/rounding-numbers.md
date:                  2024-01-29T00:03:08.472238-07:00
model:                 gpt-4-0125-preview
simple_title:         "Округление чисел"

tag:                  "Numbers"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/ru/cpp/rounding-numbers.md"
changelog:
  - 2024-01-29, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## Что и Почему?
Округление чисел означает корректировку значения до ближайшего целого или заданной точности. Разработчики делают это чтобы упростить, соответствовать ограничениям реального мира или улучшить производительность за счет отказа от излишней точности.

## Как это сделать:
C++ предлагает несколько способов округления чисел, таких как `floor()`, `ceil()` и `round()`:

```C++
#include <iostream>
#include <cmath> // для функций округления

int main() {
    double num = 3.14;

    std::cout << "floor: " << std::floor(num) << "\n"; // Вывод: floor: 3
    std::cout << "ceil: " << std::ceil(num) << "\n";   // Вывод: ceil: 4
    std::cout << "round: " << std::round(num) << "\n"; // Вывод: round: 3

    // Для фиксированной точности, например, округление до двух знаков после запятой:
    double precise_num = 3.146;
    double multiplier = 100.0;
    double rounded = std::round(precise_num * multiplier) / multiplier;

    std::cout << "округлено до двух знаков после запятой: " << rounded << "\n"; // Вывод: округлено до двух знаков после запятой: 3.15

    return 0;
}
```

## Погружение в тему
До C++11 округление осуществлялось с помощью ручных методик или нестандартных библиотек. Сегодня `<cmath>` предоставляет надежные методы. `floor()` округляет вниз, `ceil()` округляет вверх, в то время как `round()` округляет до ближайшего целого числа, обрабатывая даже случаи срединного округления (случаи 0.5) путем округления до четного числа.

Понимание поведения этих функций крайне важно; например, отрицательные числа могут стать камнем преткновения (`std::round(-2.5)` дает `-2.0`).

Альтернативы? Приведение к типу int после добавления 0.5 для положительных чисел было классическим трюком, но ошибается с отрицательными и не является агностично типовым. Библиотеки типа Boost могут предложить более тонкие подходы, в то время как расширения языка или внутренние функции компилятора могут быть оптимизированы для конкретного оборудования.

## Смотрите также
- Справочник по C++ для `<cmath>`: https://en.cppreference.com/w/cpp/header/cmath
- Стандарт IEEE для арифметики с плавающей запятой (IEEE 754): https://ieeexplore.ieee.org/document/4610935
- Библиотека числовых преобразований Boost: https://www.boost.org/doc/libs/release/libs/numeric/conversion/
