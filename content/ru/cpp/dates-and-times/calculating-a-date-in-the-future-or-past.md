---
title:                "Расчет даты в будущем или прошлом"
aliases:
- /ru/cpp/calculating-a-date-in-the-future-or-past/
date:                  2024-01-28T23:55:55.535962-07:00
model:                 gpt-4-0125-preview
simple_title:         "Расчет даты в будущем или прошлом"

tag:                  "Dates and Times"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/ru/cpp/calculating-a-date-in-the-future-or-past.md"
changelog:
  - 2024-01-28, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## Что и почему?
Расчёт даты в будущем или прошлом означает выяснение, каким будет день через определённый промежуток времени или до него. Это полезно для создания напоминаний, установления сроков годности, планирования событий или просто для записи, сколько времени прошло.

## Как это сделать:
C++20 представил обновления библиотеки `<chrono>`, так что работа с временем стала менее обременительной. Вот быстрый пример добавления дней к текущей дате:

```C++
#include <iostream>
#include <chrono>
#include <format>

using namespace std::chrono;

int main() {
    // Получить сегодняшнюю дату
    auto today = floor<days>(system_clock::now());
    
    // Добавить к сегодняшней дате 30 дней
    auto future_date = today + days(30);
    
    // Преобразовать в time_point для вывода с использованием system_clock
    auto tp = system_clock::time_point(future_date);
    
    // Вывод
    std::cout << "Сегодняшняя дата: "
              << std::format("{:%F}\n", today);
    std::cout << "Будущая дата (через 30 дней): "
              << std::format("{:%F}\n", tp);
    return 0;
}
```

Пример вывода:
```
Сегодняшняя дата: 2023-03-15
Будущая дата (через 30 дней): 2023-04-14
```

Вычитание дней работает аналогично - нужно использовать `-` вместо `+`.

## Подробнее
До C++20 возможно, вы бы использовали библиотеку, такую как Boost, для манипуляции с датами. Но обновлённый `<chrono>` упрощает это с помощью `system_clock`, `year_month_day` и типов `duration`.

Исторически, расчёт дат был сложным из-за ручного управления разной длительностью месяцев, високосными годами и часовыми поясами. `<chrono>` в C++20 решает эти проблемы, предоставляя поддержку календаря и часовых поясов.

Альтернативы? Вы всё ещё можете использовать Boost или даже создавать свою собственную логику работы с датами (авантюрно, но зачем?). Также есть сторонние библиотеки, такие как библиотека "date" Говарда Хиннанта, которая оказала влияние на обновления chrono в C++20.

С точки зрения реализации, `<chrono>` определяет длительности как константы времени компиляции в рациональных числах, избегая проблем с плавающей точкой. Типы, такие как `year_month_day`, основаны на `sys_days`, который представляет собой `time_point` в виде дней с общей эпохи (1970-01-01).

## Смотрите также
- Справочник по `chrono` в C++: https://en.cppreference.com/w/cpp/header/chrono
- Библиотека Date Говарда Хиннанта (предшественник обновлений chrono в C++20): https://github.com/HowardHinnant/date
- Документация по Boost Date/Time: https://www.boost.org/doc/libs/release/libs/date_time/
