---
changelog:
- 2024-01-29, gpt-4-0125-preview, translated from English
date: 2024-01-29 00:02:29.638828-07:00
description: "\u0420\u0435\u0444\u0430\u043A\u0442\u043E\u0440\u0438\u043D\u0433 -\
  \ \u044D\u0442\u043E \u043F\u0440\u043E\u0446\u0435\u0441\u0441 \u043C\u043E\u0434\
  \u0438\u0444\u0438\u043A\u0430\u0446\u0438\u0438 \u0441\u0443\u0449\u0435\u0441\u0442\
  \u0432\u0443\u044E\u0449\u0435\u0433\u043E \u043A\u043E\u0434\u0430 \u0434\u043B\
  \u044F \u0443\u043B\u0443\u0447\u0448\u0435\u043D\u0438\u044F \u0435\u0433\u043E\
  \ \u0441\u0442\u0440\u0443\u043A\u0442\u0443\u0440\u044B, \u0447\u0438\u0442\u0430\
  \u0435\u043C\u043E\u0441\u0442\u0438 \u0438 \u043F\u0440\u043E\u0438\u0437\u0432\
  \u043E\u0434\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u0438 \u0431\u0435\
  \u0437 \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u044F \u0435\u0433\u043E\
  \ \u0432\u043D\u0435\u0448\u043D\u0435\u0433\u043E\u2026"
lastmod: '2024-03-13T22:44:44.994481-06:00'
model: gpt-4-0125-preview
summary: "\u0420\u0435\u0444\u0430\u043A\u0442\u043E\u0440\u0438\u043D\u0433 - \u044D\
  \u0442\u043E \u043F\u0440\u043E\u0446\u0435\u0441\u0441 \u043C\u043E\u0434\u0438\
  \u0444\u0438\u043A\u0430\u0446\u0438\u0438 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\
  \u0443\u044E\u0449\u0435\u0433\u043E \u043A\u043E\u0434\u0430 \u0434\u043B\u044F\
  \ \u0443\u043B\u0443\u0447\u0448\u0435\u043D\u0438\u044F \u0435\u0433\u043E \u0441\
  \u0442\u0440\u0443\u043A\u0442\u0443\u0440\u044B, \u0447\u0438\u0442\u0430\u0435\
  \u043C\u043E\u0441\u0442\u0438 \u0438 \u043F\u0440\u043E\u0438\u0437\u0432\u043E\
  \u0434\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u0438 \u0431\u0435\u0437\
  \ \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u044F \u0435\u0433\u043E \u0432\
  \u043D\u0435\u0448\u043D\u0435\u0433\u043E \u043F\u043E\u0432\u0435\u0434\u0435\u043D\
  \u0438\u044F."
title: "\u0420\u0435\u0444\u0430\u043A\u0442\u043E\u0440\u0438\u043D\u0433"
weight: 19
---

## Как это сделать:
Вот фрагмент кода на Kotlin, демонстрирующий типичный недочет в коде и его рефакторинг. Мы начинаем с блока кода, который выполняет слишком много операций:

```kotlin
fun processOrders(orders: List<Order>) {
    for (order in orders) {
        print("Номер заказа: ${order.id}")
        // Расчет итоговой суммы заказа
        var total = 0.0
        for (item in order.items) {
            total += item.price
        }
        // Применение скидки
        if (order.customer.isVIP) {
            total *= 0.9
        }
        print("Итого: $total")
        // Дополнительная обработка...
    }
}
```

Рефакторинг для лучшей читаемости и разделения забот:

```kotlin
fun printOrderSummary(order: Order) {
    print("Номер заказа: ${order.id}")
    val total = calculateTotal(order)
    print("Итого: $total")
}

fun calculateTotal(order: Order): Double {
    var total = order.items.sumOf { it.price }
    return if (order.customer.isVIP) total * 0.9 else total
}

fun processOrders(orders: List<Order>) {
    orders.forEach { printOrderSummary(it) }
}
```

Здесь нет примера вывода, поскольку мы не изменили функциональность, но читаемость и поддерживаемость кода значительно улучшились!

## Глубокое погружение
Рефакторинг как концепция существует с тех пор, как началось программирование, но он действительно набрал обороты как дисциплина в 1990-х годах, особенно после того, как Мартин Фаулер опубликовал "Рефакторинг: Улучшение проекта существующего кода" в 1999 году. Эта книга дала название практике и определила организованный метод ее применения, включая каталог техник рефакторинга.

Сравнивая рефакторинг с альтернативами: можно переписать код с нуля (рискованно и затратно по времени) или просто делать дополнительные изменения (ведет к увеличению объема программного обеспечения и потенциальному техническому долгу). Рефакторинг занимает золотую середину - он модернизирует и очищает, сохраняя при этом риск на низком уровне.

С точки зрения реализации крайне важно иметь надежный набор тестов перед началом рефакторинга, чтобы убедиться, что вы случайно не измените поведение программы. Многие современные среды разработки (включая IntelliJ для Kotlin) имеют автоматизированные инструменты рефакторинга для переименования переменных, выделения методов и многого другого, что может ускорить процесс и уменьшить количество ошибок.

## См. также
- "Рефакторинг: Улучшение проекта существующего кода" Мартина Фаулера (для основ работы по этой теме)
- Документация Kotlin по соглашениям кодирования: [https://kotlinlang.org/docs/coding-conventions.html](https://kotlinlang.org/docs/coding-conventions.html) (для понимания "пути Kotlin" к чистому коду)
- Поддержка рефакторинга в IntelliJ IDEA от JetBrains: [https://www.jetbrains.com/help/idea/refactoring-source-code.html](https://www.jetbrains.com/help/idea/refactoring-source-code.html) (для практического использования инструментов рефакторинга)
- Руководство Google по рефакторингу в больших масштабах: [https://testing.googleblog.com/2017/06/code-health-to-comment-or-not-to-comment.html](https://testing.googleblog.com/2017/06/code-health-to-comment-or-not-to-comment.html) (для получения представления о решении более крупных задач рефакторинга)
