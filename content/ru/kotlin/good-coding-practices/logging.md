---
title:                "Журналирование"
aliases:
- /ru/kotlin/logging/
date:                  2024-01-29T00:00:49.326169-07:00
model:                 gpt-4-0125-preview
simple_title:         "Журналирование"

tag:                  "Good Coding Practices"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/ru/kotlin/logging.md"
changelog:
  - 2024-01-28, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## Что и Почему?

Логирование, в его основе, это практика записи событий и данных из программного приложения во внешний вывод, например, в файл или консоль. Программисты ведут логи, чтобы проследить путь через код, устранить проблемы и следить за поведением приложения в реальных условиях, предоставляя критически важные данные, которые нельзя было бы получить столь же эффективно другим способом.

## Как:

В Kotlin логирование может быть выполнено с использованием встроенной функции `println()` для простых случаев или с использованием более сложных библиотек, таких как SLF4J с Logback или Log4j для более продвинутых потребностей.

Ниже приведен базовый пример использования `println()`:

```Kotlin
fun main() {
    println("Простое сообщение лога: Приложение запущено.")
    // ... здесь некоторая логика приложения ...
    try {
        // Имитация ошибки
        throw Exception("Имитированная ошибка")
    } catch (e: Exception) {
        println("Сообщение лога об ошибке: " + e.message)
    }
}
```

Вывод:
```
Простое сообщение лога: Приложение запущено.
Сообщение лога об ошибке: Имитированная ошибка
```

А вот фрагмент, использующий SLF4J с настроенным Logback:

```Kotlin
import org.slf4j.LoggerFactory

private val logger = LoggerFactory.getLogger("MyAppLogger")

fun main() {
    logger.info("Структурированное сообщение лога: Приложение запущено.")
    // ... здесь некоторая логика приложения ...
    try {
        // Имитация ошибки
        throw Exception("Имитированная ошибка")
    } catch (e: Exception) {
        logger.error("Структурированный лог ошибки: ", e)
    }
}
```

При соответствующей конфигурации Logback вывод может быть форматирован и может выглядеть примерно так, когда он записан в файл лога:
```
[INFO] - 2023-03-29 14:15:42 - MyAppLogger - Структурированное сообщение лога: Приложение запущено.
[ERROR] - 2023-03-29 14:15:43 - MyAppLogger - Структурированный лог ошибки: 
java.lang.Exception: Имитированная ошибка
   at com.myapp.Main.main(Main.kt:10)
```

## Глубокое погружение

Исторически логирование в программном обеспечении развивалось вместе с увеличением сложности приложений и систем. Простые операторы вывода были достаточными на ранних этапах, когда программы часто запускались и отлаживались самими разработчиками. Но по мере того, как системы стали объединяться в сеть и работать в различных средах у разных пользователей, мощная и постоянная система логирования стала критически важной.

До того, как Kotlin стал популярным, разработчики на Java широко использовали библиотеки вроде Log4j и позже SLF4J. Эти библиотеки вдохновили на схожие практики в Kotlin, используя взаимодействие Kotlin с библиотеками Java. SLF4J действует как абстрактный слой, позволяющий заменять реализацию логирования – обычно предпочтительными выборами являются Logback или Log4j2.

Kotlin также позволяет использовать мультиплатформенные решения для логирования, работающие на JVM, JavaScript и Native, например, через механизм `expect`/`actual`, который абстрагирует специфичные для платформы реализации.

В отличие от специализированных библиотек логирования, println остается самым простым видом логирования, поскольку не требует дополнительной настройки или зависимостей; однако, обычно это не подходит для продуктовых приложений из-за его недостатков, таких как отсутствие уровней логирования, ротации логов и структурированных форматов.

Другие общие функции продвинутых фреймворков логирования включают:

- Уровни логов (DEBUG, INFO, WARN, ERROR и т.д.), чтобы категоризировать срочность сообщений логов.
- Вывод в различные приемники, такие как консоль, файлы, базы данных или сетевые сервисы.
- Автоматическая ротация логов и политики их сохранения.
- Поддержка распределенного трассирования для архитектуры микросервисов.
- Структурированное логирование с использованием форматов вроде JSON, которое хорошо интегрируется с системами аналитики логов.

Эти инструменты и функции критически важны для поддержания надежной, наблюдаемой системы, особенно в сложных, распределенных или высоконагруженных средах.

## Смотрите также

Для дальнейшего обучения и получения информации о логировании в Kotlin, изучите:

- SLF4J (Простой Фасад Логирования для Java) [http://www.slf4j.org/](http://www.slf4j.org/)
- Logback, преемник Log4j [http://logback.qos.ch/](http://logback.qos.ch/)
- Log4j 2 [https://logging.apache.org/log4j/2.x/](https://logging.apache.org/log4j/2.x/)
- Документация Kotlin Multiplatform по объявлениям 'expect' и 'actual': [https://kotlinlang.org/docs/multiplatform.html](https://kotlinlang.org/docs/multiplatform.html)
- Руководство по структурированному логированию в Kotlin: [https://ktor.io/docs/logging.html](https://ktor.io/docs/logging.html)
