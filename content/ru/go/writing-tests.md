---
title:                "Написание тестов"
aliases:
- ru/go/writing-tests.md
date:                  2024-02-03T18:15:50.090406-07:00
model:                 gpt-4-0125-preview
simple_title:         "Написание тестов"
tag:                  "Testing and Debugging"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/ru/go/writing-tests.md"
changelog:
  - 2024-02-03, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## Что и Почему?

Написание тестов на Go включает создание небольших, управляемых фрагментов кода, которые проверяют функциональность и поведение вашего приложения. Программисты пишут тесты, чтобы убедиться, что их код работает как ожидается в различных условиях, облегчить рефакторинг и помочь предотвратить регрессии.

## Как:

В Go тесты, как правило, пишутся в том же пакете, что и тестируемый код. Файлы, содержащие тесты, называются с суффиксом `_test.go`. Тесты - это функции, которые принимают указатель на объект testing.T (из пакета `testing`) в качестве аргумента, и они сигнализируют об ошибке, вызывая методы, такие как `t.Fail()`, `t.Errorf()` и т.д.

Пример простого теста для функции `Add`, определенной в `math.go`:
```go
// math.go
package math

func Add(x, y int) int {
    return x + y
}
```

Тестовый файл `math_test.go`:
```go
package math

import "testing"

func TestAdd(t *testing.T) {
    result := Add(1, 2)
    expected := 3
    if result != expected {
        t.Errorf("Add(1, 2) = %d; хотели %d", result, expected)
    }
}
```

Запускайте ваши тесты с помощью команды `go test` в той же директории, что и ваши тестовые файлы. Пример вывода, указывающего на успешное прохождение теста, будет выглядеть следующим образом:

```
PASS
ok      example.com/my/math 0.002s
```

Для табличных тестов, которые позволяют вам эффективно тестировать различные комбинации входных и выходных данных, определите срез структур, представляющих тестовые случаи:

```go
func TestAddTableDriven(t *testing.T) {
    var tests = []struct {
        x        int
        y        int
        expected int
    }{
        {1, 2, 3},
        {2, 3, 5},
        {-1, -2, -3},
    }
    
    for _, tt := range tests {
        testname := fmt.Sprintf("%d+%d", tt.x, tt.y)
        t.Run(testname, func(t *testing.T) {
            ans := Add(tt.x, tt.y)
            if ans != tt.expected {
                t.Errorf("получили %d, хотели %d", ans, tt.expected)
            }
        })
    }
}
```

## Подробнее

Фреймворк для тестирования в Go, представленный в Go 1 наряду с самим языком, был разработан для безшовной интеграции с инструментарием Go, отражая акцент Go на простоту и эффективность в разработке программного обеспечения. В отличие от некоторых фреймворков для тестирования в других языках, которые полагаются на внешние библиотеки или сложные настройки, встроенный пакет `testing` в Go предоставляет простой способ написания и запуска тестов.

Интересной особенностью подхода Go к тестированию является принцип соглашения перед настройкой, который он принимает, например, образец именования файлов (`_test.go`) и использование функциональных возможностей стандартной библиотеки вместо внешних зависимостей. Этот минималистичный подход поощряет разработчиков писать тесты, поскольку порог входа низкий.

Хотя встроенные средства тестирования в Go охватывают многое, существуют сценарии, в которых сторонние инструменты или фреймворки могут предложить больше функциональностей, таких как генерация моков, фаззинг-тестирование или тесты в стиле разработки, ориентированной на поведение (BDD). Популярные библиотеки, такие как Testify или GoMock, дополняют стандартные возможности тестирования в Go, предлагая более выразительные утверждения или возможности генерации моков, которые могут быть особенно полезны в сложных приложениях с множеством зависимостей.

Несмотря на существование этих альтернатив, стандартный пакет тестирования в Go остается краеугольным камнем для тестирования на Go из-за его простоты, производительности и тесной интеграции с языком и инструментарием. Будь то разработчики решают дополнить его сторонними инструментами или нет, фреймворк для тестирования в Go предоставляет надежную основу для обеспечения качества и надежности кода.
