---
title:                "Удаление символов, соответствующих шаблону"
date:                  2024-01-28T23:57:16.117673-07:00
model:                 gpt-4-0125-preview
simple_title:         "Удаление символов, соответствующих шаблону"

tag:                  "Strings"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/ru/go/deleting-characters-matching-a-pattern.md"
changelog:
  - 2024-01-28, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## Что и Зачем?

Удаление символов, соответствующих шаблону, заключается в вырезании определенных частей строки — как выдергивание сорняков из вашего текстового сада. Программисты делают это для очистки, форматирования или разбора данных, убеждаясь, что текст чист и полезен.

## Как это сделать:

В Go мы используем пакеты `strings` и `regexp`. Вот коротко и с кодом:

```go
package main

import (
	"fmt"
	"regexp"
	"strings"
)

func main() {
	// Использование пакета strings для удаления набора символов
	str1 := "Hello, 123 World!"
	cleanStr1 := strings.Map(func(r rune) rune {
		if r >= '0' && r <= '9' {
			return -1 // Удалить символ
		}
		return r // Оставить символ
	}, str1)

	fmt.Println(cleanStr1) // Вывод: Hello,  World!

	// Использование пакета regexp для удаления символов, соответствующих шаблону
	str2 := "Go 1.18 - это текущая версия!"
	re := regexp.MustCompile(`[0-9]+`)
	cleanStr2 := re.ReplaceAllString(str2, "")

	fmt.Println(cleanStr2) // Вывод: Go . - это текущая версия!
}
```

## Погружение в детали

В стародавние времена, когда языки программирования были больше похожи на арканы, поиск по шаблону был заветным умением. Регулярные выражения (regex) были швейцарским ножом для этой задачи. Go, однако, сделал это простым и эффективным, интегрировав этот навык с пакетом `regexp`.

Теперь, почему бы вам просто не использовать `strings.Replace` или `strings.ReplaceAll`? Ну, они подходят для простых, статичных замен. Но когда ваши шаблоны дики, как лианы в джунглях, на помощь приходит regex.

Под капотом `regexp` компилирует шаблон в машину состояний. Каждый символ проверяется с этой машиной, и совпадения удаляются. Это означает большую работу при первой компиляции, но молниеносно после этого.

Альтернативные методы? У вас есть `bytes.Buffer` для построения строк без шаблонов и `strings.Builder` в новых версиях, если вы аллергичны к ненужным аллокациям.

## Смотрите также

Лучшие места для расширения знаний:
- Go by Example: Regular Expressions - https://gobyexample.com/regular-expressions
- Go Doc: Пакет strings - https://pkg.go.dev/strings
- Go Doc: Пакет regexp - https://pkg.go.dev/regexp
- Игровая площадка регулярных выражений - https://regex101.com/ (не специфично для Go, но очень полезно)
