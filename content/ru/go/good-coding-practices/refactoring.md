---
title:                "Рефакторинг"
date:                  2024-02-03T18:07:31.260146-07:00
model:                 gpt-4-0125-preview
simple_title:         "Рефакторинг"
tag:                  "Good Coding Practices"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/ru/go/refactoring.md"
changelog:
  - 2024-02-03, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## Что и почему?

Рефакторинг в программировании включает реструктуризацию существующего компьютерного кода — изменение его факторинга — без изменения его внешнего поведения. Программисты приступают к этому процессу, чтобы улучшить читаемость кода, снизить его сложность и повысить удобство сопровождения, в конечном итоге делая программное обеспечение более понятным и удобным для модификации.

## Как это сделать:

В Go рефакторинг может варьироваться от простых корректировок кода до более сложных изменений. Давайте начнем с базового примера: упрощение начальной функции Go для лучшей читаемости и эффективности.

**До рефакторинга:**

```go
package main

import "fmt"

func CalculatePrice(quantity int, price float64) float64 {
    var total float64
    if quantity > 0 {
        total = float64(quantity) * price
    } else {
        total = 0
    }
    return total
}

func main() {
    fmt.Println(CalculatePrice(10, 5.99))  // Вывод: 59.9
}
```

**После рефакторинга:**

```go
package main

import "fmt"

func CalculatePrice(quantity int, price float64) float64 {
    if quantity > 0 {
        return float64(quantity) * price
    }
    return 0
}

func main() {
    fmt.Println(CalculatePrice(10, 5.99))  // Вывод: 59.9
}
```

В рефакторинговой версии удаление `else` упрощает поток функции, не влияя на ее результат — пример базовой, но значимой техники рефакторинга в Go.

Для более продвинутого примера рассмотрим рефакторинг функций для использования интерфейсов для лучшей повторной использования и тестируемости:

**До рефакторинга:**

```go
package main

import "fmt"

type Logger struct{}

func (l Logger) Log(message string) {
    fmt.Println("Log:", message)
}

func ProcessData(data string, logger Logger) {
    // Представим, что здесь некая обработка данных
    logger.Log("Data processed")
}

func main() {
    logger := Logger{}
    ProcessData("example data", logger)
}
```

**После рефакторинга:**

```go
package main

import "fmt"

type Logger interface {
    Log(message string)
}

type ConsoleLogger struct{}

func (c ConsoleLogger) Log(message string) {
    fmt.Println("Log:", message)
}

func ProcessData(data string, logger Logger) {
    // Обработка данных остается без изменений
    logger.Log("Data processed")
}

func main() {
    logger := ConsoleLogger{}
    ProcessData("example data", logger)
}
```

Рефакторинг с использованием интерфейса (`Logger`) вместо конкретного типа (`ConsoleLogger`) повышает гибкость функции и отделяет обработку данных от конкретной реализации логирования.

## Глубокое погружение

Рефакторинг в Go должен сбалансировать простоту (одна из основных философий Go) с гибкостью, необходимой в крупных программных проектах. Учитывая минималистичный подход Go к функциональности — без обобщений (до недавнего времени) и с сильным акцентом на читаемость — язык естественным образом направляет разработчиков на более простые, более поддерживаемые структуры кода. Однако это не означает, что код на Go не выигрывает от рефакторинга; это означает, что рефакторинг всегда должен приоритизировать ясность и простоту.

Исторически, отсутствие определенных функций в Go (например, обобщений до Go 1.18) приводило к творческим, но иногда запутанным решениям для повторного использования кода и гибкости, делая рефакторинг для абстракции обычной практикой. С введением обобщений в Go 1.18 разработчики Go теперь рефакторят устаревший код, чтобы использовать эту функцию для лучшей типобезопасности и повторного использования кода, демонстрируя развивающийся характер практик рефакторинга в Go.

Тем не менее, инструментарий Go, включая `gofmt` для форматирования кода и `go vet` для выявления подозрительных конструкций, поддерживает поддержание чистых кодовых баз, снижая необходимость в обширном рефакторинге. Хотя рефакторинг является ценным инструментом в арсенале программиста Go, мудрое использование функций языка Go и инструментов с самого начала может помочь минимизировать необходимость в сложном рефакторинге позже.
