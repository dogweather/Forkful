---
title:                "Журналирование"
date:                  2024-01-29T00:00:58.631532-07:00
model:                 gpt-4-0125-preview
simple_title:         "Журналирование"

tag:                  "Good Coding Practices"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/ru/rust/logging.md"
changelog:
  - 2024-01-28, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## Что и зачем?

Логирование похоже на ведение журнала для вашего приложения; это практика записи событий, ошибок и других важных данных во время выполнения. Разработчики используют логи для диагностики проблем, мониторинга поведения системы и сбора информации, которая способствует улучшениям — это хлеб с маслом операционной интеллектуальности.

## Как это сделать:

Давайте настроим базовый сценарий логирования на Rust с использованием крейта `log`, который предоставляет фасад для логирования, и `env_logger`, реализацию логирования для крейта `log`. Сначала добавьте их в ваш Cargo.toml:

```toml
[dependencies]
log = "0.4.14"
env_logger = "0.9.0"
```

Теперь настройте и инициализируйте логгер в вашем `main.rs`:

```rust
use log::{info, warn};

fn main() {
    env_logger::init();

    info!("Это информационное сообщение.");
    warn!("Это предупреждающее сообщение.");
}
```

Запустите ваше приложение с `RUST_LOG=info cargo run`, и вы увидите вывод:

```
INFO: Это информационное сообщение.
WARN: Это предупреждающее сообщение.
```

Поиграйте с переменной окружения `RUST_LOG`, установив ее в `error`, `warn`, `info`, `debug` или `trace`, чтобы контролировать детализацию ваших логов.

## Подробный разбор

Концепция логирования не нова; она существует с ранних дней вычислительной техники. До того как логирование стало общепринятым в программном обеспечении, разработчики полагались на примитивные методы, такие как операторы печати или инструменты отладчика, чтобы отслеживать выполнение программы. По мере усложнения программ возникла потребность в структурированных подходах к логированию.

В Rust, крейт `log` абстрагирует детали реализации логирования, позволяя разработчикам подключать различные бэкенды для логирования. Хотя `env_logger` является распространенным выбором, существуют альтернативы, такие как `fern`, `slog` или `tracing`, каждая из которых имеет свой набор функций и опций конфигурации.

Некоторые соображения при реализации логирования включают:

1. **Уровни логирования**: Контроль детализации крайне важен. Крейт `log` Rust определяет несколько уровней логирования: error, warn, info, debug и trace, в порядке уменьшения серьезности.

2. **Производительность**: Логирование может влиять на производительность. Критически важно использовать его с умом, стараясь избегать логирования на критически важных путях или чрезмерно подробных логов в продакшене.

3. **Структурированное логирование**: Современные передовые практики включают в себя структурированное логирование, когда логи записываются в машиночитаемом формате, например, JSON. Библиотеки, такие как `slog`, позволяют осуществлять структурированное логирование в Rust, которое может быть индексировано и запрашиваемо с использованием систем управления логами, таких как ELK Stack или Splunk.

4. **Асинхронное логирование**: Чтобы минимизировать влияние на основное приложение, логирование может быть выполнено асинхронно. Это часто достигается за счет того, что библиотека логирования записывает данные во внутреннюю очередь, а отдельный поток обрабатывает эту очередь и записывает логи в назначение.

5. **Конфигурация**: Многие фреймворки логирования поддерживают конфигурацию через переменные окружения, файлы конфигурации и/или код. Эта гибкость ключевая для точной настройки вывода в разных средах (разработка, стейджинг, продакшен).

## Смотрите также

- Документация крейта `log`: https://docs.rs/log/
- Документация крейта `env_logger`: https://docs.rs/env_logger/
- Страница Rust by Example о логировании: https://doc.rust-lang.org/rust-by-example/std_misc/log.html
- Крейт `slog`, альтернативный фреймворк для логирования: https://github.com/slog-rs/slog
- Tracing, фреймворк для инструментирования программ на Rust: https://crates.io/crates/tracing
