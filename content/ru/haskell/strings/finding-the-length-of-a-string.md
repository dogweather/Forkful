---
changelog:
- 2024-01-28, gpt-4-0125-preview, translated from English
date: 2024-01-28 23:58:18.048012-07:00
description: "\u041D\u0430\u0445\u043E\u0436\u0434\u0435\u043D\u0438\u0435 \u0434\u043B\
  \u0438\u043D\u044B \u0441\u0442\u0440\u043E\u043A\u0438 \u0432 Haskell \u0437\u0430\
  \u043A\u043B\u044E\u0447\u0430\u0435\u0442\u0441\u044F \u0432 \u043E\u043F\u0440\
  \u0435\u0434\u0435\u043B\u0435\u043D\u0438\u0438, \u0441\u043A\u043E\u043B\u044C\
  \u043A\u043E \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432 \u043E\u043D\u0430\
  \ \u0441\u043E\u0434\u0435\u0440\u0436\u0438\u0442. \u041F\u0440\u043E\u0433\u0440\
  \u0430\u043C\u043C\u0438\u0441\u0442\u0430\u043C \u044D\u0442\u043E \u0447\u0430\
  \u0441\u0442\u043E \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044F \u0434\
  \u043B\u044F \u043A\u043E\u043D\u0442\u0440\u043E\u043B\u044F \u0438\u0442\u0435\
  \u0440\u0430\u0442\u043E\u0440\u043E\u0432\u2026"
lastmod: '2024-03-13T22:44:45.117004-06:00'
model: gpt-4-0125-preview
summary: "\u041D\u0430\u0445\u043E\u0436\u0434\u0435\u043D\u0438\u0435 \u0434\u043B\
  \u0438\u043D\u044B \u0441\u0442\u0440\u043E\u043A\u0438 \u0432 Haskell \u0437\u0430\
  \u043A\u043B\u044E\u0447\u0430\u0435\u0442\u0441\u044F \u0432 \u043E\u043F\u0440\
  \u0435\u0434\u0435\u043B\u0435\u043D\u0438\u0438, \u0441\u043A\u043E\u043B\u044C\
  \u043A\u043E \u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432 \u043E\u043D\u0430\
  \ \u0441\u043E\u0434\u0435\u0440\u0436\u0438\u0442."
title: "\u041F\u043E\u0438\u0441\u043A \u0434\u043B\u0438\u043D\u044B \u0441\u0442\
  \u0440\u043E\u043A\u0438"
weight: 7
---

## Как:
```Haskell
-- Использование функции `length`
main = do
    let myString = "Привет, Haskell!"
    print $ length myString
```

Пример вывода:
```
15
```

## Подробнее
Haskell - это чисто функциональный язык, где строки представлены как списки символов. Функция `length`, часть Prelude (библиотеки по умолчанию, импортируемой в каждую программу на Haskell), работает именно с таким представлением.

Исторически, строки как списки были естественным выбором для Haskell из-за их простоты и того факта, что Lisp сделал аналогичный выбор дизайна (и повлиял на многие функциональные языки). Функция `length` просто подсчитывает элементы в этом списке.

Однако, `length` имеет сложность O(n), что означает, что функция будет работать время, пропорциональное длине строки. Это не проблема для коротких строк, но для длинных может быть неэффективно.

Альтернативы включают:
- Использование `Text` из пакета `text`, более эффективной структуры для текста в кодировке Unicode.
- Использование `ByteString` из пакета `bytestring` для двоичных данных или данных ASCII.

Оба предлагают функцию `length`, оптимизированную для своих соответствующих структур данных.

С точки зрения реализации, базовая версия функции `length` может выглядеть так:

```Haskell
myLength :: [a] -> Int
myLength [] = 0          -- Длина пустого списка равна 0
myLength (_:xs) = 1 + myLength xs  -- Рекурсивно добавляем 1 для остальной части списка
```

Для типов данных `Text` и `ByteString` у них есть свои собственные детали внутренней реализации, которые делают их более эффективными, чем простой связанный список символов.

## Смотрите также
- [Официальная документация Haskell `length`](https://hackage.haskell.org/package/base-4.16.1.0/docs/Prelude.html#v:length)
- [Пакет `text` на Hackage](https://hackage.haskell.org/package/text)
- [Пакет `bytestring` на Hackage](https://hackage.haskell.org/package/bytestring)
- [Изучаем Haskell ради большого блага! (Вводная книга)](http://learnyouahaskell.com/chapters)
