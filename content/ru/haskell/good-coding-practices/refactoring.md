---
changelog:
- 2024-01-29, gpt-4-0125-preview, translated from English
date: 2024-01-29 00:03:02.305111-07:00
description: "\u0420\u0435\u0444\u0430\u043A\u0442\u043E\u0440\u0438\u043D\u0433 \u2014\
  \ \u044D\u0442\u043E \u043F\u0440\u043E\u0446\u0435\u0441\u0441 \u043A\u043E\u0440\
  \u0440\u0435\u043A\u0442\u0438\u0440\u043E\u0432\u043A\u0438 \u0432\u0430\u0448\u0435\
  \u0433\u043E \u043A\u043E\u0434\u0430 \u0431\u0435\u0437 \u0438\u0437\u043C\u0435\
  \u043D\u0435\u043D\u0438\u044F \u0435\u0433\u043E \u0432\u043D\u0435\u0448\u043D\
  \u0435\u0433\u043E \u043F\u043E\u0432\u0435\u0434\u0435\u043D\u0438\u044F. \u042D\
  \u0442\u043E \u0432\u0441\u0451 \u043E \u0442\u043E\u043C, \u0447\u0442\u043E\u0431\
  \u044B \u043F\u0440\u0438\u0432\u0435\u0441\u0442\u0438 \u0432 \u043F\u043E\u0440\
  \u044F\u0434\u043E\u043A \u0438 \u043E\u0440\u0433\u0430\u043D\u0438\u0437\u043E\
  \u0432\u0430\u0442\u044C \u0432\u0430\u0448 \u043A\u043E\u0434\u2026"
lastmod: '2024-03-13T22:44:45.149316-06:00'
model: gpt-4-0125-preview
summary: "\u0420\u0435\u0444\u0430\u043A\u0442\u043E\u0440\u0438\u043D\u0433 \u2014\
  \ \u044D\u0442\u043E \u043F\u0440\u043E\u0446\u0435\u0441\u0441 \u043A\u043E\u0440\
  \u0440\u0435\u043A\u0442\u0438\u0440\u043E\u0432\u043A\u0438 \u0432\u0430\u0448\u0435\
  \u0433\u043E \u043A\u043E\u0434\u0430 \u0431\u0435\u0437 \u0438\u0437\u043C\u0435\
  \u043D\u0435\u043D\u0438\u044F \u0435\u0433\u043E \u0432\u043D\u0435\u0448\u043D\
  \u0435\u0433\u043E \u043F\u043E\u0432\u0435\u0434\u0435\u043D\u0438\u044F."
title: "\u0420\u0435\u0444\u0430\u043A\u0442\u043E\u0440\u0438\u043D\u0433"
weight: 19
---

## Как это делать:
Допустим, у вас есть кусок кода на Haskell, который повторяется чаще, чем ваша любимая песня. Вот быстрый взгляд на то, как вы могли бы рефакторить это с использованием функций.

До рефакторинга:

```haskell
printInvoice :: String -> Float -> String -> IO ()
printInvoice customer total item = do
  putStrLn $ "Customer: " ++ customer
  putStrLn $ "Total: " ++ show total
  putStrLn $ "Item: " ++ item
```

После небольшого рефакторинга:

```haskell
printDetail :: String -> String -> IO ()
printDetail label value = putStrLn $ label ++ ": " ++ value

printInvoice :: String -> Float -> String -> IO ()
printInvoice customer total item = do
  printDetail "Customer" customer
  printDetail "Total" (show total)
  printDetail "Item" item

-- Пример вывода:
-- Customer: Alice
-- Total: $42.00
-- Item: Руководство по программированию на Haskell
```

Как вы можете видеть, извлекая общие шаблоны в отдельную функцию `printDetail`, мы избегаем повторения и делаем `printInvoice` более понятной и легкой для управления.

## Глубокое погружение
Когда Haskell появился в конце 80-х, стало ясно, что функциональная парадигма может принести некоторое новшество в практики программирования. Проведя быстрый взгляд вперёд, рефакторинг на Haskell выглядит особенно элегантно благодаря тому, что функции являются объектами первого класса и сильной статической типизации. Вы можете рефакторить, не боясь, что сломаете приложение, так как компилятор защитит вас.

Альтернативами ручному рефакторингу могут быть автоматизированные инструменты, хотя функциональная природа и типовая безопасность Haskell иногда могут делать это менее распространенным по сравнению с другими языками. С точки зрения реализации, важно использовать такие возможности Haskell, как функции высших порядков, чистота и неизменяемость для облегчения рефакторинга.

Такие рефакторинги, как "Извлечение функции", как было показано, являются обычным делом, но вы также можете с уверенностью выполнять "Встраивание функции", "Переименование переменной" и "Изменение сигнатуры функции" благодаря системе типов. Мощный механизм вывода типов в Haskell иногда может обнаружить ошибки, которые могли бы проскользнуть в других языках.

## Смотрите также
Для глубокого погружения в рефакторинг на Haskell обратитесь к книге "Рефакторинг: Улучшение проекта существующего кода" Мартина Фаулера, где концепции являются универсально применимыми. Ознакомьтесь с инструментом hlint для автоматизированных подсказок по улучшению вашего кода на Haskell. Также зайдите на вики Haskell (https://wiki.haskell.org/Refactoring) для получения сообщественных взглядов и дальнейшего чтения.
