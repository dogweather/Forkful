---
changelog:
- 2024-01-28, gpt-4-0125-preview, translated from English
date: 2024-01-29 00:00:06.714647-07:00
description: "\u0420\u0430\u0437\u0431\u043E\u0440 HTML \u043E\u0437\u043D\u0430\u0447\
  \u0430\u0435\u0442 \u0438\u0437\u0432\u043B\u0435\u0447\u0435\u043D\u0438\u0435\
  \ \u0434\u0430\u043D\u043D\u044B\u0445 \u0438\u0437 HTML-\u0434\u043E\u043A\u0443\
  \u043C\u0435\u043D\u0442\u043E\u0432 \u2014 \u0432 \u043A\u043E\u043D\u0446\u0435\
  \ \u043A\u043E\u043D\u0446\u043E\u0432, HTML - \u044D\u0442\u043E \u043A\u0430\u0440\
  \u043A\u0430\u0441 \u0432\u0435\u0431\u0430. \u041F\u0440\u043E\u0433\u0440\u0430\
  \u043C\u043C\u0438\u0441\u0442\u044B \u0430\u043D\u0430\u043B\u0438\u0437\u0438\u0440\
  \u0443\u044E\u0442 HTML, \u0447\u0442\u043E\u0431\u044B \u0430\u0432\u0442\u043E\
  \u043C\u0430\u0442\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u0442\u044C\u2026"
lastmod: '2024-03-13T22:44:45.129657-06:00'
model: gpt-4-0125-preview
summary: "\u0420\u0430\u0437\u0431\u043E\u0440 HTML \u043E\u0437\u043D\u0430\u0447\
  \u0430\u0435\u0442 \u0438\u0437\u0432\u043B\u0435\u0447\u0435\u043D\u0438\u0435\
  \ \u0434\u0430\u043D\u043D\u044B\u0445 \u0438\u0437 HTML-\u0434\u043E\u043A\u0443\
  \u043C\u0435\u043D\u0442\u043E\u0432 \u2014 \u0432 \u043A\u043E\u043D\u0446\u0435\
  \ \u043A\u043E\u043D\u0446\u043E\u0432, HTML - \u044D\u0442\u043E \u043A\u0430\u0440\
  \u043A\u0430\u0441 \u0432\u0435\u0431\u0430."
title: "\u0420\u0430\u0437\u0431\u043E\u0440 HTML"
weight: 43
---

## Как:
Давайте погрузимся в код, используя библиотеку `tagsoup` для разбора простого HTML-фрагмента. Сначала убедитесь, что установили пакет из Hackage через `cabal install tagsoup`.

```Haskell
import Text.HTML.TagSoup

-- Давайте разберем простой HTML-фрагмент
let html = "<html><body><p>Привет, Haskell!</p></body></html>"

-- Разбираем
let parsedHtml = parseTags html

-- Находим параграфы
let paragraphs = partitions (~== "<p>") parsedHtml

-- Получаем текст из первого параграфа
let firstParagraphText = innerText $ head paragraphs

-- Вуаля!
print firstParagraphText
```

Пример вывода:
```
"Привет, Haskell!"
```
Этот фрагмент разбирает строку HTML, отыскивает теги параграфов и печатает текст, содержащийся в первом параграфе. Опрятно и сладко.

## Глубокое Погружение
Разбор HTML в Haskell не всегда был таким простым, как сегодня. Когда-то люди создавали свои собственные парсеры или боролись с библиотеками низкого уровня, анализируя HTML, как будто это был Дикий Запад.

В наши дни у вас есть выбор. `tagsoup`, как мы использовали, отлично подходит, когда структура HTML скорее предложение, чем правило — он терпим к реальному неаккуратному HTML. Если вы ищете большей строгости, `html-conduit` в сочетании с `xml-conduit` из пакета `conduit` может быть вашим выбором. Они используют потоковый подход и более требовательны к структуре.

Под капотом эти библиотеки превращают HTML в дерево или суп из тегов. Они предоставляют удобные функции для запроса и манипулирования этими данными, делая разбор HTML менее головной болью. Думайте о них как о карте сокровищ, где X отмечает тег параграфа.

## См. Также
- [`tagsoup` на Hackage](https://hackage.haskell.org/package/tagsoup)
- [`html-conduit` на Hackage](https://hackage.haskell.org/package/html-conduit)
- [Документация Beautiful Soup](https://www.crummy.com/software/BeautifulSoup/) - Хотя и не Haskell, подход Beautiful Soup к 'супу из тегов' повлиял на похожие библиотеки в мире Haskell.
- [Функции и операторы XPath и XQuery на сайте W3C](https://www.w3.org/TR/xpath-functions/) - Глубокое погружение в стандарты может информировать о структуре и запросах к XML/HTML документам, полезно для понимания стратегий разбора на заднем плане.
