---
aliases:
- /ru/python/using-associative-arrays/
changelog:
- 2024-01-30, gpt-4-0125-preview, translated from English
date: 2024-01-30 19:12:51.126361-07:00
description: "\u0410\u0441\u0441\u043E\u0446\u0438\u0430\u0442\u0438\u0432\u043D\u044B\
  \u0435 \u043C\u0430\u0441\u0441\u0438\u0432\u044B, \u0438\u0437\u0432\u0435\u0441\
  \u0442\u043D\u044B\u0435 \u0432 Python \u043A\u0430\u043A \u0441\u043B\u043E\u0432\
  \u0430\u0440\u0438, \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u044E\u0442\
  \ \u043A\u043B\u044E\u0447\u0438 \u043D\u0430 \u0437\u043D\u0430\u0447\u0435\u043D\
  \u0438\u044F, \u0447\u0442\u043E \u0443\u043F\u0440\u043E\u0449\u0430\u0435\u0442\
  \ \u0438\u0437\u0432\u043B\u0435\u0447\u0435\u043D\u0438\u0435, \u0438\u0437\u043C\
  \u0435\u043D\u0435\u043D\u0438\u0435 \u0438\u043B\u0438 \u043E\u0442\u0441\u043B\
  \u0435\u0436\u0438\u0432\u0430\u043D\u0438\u0435 \u0434\u0430\u043D\u043D\u044B\u0445\
  \ \u043F\u043E\u2026"
lastmod: 2024-02-18 23:08:56.524482
model: gpt-4-0125-preview
summary: "\u0410\u0441\u0441\u043E\u0446\u0438\u0430\u0442\u0438\u0432\u043D\u044B\
  \u0435 \u043C\u0430\u0441\u0441\u0438\u0432\u044B, \u0438\u0437\u0432\u0435\u0441\
  \u0442\u043D\u044B\u0435 \u0432 Python \u043A\u0430\u043A \u0441\u043B\u043E\u0432\
  \u0430\u0440\u0438, \u043E\u0442\u043E\u0431\u0440\u0430\u0436\u0430\u044E\u0442\
  \ \u043A\u043B\u044E\u0447\u0438 \u043D\u0430 \u0437\u043D\u0430\u0447\u0435\u043D\
  \u0438\u044F, \u0447\u0442\u043E \u0443\u043F\u0440\u043E\u0449\u0430\u0435\u0442\
  \ \u0438\u0437\u0432\u043B\u0435\u0447\u0435\u043D\u0438\u0435, \u0438\u0437\u043C\
  \u0435\u043D\u0435\u043D\u0438\u0435 \u0438\u043B\u0438 \u043E\u0442\u0441\u043B\
  \u0435\u0436\u0438\u0432\u0430\u043D\u0438\u0435 \u0434\u0430\u043D\u043D\u044B\u0445\
  \ \u043F\u043E\u2026"
title: "\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u0435\
  \ \u0430\u0441\u0441\u043E\u0446\u0438\u0430\u0442\u0438\u0432\u043D\u044B\u0445\
  \ \u043C\u0430\u0441\u0441\u0438\u0432\u043E\u0432"
---

{{< edit_this_page >}}

## Что и Почему?

Ассоциативные массивы, известные в Python как словари, отображают ключи на значения, что упрощает извлечение, изменение или отслеживание данных по уникальному идентификатору. Программисты используют их за их эффективность доступа к элементам и гибкость в представлении сложных структур данных.

## Как:

Создание словаря в Python просто. Вам нужно заключить пары ключ-значение в фигурные скобки `{}`, с ключами и значениями, разделенными двоеточием:

```Python
# Создаем ассоциативный массив (словарь)
my_dict = {"name": "John", "age": 30, "city": "New York"}
print(my_dict)
```

Вывод:
```
{'name': 'John', 'age': 30, 'city': 'New York'}
```

Доступ к значению по его ключу прост:

```Python
# Доступ к значению
print(my_dict["name"])
```

Вывод:
```
John
```

Добавление или обновление элементов осуществляется путем присвоения значения ключу:

```Python
# Добавляем новую пару ключ-значение
my_dict["email"] = "john@example.com"
# Обновляем значение
my_dict["age"] = 31
print(my_dict)
```

Вывод:
```
{'name': 'John', 'age': 31, 'city': 'New York', 'email': 'john@example.com'}
```

Для итерации по элементам словаря:

```Python
# Итерация по парам ключ-значение
for key, value in my_dict.items():
    print(f"{key}: {value}")
```

Вывод:
```
name: John
age: 31
city: New York
email: john@example.com
```

## Глубокое Погружение

Ассоциативные массивы в Python, или словари, были введены для предоставления структуры данных для эффективного доступа к данным и обработки данных. В отличие от последовательностей, которые индексируются диапазоном чисел, словари индексируются ключами, которыми могут быть любые неизменяемые типы. Этот выбор дизайна делает словари идеально подходящими для быстрых таблиц поиска, где ключи отображаются на уникальные значения.

Исторически словари Python реализовывались с использованием хеш-таблицы, обеспечивая, таким образом, что среднее время сложности для операций поиска, вставки и удаления составляет O(1). Начиная с Python 3.6 и позже, словари также сохраняют порядок вставки элементов, сочетая в себе преимущества хеш-таблиц с предсказуемостью порядка вставки, видимой в упорядоченных структурах данных.

Хотя словари невероятно универсальны, в некоторых специализированных случаях могут быть предпочтительнее альтернативы, такие как `collections.defaultdict` или `collections.OrderedDict` (до Python 3.7). `defaultdict` особенно полезен, когда вам нужен словарь, возвращающий значение по умолчанию для несуществующих ключей, упрощая определенные типы условной логики. Однако, с непрерывным улучшением и развитием Python, встроенный класс словаря часто остается предпочтительным выбором для ассоциативных массивов из-за его надежности и удобства, которое он предлагает "из коробки".
