---
aliases:
- /ru/python/handling-errors/
changelog:
- 2024-01-28, gpt-4-0125-preview, translated from English
date: 2024-01-28 23:58:51.047975-07:00
description: "\u041E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u043E\u0448\u0438\
  \u0431\u043E\u043A \u0432 Python (\u0438\u043B\u0438 \u0432 \u043B\u044E\u0431\u043E\
  \u043C \u0434\u0440\u0443\u0433\u043E\u043C \u044F\u0437\u044B\u043A\u0435 \u043F\
  \u0440\u043E\u0433\u0440\u0430\u043C\u043C\u0438\u0440\u043E\u0432\u0430\u043D\u0438\
  \u044F) \u0437\u0430\u043A\u043B\u044E\u0447\u0430\u0435\u0442\u0441\u044F \u0432\
  \ \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u0438 \u043D\u0435\u043E\u0436\u0438\
  \u0434\u0430\u043D\u043D\u043E\u0433\u043E \u2013 \u044D\u0442\u043E \u0438\u0441\
  \u043A\u0443\u0441\u0441\u0442\u0432\u043E \u044D\u043B\u0435\u0433\u0430\u043D\u0442\
  \u043D\u043E\u0433\u043E \u0443\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u0438\u044F\
  \u2026"
lastmod: 2024-02-18 23:08:56.541946
model: gpt-4-0125-preview
summary: "\u041E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u043E\u0448\u0438\
  \u0431\u043E\u043A \u0432 Python (\u0438\u043B\u0438 \u0432 \u043B\u044E\u0431\u043E\
  \u043C \u0434\u0440\u0443\u0433\u043E\u043C \u044F\u0437\u044B\u043A\u0435 \u043F\
  \u0440\u043E\u0433\u0440\u0430\u043C\u043C\u0438\u0440\u043E\u0432\u0430\u043D\u0438\
  \u044F) \u0437\u0430\u043A\u043B\u044E\u0447\u0430\u0435\u0442\u0441\u044F \u0432\
  \ \u043E\u0436\u0438\u0434\u0430\u043D\u0438\u0438 \u043D\u0435\u043E\u0436\u0438\
  \u0434\u0430\u043D\u043D\u043E\u0433\u043E \u2013 \u044D\u0442\u043E \u0438\u0441\
  \u043A\u0443\u0441\u0441\u0442\u0432\u043E \u044D\u043B\u0435\u0433\u0430\u043D\u0442\
  \u043D\u043E\u0433\u043E \u0443\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u0438\u044F\
  \u2026"
title: "\u041E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u043E\u0448\u0438\u0431\
  \u043E\u043A"
---

{{< edit_this_page >}}

## Что и Почему?

Обработка ошибок в Python (или в любом другом языке программирования) заключается в ожидании неожиданного – это искусство элегантного управления ситуацией, когда в вашем коде что-то идет не так. Мы делаем это, чтобы предотвратить сбои, направлять пользователей и делать наши программы надежными и устойчивыми.

## Как это сделать:

```python
# Базовый блок try-except
try:
    # рискованный код
    number = int(input("Введите число: "))
except ValueError:
    # обработка ошибки
    print("Это не число!")

# Указание нескольких исключений
try:
    # код, который может вызвать разные исключения
    result = 10 / int(input("Введите делитель: "))
except ZeroDivisionError:
    print("Ой! Нельзя делить на ноль.")
except ValueError:
    print("Мне нужно число, дружище.")

# Использование else и finally
try:
    number = int(input("Введите число для возведения в квадрат: "))
except ValueError:
    print("Я сказал число!")
else:
    # ошибок не произошло
    print("Ваше число в квадрате:", number**2)
finally:
    # выполняется всегда
    print("Спасибо, что попробовали это!")
```

Пример вывода при вводе недопустимого числа для первого блока:
```
Введите число: привет
Это не число!
```

## Подробнее

С самого начала программирования, обработка ошибок была критически важна. Ранние подходы были элементарными, например, проверка условий перед каждой рискованной операцией. Синтаксис `try-except` Python произошел от наследия обработки исключений в более старых языках, таких как C++ и Java, упрощая процесс.

Когда вы используете `try` с блоком кода, Python следит за любыми исключениями. Если появляется ошибка, блок `except` ловит ее. Вы можете быть конкретными по поводу ловли исключений или поймать их всех с помощью пустого `except`. Однако, лучше сначала указывать конкретику – это точно, а не сеть, ловящая всё подряд.

`else` и `finally` – дополнения к этой концепции. Блок `else` выполняется, если в блоке try не возникло ошибок. `finally` – это надежный друг, который выполняется в любом случае – подумайте о операциях по очистке.

Альтернативы? Конечно, они есть. Некоторые языки используют коды возврата вместо исключений. Вы также можете столкнуться с операторами `with` для обработки ресурсов или `assertions`, которые проверяют условия во время разработки. Но когда мы говорим об надежных стратегиях обработки ошибок, модель try-catch выделяется своей читаемостью и структурой.

## Смотрите также

Вот некоторые хорошие дополнительные ресурсы для глубокого погружения:

- Официальная документация Python об ошибках и исключениях: [Python Docs – Errors and Exceptions](https://docs.python.org/3/tutorial/errors.html)
- Руководство от Real Python по данной теме: [Real Python - Блок try/except/else/finally](https://realpython.com/python-exceptions/)
- Продуманное обсуждение лучших практик обработки ошибок: [Stack Overflow – Как мне правильно игнорировать исключения?](https://stackoverflow.com/questions/4990718/about-catching-any-exception)
