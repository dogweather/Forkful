---
title:                "Рефакторинг"
aliases:
- /ru/clojure/refactoring/
date:                  2024-01-29T00:01:22.086969-07:00
model:                 gpt-4-0125-preview
simple_title:         "Рефакторинг"

tag:                  "Good Coding Practices"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/ru/clojure/refactoring.md"
changelog:
  - 2024-01-29, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## Что и Почему?

Рефакторинг — это процесс структурной переработки существующего компьютерного кода без изменения его внешнего поведения, направленный на улучшение нефункциональных атрибутов. Программисты проводят рефакторинг, чтобы сделать свой код более чистым, эффективным и легким в обслуживании, тем самым повышая его читабельность и уменьшая сложность программного обеспечения.

## Как:

Рефакторинг в Clojure — благодаря его чистому синтаксису и функциональной парадигме — может быть невероятно простым. Давайте рассмотрим обычный сценарий: итерация по коллекциям. Вы можете начать с цикла `for`, вот так:

```clojure
(defn calculate-sum [numbers]
  (reduce + 0 numbers))

(defn old-way []
  (let [nums (range 1 11)]
    (calculate-sum nums)))
```

Вызов `(old-way)` даст нам 55, сумму от 1 до 10. Но, эй, мы можем рефакторить это, чтобы сделать более Clojure-образным:

```clojure
(defn new-way []
  (->> (range 1 11)
       (reduce +)))
```

Эта рефакторинговая функция `(new-way)` использует макросы потоков для передачи диапазона непосредственно в `reduce`, уменьшая избыточность.

## Погружение

Искусство рефакторинга имеет корни в ранние дни разработки программного обеспечения, но действительно набрало обороты с выходом фундаментальной книги Мартина Фаулера "Рефакторинг: Улучшение проекта существующего кода", опубликованной в 1999 году. В Clojure рефакторинг часто опирается на принципы функционального программирования, отдавая предпочтение чистым функциям и неизменяемым структурам данных.

Альтернативы ручному рефакторингу в Clojure могут включать использование инструментов вроде Cursive, популярного плагина для IntelliJ IDEA, который предлагает автоматизированные рефакторинги, специфичные для Clojure. Также существует clj-refactor, пакет для Emacs для Clojure, предоставляющий набор функций для рефакторинга.

Особенной задачей при рефакторинге в Clojure является работа со состоянием и побочными эффектами в принципиально неизменяемой и свободной от побочных эффектов парадигме. Осторожное использование атомов, справок, агентов и транзиентов является ключевым в поддержании как производительности, так и корректности при рефакторингах.

## Смотрите также

- "Рефакторинг: Улучшение проекта существующего кода" Мартина Фаулера для основных концепций.
- [Документация Clojure](https://clojuredocs.org/) для конкретных примеров идиоматичного кода Clojure.
- [clj-refactor](https://github.com/clojure-emacs/clj-refactor.el) для автоматизации рефакторинга в Emacs.
- [Cursive](https://cursive-ide.com/) для пользователей IntelliJ, ищущих помощь в автоматизированном рефакторинге.
- [Рефакторинг с Ричем Хикки](https://www.infoq.com/presentations/Simple-Made-Easy/) - Доклад создателя Clojure, который, хотя и не о рефакторинге в частности, предоставляет представление о философии Clojure, которая может направлять эффективные решения по рефакторингу.
