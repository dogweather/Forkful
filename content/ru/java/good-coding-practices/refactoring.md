---
changelog:
- 2024-01-29, gpt-4-0125-preview, translated from English
date: 2024-01-29 00:02:19.941101-07:00
description: "\u0420\u0435\u0444\u0430\u043A\u0442\u043E\u0440\u0438\u043D\u0433 \u2014\
  \ \u044D\u0442\u043E \u043F\u0440\u043E\u0446\u0435\u0441\u0441 \u0440\u0435\u0441\
  \u0442\u0440\u0443\u043A\u0442\u0443\u0440\u0438\u0437\u0430\u0446\u0438\u0438 \u0441\
  \u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044E\u0449\u0435\u0433\u043E \u043A\u043E\
  \u043C\u043F\u044C\u044E\u0442\u0435\u0440\u043D\u043E\u0433\u043E \u043A\u043E\u0434\
  \u0430 \u2014 \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u044F \u0435\u0433\
  \u043E \u0444\u0430\u043A\u0442\u043E\u0440\u0438\u0437\u0430\u0446\u0438\u0438\
  \ \u2014 \u0431\u0435\u0437 \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u044F\
  \ \u0435\u0433\u043E \u0432\u043D\u0435\u0448\u043D\u0435\u0433\u043E \u043F\u043E\
  \u0432\u0435\u0434\u0435\u043D\u0438\u044F.\u2026"
lastmod: '2024-03-13T22:44:44.837588-06:00'
model: gpt-4-0125-preview
summary: "\u0420\u0435\u0444\u0430\u043A\u0442\u043E\u0440\u0438\u043D\u0433 \u2014\
  \ \u044D\u0442\u043E \u043F\u0440\u043E\u0446\u0435\u0441\u0441 \u0440\u0435\u0441\
  \u0442\u0440\u0443\u043A\u0442\u0443\u0440\u0438\u0437\u0430\u0446\u0438\u0438 \u0441\
  \u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044E\u0449\u0435\u0433\u043E \u043A\u043E\
  \u043C\u043F\u044C\u044E\u0442\u0435\u0440\u043D\u043E\u0433\u043E \u043A\u043E\u0434\
  \u0430 \u2014 \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u044F \u0435\u0433\
  \u043E \u0444\u0430\u043A\u0442\u043E\u0440\u0438\u0437\u0430\u0446\u0438\u0438\
  \ \u2014 \u0431\u0435\u0437 \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u044F\
  \ \u0435\u0433\u043E \u0432\u043D\u0435\u0448\u043D\u0435\u0433\u043E \u043F\u043E\
  \u0432\u0435\u0434\u0435\u043D\u0438\u044F."
title: "\u0420\u0435\u0444\u0430\u043A\u0442\u043E\u0440\u0438\u043D\u0433"
weight: 19
---

## Как
Давайте рассмотрим простой Java класс, который кричит о рефакторинге из-за своей плохой организации и недостатка ясности.

```java
public class Calculator {
    public int calc(int op1, int op2, String operation) {
        if (operation.equals("add")) {
            return op1 + op2;
        } else if (operation.equals("subtract")) {
            return op1 - op2;
        } // Другие операции...
    }
}
```

После рефакторинга у нас получается:

```java
public class Calculator {
    public int add(int operand1, int operand2) {
        return operand1 + operand2;
    }

    public int subtract(int operand1, int operand2) {
        return operand1 - operand2;
    }

    // Другие операции...
}
```

Благодаря рефакторингу мы улучшили имена методов и параметры для читаемости и устранили необходимость в условном ветвлении внутри одного метода. Каждая операция теперь четко указывает свою цель.

## Глубокое погружение
Рефакторинг берет свое начало в сообществе Smalltalk, с его акцентом на читаемость кода и объектно-ориентированное проектирование, но он действительно взлетел в мире Java в конце 90-х и начале 00-х годов, особенно после публикации фундаментальной книги Мартина Фаулера "Рефакторинг: Улучшение дизайна существующего кода".

Существуют альтернативы рефакторингу, такие как переписывание кода с нуля. Однако рефакторинг часто предпочтителен, поскольку он включает в себя постепенные изменения, которые не нарушают функциональность приложения.

Детали реализации при рефакторинге в Java (или любом другом языке программирования) вращаются вокруг понимания "запахов кода" — индикаторов более глубоких проблем в коде. Некоторые запахи включают в себя длинные методы, большие классы, дублирующий код и чрезмерное использование примитивов. Применяя паттерны рефакторинга, например, Выделение метода, Перемещение метода или Замена временной переменной запросом, разработчики могут систематически решать эти проблемы, обеспечивая при этом функциональность кода в любое время.

Автоматизированные инструменты, такие как поддержка рефакторинга в IntelliJ IDEA или плагины для Eclipse, могут помочь в процессе, автоматизируя такие рефакторинги, как переименование переменных, методов и классов, выделение методов или переменных и перемещение методов или классов в разные пакеты или пространства имен.

## См. также:
- "Рефакторинг: Улучшение дизайна существующего кода" Мартина Фаулера: https://martinfowler.com/books/refactoring.html
- Техники рефакторинга на Refactoring.Guru: https://refactoring.guru/refactoring/techniques
- Автоматизированный рефакторинг в Eclipse: https://www.eclipse.org/eclipse/news/4.18/jdt.php
- Возможности рефакторинга в IntelliJ IDEA: https://www.jetbrains.com/idea/features/refactoring.html

Каждый из этих ресурсов предоставляет либо основу для понимания принципов рефакторинга, либо инструменты, которые могут быть использованы для применения этих принципов на практике.
