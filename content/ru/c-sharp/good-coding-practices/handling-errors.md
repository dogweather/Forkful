---
changelog:
- 2024-01-28, gpt-4-0125-preview, translated from English
date: 2024-01-28 23:58:58.870048-07:00
description: "\u041E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u043E\u0448\u0438\
  \u0431\u043E\u043A \u0432 C# \u2014 \u044D\u0442\u043E \u0443\u043F\u0440\u0430\u0432\
  \u043B\u0435\u043D\u0438\u0435 \u043D\u0435\u043E\u0436\u0438\u0434\u0430\u043D\u043D\
  \u043E\u0441\u0442\u044F\u043C\u0438, \u043F\u043E\u0434\u043E\u0431\u043D\u043E\
  \ \u0441\u043F\u043E\u0442\u044B\u043A\u0430\u043D\u0438\u044E \u043E \u0448\u043D\
  \u0443\u0440\u043A\u0438. \u041F\u0440\u043E\u0433\u0440\u0430\u043C\u043C\u044B\
  \ \u043C\u043E\u0433\u0443\u0442 \"\u0441\u043F\u043E\u0442\u044B\u043A\u0430\u0442\
  \u044C\u0441\u044F\" \u043E \u043D\u0435\u043A\u043E\u0440\u0440\u0435\u043A\u0442\
  \u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435 \u0438\u043B\u0438 \u043D\
  \u0435\u0441\u0442\u0430\u0431\u0438\u043B\u044C\u043D\u044B\u0435\u2026"
lastmod: '2024-03-13T22:44:45.070312-06:00'
model: gpt-4-0125-preview
summary: "\u041E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u043E\u0448\u0438\
  \u0431\u043E\u043A \u0432 C# \u2014 \u044D\u0442\u043E \u0443\u043F\u0440\u0430\u0432\
  \u043B\u0435\u043D\u0438\u0435 \u043D\u0435\u043E\u0436\u0438\u0434\u0430\u043D\u043D\
  \u043E\u0441\u0442\u044F\u043C\u0438, \u043F\u043E\u0434\u043E\u0431\u043D\u043E\
  \ \u0441\u043F\u043E\u0442\u044B\u043A\u0430\u043D\u0438\u044E \u043E \u0448\u043D\
  \u0443\u0440\u043A\u0438."
title: "\u041E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 \u043E\u0448\u0438\u0431\
  \u043E\u043A"
weight: 16
---

## Как это сделать:
Начнем с блока try-catch. Это как поставить сеть безопасности под канатоходца. Если он поскользнется, он не упадет вниз — его поймают.

```C#
using System;

class ПримерОбработкиОшибок {
    static void Main() {
        try {
            int[] числа = {1, 2, 3};
            Console.WriteLine(числа[5]);  // Ой, индекс вне границ!
        } catch (IndexOutOfRangeException e) {
            Console.WriteLine("Ошибка перехвачена: " + e.Message);
        }
    }
}
```

Пример вывода при возникновении ошибок:
```
Ошибка перехвачена: Индекс находился вне границ массива.
```

Теперь добавим блок finally — это то, что происходит в любом случае, как и платежи налогов.

```C#
try {
    // Потенциально проблемный код здесь
} catch (SomeSpecificException e) {
    // Обработка этой конкретной ошибки здесь
} finally {
    // Этот код выполняется независимо от того, что произошло выше
    Console.WriteLine("Это всегда выполняется.");
}
```

## Глубокое погружение
Обработка ошибок была в C# с момента его создания. Со временем она эволюционировала. В прошлом программисты полагались на возвращаемые коды или глобальные флаги для сигнализации о проблемах — громоздко и склонно к ошибкам.

C# использует исключения, более современный подход. Исключение генерируется, когда происходит что-то неожиданное, подобно поднятию флага на игре в американский футбол. Структурированная обработка исключений с блоками try, catch и finally делает управление этими моментами более ясным и чистым, чем старые методы проверки ошибок.

Альтернативы? Конечно. Есть `UnhandledExceptionEventHandler` для исключений, которые прошли мимо. Или в асинхронном коде, обработка ошибок делается немного по-другому с объектами `Task`, которые несут собственный груз исключений.

Детали реализации — подобно мелкому шрифту — важны. Исключения могут быть дорогостоящими, тормозя производительность, если их бросать без разбора. Поэтому мы используем их для исключительных случаев, а не для управления логикой каждый день.

## См. также
- [Официальная документация по исключениям в C#](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/exceptions/exception-handling)
- [Лучшие практики обработки исключений в C#](https://docs.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions)
