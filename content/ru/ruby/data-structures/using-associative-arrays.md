---
aliases:
- /ru/ruby/using-associative-arrays/
changelog:
- 2024-01-30, gpt-4-0125-preview, translated from English
date: 2024-01-30 19:13:02.041430-07:00
description: "\u0410\u0441\u0441\u043E\u0446\u0438\u0430\u0442\u0438\u0432\u043D\u044B\
  \u0435 \u043C\u0430\u0441\u0441\u0438\u0432\u044B, \u0431\u043E\u043B\u0435\u0435\
  \ \u0438\u0437\u0432\u0435\u0441\u0442\u043D\u044B\u0435 \u0432 Ruby \u043A\u0430\
  \u043A \u0445\u0435\u0448\u0438, \u043F\u043E\u0437\u0432\u043E\u043B\u044F\u044E\
  \u0442 \u0441\u0432\u044F\u0437\u044B\u0432\u0430\u0442\u044C \u0443\u043D\u0438\
  \u043A\u0430\u043B\u044C\u043D\u044B\u0435 \u043A\u043B\u044E\u0447\u0438 \u0441\
  \u043E \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u044F\u043C\u0438. \u041E\u043D\
  \u0438 \u043D\u0435\u0437\u0430\u043C\u0435\u043D\u0438\u043C\u044B, \u043A\u043E\
  \u0433\u0434\u0430 \u043D\u0443\u0436\u043D\u043E \u043E\u0442\u0441\u043B\u0435\
  \u0436\u0438\u0432\u0430\u0442\u044C\u2026"
lastmod: 2024-02-18 23:08:57.608599
model: gpt-4-0125-preview
summary: "\u0410\u0441\u0441\u043E\u0446\u0438\u0430\u0442\u0438\u0432\u043D\u044B\
  \u0435 \u043C\u0430\u0441\u0441\u0438\u0432\u044B, \u0431\u043E\u043B\u0435\u0435\
  \ \u0438\u0437\u0432\u0435\u0441\u0442\u043D\u044B\u0435 \u0432 Ruby \u043A\u0430\
  \u043A \u0445\u0435\u0448\u0438, \u043F\u043E\u0437\u0432\u043E\u043B\u044F\u044E\
  \u0442 \u0441\u0432\u044F\u0437\u044B\u0432\u0430\u0442\u044C \u0443\u043D\u0438\
  \u043A\u0430\u043B\u044C\u043D\u044B\u0435 \u043A\u043B\u044E\u0447\u0438 \u0441\
  \u043E \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u044F\u043C\u0438. \u041E\u043D\
  \u0438 \u043D\u0435\u0437\u0430\u043C\u0435\u043D\u0438\u043C\u044B, \u043A\u043E\
  \u0433\u0434\u0430 \u043D\u0443\u0436\u043D\u043E \u043E\u0442\u0441\u043B\u0435\
  \u0436\u0438\u0432\u0430\u0442\u044C\u2026"
title: "\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u0435\
  \ \u0430\u0441\u0441\u043E\u0446\u0438\u0430\u0442\u0438\u0432\u043D\u044B\u0445\
  \ \u043C\u0430\u0441\u0441\u0438\u0432\u043E\u0432"
---

{{< edit_this_page >}}

## Что и почему?

Ассоциативные массивы, более известные в Ruby как хеши, позволяют связывать уникальные ключи со значениями. Они незаменимы, когда нужно отслеживать элементы через определенную ссылку, например, хранить свойства объекта или быстро получать доступ к данным по уникальному идентификатору.

## Как это сделать:

Создание и использование хешей в Ruby довольно простое. Вы можете инициализировать пустой хеш, заполнить его парами ключ-значение, получить доступ к значениям по их ключам и многое другое. Вот как это делается:

```Ruby
# Создание хеша
my_hash = { "name" => "John Doe", "age" => 30 }

# Другой способ создать хеш
another_hash = Hash.new
another_hash["position"] = "Разработчик"

# Доступ к значениям хеша
puts my_hash["name"] # Вывод: John Doe

# Добавление новой пары ключ-значение
my_hash["language"] = "Ruby"
puts my_hash # Вывод: {"name"=>"John Doe", "age"=>30, "language"=>"Ruby"}

# Итерация по хешу
my_hash.each do |key, value|
  puts "#{key}: #{value}"
end
# Вывод:
# name: John Doe
# age: 30
# language: Ruby
```

Вы также можете использовать символы в качестве более эффективных ключей:

```Ruby
# Использование символов для ключей
symbol_hash = { name: "Jane Doe", age: 22 }
puts symbol_hash[:name] # Вывод: Jane Doe
```

## Глубокое погружение:

Концепция ассоциативных массивов не уникальна для Ruby; многие языки реализуют их под различными названиями, например, словари в Python или объекты в JavaScript (когда используются как пары ключ-значение). На ранних этапах развития Ruby хеши были несколько медленнее и не так универсальны. Однако со временем реализация хешей в Ruby стала высокооптимизированной, особенно для ключей-символов, что делает их чрезвычайно эффективными для частого доступа и обновлений.

Хеши в Ruby выделяются своей синтаксической простотой использования и гибкостью - вы можете использовать практически любой тип объекта в качестве ключа, хотя наиболее распространены символы и строки. Внутри Ruby хеши реализованы с использованием алгоритма хеширования, который обеспечивает баланс между скоростью и эффективностью использования памяти, даже когда количество элементов увеличивается.

Несмотря на то что хеши невероятно универсальны, они не являются универсальным решением для хранения данных в Ruby. Для упорядоченных коллекций более подходящими являются массивы, а для набора уникальных элементов лучше использовать Set. Кроме того, для очень сложных структур данных может быть целесообразно создание пользовательских классов.

Помните, выбор использования хеша вместо других структур данных во многом зависит от конкретного случая использования — хеши отлично подходят для быстрых поисков и поддержания связей между уникальными ключами и их значениями.
