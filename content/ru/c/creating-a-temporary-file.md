---
title:                "Создание временного файла"
date:                  2024-01-28T23:57:21.741654-07:00
model:                 gpt-4-0125-preview
simple_title:         "Создание временного файла"

tag:                  "Files and I/O"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/ru/c/creating-a-temporary-file.md"
changelog:
  - 2024-01-28, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## Что и Зачем?
Создание временного файла в Си предоставляет вам черновик для обработки данных. Это способ хранения данных, которые вам нужны во время выполнения программы, но не после её завершения.

## Как это сделать:

В Си есть функции, такие как `tmpfile()` и `mkstemp()`, для создания временных файлов. Вот пример с использованием `tmpfile()`:

```c
#include <stdio.h>

int main() {
    FILE *temp = tmpfile();
    if (temp) {
        fputs("Записываем что-то временное.", temp);
        // Используем файл...
        rewind(temp); // Возвращаемся в начало, чтобы прочитать что мы записали.
        
        // Допустим, мы хотим это отобразить:
        char buffer[100];
        while (fgets(buffer, sizeof(buffer), temp) != NULL) {
            printf("%s", buffer);
        }
        // Закрыть и автоматически удалить при завершении программы
        fclose(temp);
    } else {
        perror("Ошибка выполнения tmpfile()");
    }

    return 0;
}
```
Пример вывода: `Записываем что-то временное.`

## Подробнее
Временные файлы существуют с зари современных операционных систем. Они удобны для обработки больших данных, которые не умещаются в памяти, для межпроцессного взаимодействия или для конфиденциальности (поскольку обычно удаляются при завершении программы).

`tmpfile()` создает уникальный временный файл в двоичном режиме чтения/записи (`w+b`). Файл автоматически удаляется, когда он закрывается или программа завершается. Только помните, поскольку файл открыт в двоичном режиме, если вы работаете с текстом, преобразования символов новой строки не будут обрабатываться автоматически.

Если вам нужен больший контроль, используйте `mkstemp()`. Она заменяет символы-шаблоны в вашем имени файла уникальной строкой, и вам нужно будет вручную удалить файл, когда закончите.

```c
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>

int main() {
    char template[] = "/tmp/mytemp.XXXXXX";
    int fd = mkstemp(template);
    if (fd == -1) {
        perror("Ошибка выполнения mkstemp()");
        exit(EXIT_FAILURE);
    }

    // Преобразуем файловый дескриптор в объект FILE
    FILE *temp = fdopen(fd, "w+");
    if (temp == NULL) {
        perror("Ошибка выполнения fdopen()");
        close(fd);
        exit(EXIT_FAILURE);
    }

    fputs("Вот это контроль над временными файлами.", temp);
    
    // Очистка: Закрыть и удалить вручную
    fclose(temp); 
    unlink(template); // Удалить файл

    return 0;
}
```
Пример вывода: (Явного вывода нет, но временный файл создается и удаляется)

Почему бы просто не создать свой собственный временный файл с помощью `fopen()`? Риск коллизии. Помните, `tmpfile()` и `mkstemp()` гарантируют уникальность имени файла, чтобы избежать конфликтов.

## См. также

- Документация стандартной библиотеки Си: https://en.cppreference.com/w/c/io
- Руководство по библиотеке GNU C для интерфейса файловой системы: https://www.gnu.org/software/libc/manual/html_node/File-System-Interface.html
- Безопасное программирование на Си и C++ для безопасной работы с файлами и данными: https://www.securecoding.cert.org
