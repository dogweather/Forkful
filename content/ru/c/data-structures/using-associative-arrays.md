---
title:                "Использование ассоциативных массивов"
date:                  2024-02-03T18:11:45.053394-07:00
model:                 gpt-4-0125-preview
simple_title:         "Использование ассоциативных массивов"
tag:                  "Data Structures"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/ru/c/using-associative-arrays.md"
changelog:
  - 2024-02-03, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## Что и почему?

Ассоциативные массивы, известные в других языках как карты или словари, являются парами ключ-значение, используемыми для эффективного поиска и манипуляции данными. В отличие от традиционных массивов, использующих индексы-целые числа, ассоциативные массивы используют ключи, что делает доступ к данным более интуитивно понятным и гибким для программистов.

## Как это сделать:

C не имеет встроенной поддержки ассоциативных массивов, как некоторые языки высокого уровня, но вы можете симулировать их, используя структуры и хеширование. Ниже приводится простой пример с использованием комбинации структуры и простой хеш-функции для реализации ассоциативного массива для хранения и доступа к целым числам по строковым ключам.

Сначала определите структуру для представления одной пары ключ-значение и другую для представления самого ассоциативного массива:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TABLE_SIZE 128

typedef struct {
    char* key;
    int value;
} KeyValuePair;

typedef struct {
    KeyValuePair* items[TABLE_SIZE];
} AssocArray;

unsigned int hash(char* key) {
    unsigned long int value = 0;
    unsigned int i = 0;
    unsigned int key_len = strlen(key);

    for (; i < key_len; ++i) {
        value = value * 37 + key[i];
    }

    value = value % TABLE_SIZE;

    return value;
}

void initArray(AssocArray* array) {
    for (int i = 0; i < TABLE_SIZE; ++i) {
        array->items[i] = NULL;
    }
}

void insert(AssocArray* array, char* key, int value) {
    unsigned int slot = hash(key);

    KeyValuePair* item = (KeyValuePair*)malloc(sizeof(KeyValuePair));
    item->key = strdup(key);
    item->value = value;

    array->items[slot] = item;
}

int find(AssocArray* array, char* key) {
    unsigned int slot = hash(key);

    if (array->items[slot]) {
        return array->items[slot]->value;
    }
    return -1;
}

int main() {
    AssocArray a;
    initArray(&a);

    insert(&a, "key1", 1);
    insert(&a, "key2", 2);

    printf("%d\n", find(&a, "key1")); // Выведет: 1
    printf("%d\n", find(&a, "key2")); // Выведет: 2

    return 0;
}
```

Этот пример демонстрирует основные операции: инициализация ассоциативного массива, вставка пар ключ-значение и поиск значений по ключам. Обратите внимание, что этот код не обрабатывает коллизии и предназначен для образовательных целей.

## Глубокое погружение

Концепция ассоциативных массивов предшествует языку C, но низкоуровневая природа языка не поддерживает их напрямую как встроенные типы. Это способствует более глубокому пониманию структур данных и алгоритмов, включая механизмы хеширования для эффективного сопоставления ключ-значение. Многие библиотеки и фреймворки C предлагают более сложные подходы к реализации ассоциативных массивов, такие как `GHashTable` от GLib, которая предоставляет устойчивую реализацию с обработкой коллизий, динамическим изменением размера и поддержкой произвольных типов ключей и значений.

Хотя ручное создание ассоциативных массивов в C может казаться более обременительным по сравнению с языками, имеющими встроенную поддержку, это предоставляет ценные взгляды на внутреннее устройство структур данных, улучшая навыки программиста в решении проблем и оптимизации. Однако для продуктового кода или более сложных приложений использование существующих библиотек, таких как GLib, часто является более практичным и экономящим время подходом.
