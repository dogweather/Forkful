---
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 18:12:04.718900-07:00
description: "\u0420\u0430\u0431\u043E\u0442\u0430 \u0441 JSON (JavaScript Object\
  \ Notation) \u043D\u0430 C \u0432\u043A\u043B\u044E\u0447\u0430\u0435\u0442 \u0432\
  \ \u0441\u0435\u0431\u044F \u0440\u0430\u0437\u0431\u043E\u0440, \u0433\u0435\u043D\
  \u0435\u0440\u0430\u0446\u0438\u044E \u0438 \u043C\u0430\u043D\u0438\u043F\u0443\
  \u043B\u044F\u0446\u0438\u044E \u0441\u0442\u0440\u0443\u043A\u0442\u0443\u0440\u0430\
  \u043C\u0438 \u0434\u0430\u043D\u043D\u044B\u0445 JSON. \u041F\u0440\u043E\u0433\
  \u0440\u0430\u043C\u043C\u0438\u0441\u0442\u044B \u0434\u0435\u043B\u0430\u044E\u0442\
  \ \u044D\u0442\u043E \u0434\u043B\u044F\u2026"
lastmod: '2024-03-13T22:44:45.956228-06:00'
model: gpt-4-0125-preview
summary: "\u0420\u0430\u0431\u043E\u0442\u0430 \u0441 JSON (JavaScript Object Notation)\
  \ \u043D\u0430 C \u0432\u043A\u043B\u044E\u0447\u0430\u0435\u0442 \u0432 \u0441\u0435\
  \u0431\u044F \u0440\u0430\u0437\u0431\u043E\u0440, \u0433\u0435\u043D\u0435\u0440\
  \u0430\u0446\u0438\u044E \u0438 \u043C\u0430\u043D\u0438\u043F\u0443\u043B\u044F\
  \u0446\u0438\u044E \u0441\u0442\u0440\u0443\u043A\u0442\u0443\u0440\u0430\u043C\u0438\
  \ \u0434\u0430\u043D\u043D\u044B\u0445 JSON."
title: "\u0420\u0430\u0431\u043E\u0442\u0430 \u0441 JSON"
weight: 38
---

## Как это сделать:
Для работы с JSON на C обычно используются библиотеки, такие как `jansson` или `json-c`, из-за отсутствия встроенной поддержки JSON в C. Здесь мы сосредоточимся на `jansson` из-за её простоты использования и активного обслуживания. Сначала установите библиотеку (например, с помощью менеджера пакетов `apt` на Ubuntu: `sudo apt-get install libjansson-dev`).

Начнем с разбора строки JSON и доступа к её содержимому:

```c
#include <jansson.h>
#include <stdio.h>

int main() {
    const char *json_string = "{\"name\":\"John Doe\",\"age\":30}";
    json_error_t error;
    json_t *root = json_loads(json_string, 0, &error);
    
    if(!root) {
        fprintf(stderr, "ошибка: в строке %d: %s\n", error.line, error.text);
        return 1;
    }
    
    const char *name;
    int age;
    json_unpack(root, "{s:s, s:i}", "name", &name, "age", &age);
    
    printf("Имя: %s\nВозраст: %d\n", name, age);
    
    json_decref(root);
    return 0;
}
```

Пример вывода:
```
Имя: John Doe
Возраст: 30
```

Далее, создание и вывод объекта JSON:

```c
#include <jansson.h>
#include <stdio.h>

int main() {
    json_t *root = json_object();
    json_object_set_new(root, "name", json_string("Jane Doe"));
    json_object_set_new(root, "age", json_integer(25));
    
    char *json_dump = json_dumps(root, JSON_ENCODE_ANY);
    printf("%s\n", json_dump);
    
    free(json_dump);
    json_decref(root);
    return 0;
}
```

Пример вывода:
```
{"name": "Jane Doe", "age": 25}
```

Эти примеры демонстрируют основы загрузки строки JSON, извлечения её значений, создания нового объекта JSON, а затем вывода его в виде строки.

## Углубление
Необходимость работы с JSON на C возникает из-за принятия вебом JSON в качестве основного формата для обмена данными. Простота и эффективность JSON быстро сделали его более предпочтительным, чем XML, несмотря на изначальное отсутствие прямой поддержки работы с JSON в C. Ранние решения включали в себя ручную манипуляцию строками - склонную к ошибкам и неэффективную. Библиотеки, такие как `jansson` и `json-c`, появились, чтобы заполнить этот пробел, предоставляя надежные API для разбора, создания и сериализации JSON.

Хотя `jansson` предлагает простоту и удобство использования, `json-c` может привлечь тех, кто ищет более широкий набор функций. Тем не менее, альтернативы, такие как библиотеки разбора на C++, предлагают более сложные абстракции благодаря более комплексным структурам данных и поддержке стандартной библиотеки этого языка. Однако, когда работа ведется в средах, где C является предпочтительным или необходимым языком - например, во встроенных системах или при взаимодействии с существующими библиотеками на C - использование `jansson` или `json-c` становится незаменимым.

Также стоит отметить, что работа с JSON на C требует более глубокого понимания управления памятью, поскольку эти библиотеки часто возвращают динамически выделенные объекты, требующие явного освобождения. Это ставит перед программистами задачу совместить удобство с ответственностью за предотвращение утечек памяти, ключевым аспектом создания эффективного кода на C.
