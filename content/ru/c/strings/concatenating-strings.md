---
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 17:54:02.501668-07:00
description: "\u041A\u043E\u043D\u043A\u0430\u0442\u0435\u043D\u0430\u0446\u0438\u044F\
  \ \u0441\u0442\u0440\u043E\u043A \u0432 C \u0437\u0430\u043A\u043B\u044E\u0447\u0430\
  \u0435\u0442\u0441\u044F \u0432 \u043E\u0431\u044A\u0435\u0434\u0438\u043D\u0435\
  \u043D\u0438\u0438 \u0434\u0432\u0443\u0445 \u0438\u043B\u0438 \u0431\u043E\u043B\
  \u0435\u0435 \u0441\u0442\u0440\u043E\u043A \u0432 \u043A\u043E\u043D\u0435\u0446\
  \ \u043A \u043A\u043E\u043D\u0446\u0443 \u0434\u043B\u044F \u0444\u043E\u0440\u043C\
  \u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F \u043D\u043E\u0432\u043E\u0439\
  \ \u0441\u0442\u0440\u043E\u043A\u0438. \u041F\u0440\u043E\u0433\u0440\u0430\u043C\
  \u043C\u0438\u0441\u0442\u044B \u0432\u044B\u043F\u043E\u043B\u043D\u044F\u044E\u0442\
  \ \u044D\u0442\u0443 \u043E\u043F\u0435\u0440\u0430\u0446\u0438\u044E\u2026"
lastmod: '2024-03-13T22:44:45.901772-06:00'
model: gpt-4-0125-preview
summary: "\u041A\u043E\u043D\u043A\u0430\u0442\u0435\u043D\u0430\u0446\u0438\u044F\
  \ \u0441\u0442\u0440\u043E\u043A \u0432 C \u0437\u0430\u043A\u043B\u044E\u0447\u0430\
  \u0435\u0442\u0441\u044F \u0432 \u043E\u0431\u044A\u0435\u0434\u0438\u043D\u0435\
  \u043D\u0438\u0438 \u0434\u0432\u0443\u0445 \u0438\u043B\u0438 \u0431\u043E\u043B\
  \u0435\u0435 \u0441\u0442\u0440\u043E\u043A \u0432 \u043A\u043E\u043D\u0435\u0446\
  \ \u043A \u043A\u043E\u043D\u0446\u0443 \u0434\u043B\u044F \u0444\u043E\u0440\u043C\
  \u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F \u043D\u043E\u0432\u043E\u0439\
  \ \u0441\u0442\u0440\u043E\u043A\u0438."
title: "\u0421\u0446\u0435\u043F\u043B\u0435\u043D\u0438\u0435 \u0441\u0442\u0440\u043E\
  \u043A"
weight: 3
---

## Как это сделать:
В C строки – это массивы символов, заканчивающиеся нулевым символом (`\0`). В отличие от высокоуровневых языков, C не предоставляет встроенной функции конкатенации строк. Вместо этого вы используете функции `strcat()` или `strncat()` из библиотеки `<string.h>`.

Вот простой пример с использованием `strcat()`:

```c
#include <stdio.h>
#include <string.h>

int main() {
    char destination[50] = "Hello, ";
    char source[] = "World!";

    strcat(destination, source);

    printf("%s\n", destination);  // Вывод: Hello, World!
    return 0;
}
```

Функция `strcat()` принимает два аргумента: строку назначения (которая должна иметь достаточно места для хранения результата конкатенации) и исходную строку. Она добавляет исходную строку к строке назначения.

Для более точного контроля над количеством конкатенируемых символов безопаснее использовать `strncat()`:

```c
#include <stdio.h>
#include <string.h>

int main() {
    char destination[50] = "Hello, ";
    char source[] = "World!";
    int num = 3; // Количество добавляемых символов

    strncat(destination, source, num);

    printf("%s\n", destination);  // Вывод: Hello, Wor
    return 0;
}
```

Это ограничивает конкатенацию первыми `num` символами исходной строки, помогая предотвратить переполнение буфера.

## Более глубокое погружение
Функции `strcat()` и `strncat()` были частью стандартной библиотеки C с момента её создания, отражая низкоуровневый характер языка, который требует ручного управления строками и памятью. В отличие от многих современных языков программирования, которые рассматривают строки как объекты первого класса с встроенными операторами конкатенации (такими как `+` или `.concat()`), подход C требует более глубокого понимания указателей, выделения памяти и потенциальных подводных камней, таких как переполнение буфера.

Несмотря на то что `strcat()` и `strncat()` широко используются, их часто критикуют за потенциальную возможность создания уязвимостей безопасности, если их использовать неосторожно. Переполнения буфера, при которых данные превышают выделенную память, могут привести к сбоям или быть использованы для выполнения произвольного кода. В результате программисты всё чаще обращаются к более безопасным альтернативам, таким как `snprintf()`, которая обеспечивает более предсказуемое поведение, ограничивая количество символов, записываемых в строку назначения, на основе её размера:

```c
char destination[50] = "Hello, ";
char source[] = "World!";
snprintf(destination + strlen(destination), sizeof(destination) - strlen(destination), "%s", source);
```

Этот метод более громоздкий, но значительно безопаснее, подчеркивая сдвиг в практиках программирования на C в сторону приоритета безопасности и надежности перед краткостью.

Несмотря на эти вызовы, конкатенация строк в C является основным навыком, критически важным для эффективного программирования на языке. Понимание её нюансов и связанных с ней рисков ключевое для овладения программированием на C.
