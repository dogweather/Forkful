---
title:                "Using associative arrays"
date:                  2024-02-03T17:50:04.917595-07:00
model:                 gpt-4-0125-preview
simple_title:         "Using associative arrays"
tag:                  "Data Structures"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/en/go/using-associative-arrays.md"
---

{{< edit_this_page >}}

## What & Why?

Associative arrays, known as maps in Go, enable you to store key-value pairs where each unique key maps to a value. Programmers use maps for efficient data retrieval, modification, and to maintain a collection of elements that can be quickly accessed using unique keys.

## How to:

Creating and initializing a map in Go can be done in various ways. Here's a basic example to get you started:

```go
package main

import "fmt"

func main() {
    // Declaring and initializing a map
    colors := map[string]string{
        "red":   "#FF0000",
        "green": "#00FF00",
        "blue":  "#0000FF",
    }

    fmt.Println(colors)
    // Output: map[blue:#0000FF green:#00FF00 red:#FF0000]
}
```

To add or update elements, you assign a value to a key like so:

```go
colors["white"] = "#FFFFFF"
fmt.Println(colors)
// Output: map[blue:#0000FF green:#00FF00 red:#FF0000 white:#FFFFFF]
```

Accessing a value by its key is straightforward:

```go
fmt.Println("The hex code for red is:", colors["red"])
// Output: The hex code for red is: #FF0000
```

To delete an element, use the `delete` function:

```go
delete(colors, "red")
fmt.Println(colors)
// Output: map[blue:#0000FF green:#00FF00 white:#FFFFFF]
```

Iterating over a map is done using a for loop:

```go
for color, hex := range colors {
    fmt.Printf("Key: %s Value: %s\n", color, hex)
}
```

Remember, maps in Go are unordered. The order of iteration is not guaranteed.

## Deep Dive

In Go, maps are implemented as hash tables. Each entry in the map consists of two items: a key and a value. The key is hashed to store the entry, which allows for constant time operations for a small set of data and average time complexity of O(1) with proper hashing, which can degrade to O(n) in the worst case with many hash collisions.

A significant note for new Go programmers is that map types are reference types. This means when you pass a map to a function, any changes made to the map within that function are visible to the caller. This is different from, say, passing a struct to a function, where the struct is copied unless passed by a pointer.

While maps are incredibly versatile and efficient for most use cases involving associative arrays, in performance-critical applications, it may be beneficial to use data structures with more predictable performance characteristics, especially if key distributions can cause frequent collisions.

Another alternative to consider is the `sync.Map`, available since Go 1.9, designed for use cases where keys are only written once but read many times, offering efficiency improvements in these scenarios. However, for conventional Go applications, regular map usage is idiomatic and often the recommended approach for its simplicity and direct support in the language.
