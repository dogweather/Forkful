---
aliases:
- /ja/c/printing-debug-output/
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 18:05:26.792479-07:00
description: "\u30C7\u30D0\u30C3\u30B0\u51FA\u529B\u3092\u5370\u5237\u3059\u308B\u3068\
  \u306F\u3001\u30D7\u30ED\u30B0\u30E9\u30E0\u306E\u5B9F\u884C\u4E2D\u306B\u30D7\u30ED\
  \u30B0\u30E9\u30E0\u306E\u30D5\u30ED\u30FC\u3068\u72B6\u614B\u3092\u7406\u89E3\u3059\
  \u308B\u306E\u306B\u5F79\u7ACB\u3064\u4E00\u6642\u7684\u306A\u60C5\u5831\u30ED\u30B0\
  \u30E1\u30C3\u30BB\u30FC\u30B8\u3092\u751F\u6210\u3059\u308B\u3053\u3068\u3067\u3059\
  \u3002\u30D7\u30ED\u30B0\u30E9\u30DE\u30FC\u306F\u3001\u30BD\u30D5\u30C8\u30A6\u30A7\
  \u30A2\u30D0\u30B0\u3084\u30D7\u30ED\u30B0\u30E9\u30E0\u306E\u30ED\u30B8\u30C3\u30AF\
  \u306B\u304A\u3051\u308B\u4E88\u671F\u3057\u306A\u3044\u52D5\u4F5C\u3092\u7279\u5B9A\
  \u3057\u3001\u8A3A\u65AD\u3059\u308B\u305F\u3081\u306B\u3053\u308C\u3092\u884C\u3044\
  \u307E\u3059\u3002"
lastmod: 2024-02-18 23:08:55.352117
model: gpt-4-0125-preview
summary: "\u30C7\u30D0\u30C3\u30B0\u51FA\u529B\u3092\u5370\u5237\u3059\u308B\u3068\
  \u306F\u3001\u30D7\u30ED\u30B0\u30E9\u30E0\u306E\u5B9F\u884C\u4E2D\u306B\u30D7\u30ED\
  \u30B0\u30E9\u30E0\u306E\u30D5\u30ED\u30FC\u3068\u72B6\u614B\u3092\u7406\u89E3\u3059\
  \u308B\u306E\u306B\u5F79\u7ACB\u3064\u4E00\u6642\u7684\u306A\u60C5\u5831\u30ED\u30B0\
  \u30E1\u30C3\u30BB\u30FC\u30B8\u3092\u751F\u6210\u3059\u308B\u3053\u3068\u3067\u3059\
  \u3002\u30D7\u30ED\u30B0\u30E9\u30DE\u30FC\u306F\u3001\u30BD\u30D5\u30C8\u30A6\u30A7\
  \u30A2\u30D0\u30B0\u3084\u30D7\u30ED\u30B0\u30E9\u30E0\u306E\u30ED\u30B8\u30C3\u30AF\
  \u306B\u304A\u3051\u308B\u4E88\u671F\u3057\u306A\u3044\u52D5\u4F5C\u3092\u7279\u5B9A\
  \u3057\u3001\u8A3A\u65AD\u3059\u308B\u305F\u3081\u306B\u3053\u308C\u3092\u884C\u3044\
  \u307E\u3059\u3002"
title: "\u30C7\u30D0\u30C3\u30B0\u51FA\u529B\u306E\u5370\u5237"
---

{{< edit_this_page >}}

## 何となぜ？

デバッグ出力を印刷するとは、プログラムの実行中にプログラムのフローと状態を理解するのに役立つ一時的な情報ログメッセージを生成することです。プログラマーは、ソフトウェアバグやプログラムのロジックにおける予期しない動作を特定し、診断するためにこれを行います。

## 方法：

C では、デバッグ出力を印刷する最も一般的な方法は、標準 I/O ライブラリから `printf` 関数を使用することです。`printf` 関数は、通常は画面である標準出力デバイスに対してフォーマットされた出力を可能にします。以下は簡単な例です：

```c
#include <stdio.h>

int main() {
    int x = 5;
    printf("デバッグ: x の値は %d\n", x);
    
    // ここにプログラムロジック
    
    return 0;
}
```

サンプル出力：

```
デバッグ: x の値は 5
```

より洗練されたデバッグ印刷には、ファイル名と行番号の情報を含めることが望ましいかもしれません。これは `__FILE__` と `__LINE__` の事前定義マクロを使用して次のように行うことができます：

```c
#define DEBUG_PRINT(fmt, args...) fprintf(stderr, "DEBUG: %s:%d: " fmt, __FILE__, __LINE__, ##args)

int main() {
    int testValue = 10;
    DEBUG_PRINT("テスト値は %d\n", testValue);
    
    // ここにプログラムロジック
    
    return 0;
}
```

サンプル出力：

```
DEBUG: example.c:6: テスト値は 10
```

この例では、標準エラーストリーム (`stderr`) に出力するために `fprintf` を使用していますが、これはデバッグメッセージにはより適していることが多いです。

## 深く掘り下げる

歴史的に、C のデバッグ手法は、言語の金属に近い哲学と年齢のため、手動で基本的なものでした。現代の言語が洗練された組み込みのデバッグライブラリを含むか、統合開発環境（IDE）の機能に大きく依存する可能性があるのに対し、C プログラマーは、上で示したようなプリントステートメントを手動で挿入することによって、プログラムの実行を追跡することがよくあります。

デバッグプリントに関して注意すべき一つのことは、出力を散らかしたり、特に本番コードに意図せず残った場合はパフォーマンス問題につながる可能性があることです。これらの理由から、条件付きコンパイル（例：`#ifdef DEBUG ... #endif`）を使用する方がよいアプローチかもしれません。これにより、コンパイル時のフラグに基づいてデバッグステートメントを含めたり除外したりすることができます。

さらに、GDB（GNU デバッガー）やメモリリーク検出のための Valgrind など、C デバッグのためのより高度なツールやライブラリが現在では利用可能です。これらのツールは、プリントステートメントを挿入することによるコードの変更なしに、より統合的なアプローチをデバッグに提供します。

それでも、`printf` デバッグのシンプルさと即時性は過小評価できず、C の複雑さを学び始めたばかりの人々にとって特に有用なツールとなっています。
