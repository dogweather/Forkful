---
title:                "乱数の生成"
aliases:
- ja/c/generating-random-numbers.md
date:                  2024-02-03T17:57:21.812667-07:00
model:                 gpt-4-0125-preview
simple_title:         "乱数の生成"
tag:                  "Numbers"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/ja/c/generating-random-numbers.md"
changelog:
  - 2024-02-03, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## 何となぜ?

C言語で乱数を生成することは、予測不可能な値を生成し、一様または正規などの特定の分布に従うことを含みます。この能力は、シミュレーションやゲームから暗号化操作に至るまで、予測不可能性または実世界のランダム性のシミュレーションが不可欠なアプリケーションにとって重要です。

## 方法:

C言語では、標準ライブラリ`<stdlib.h>`の一部である`rand()`関数を使用して乱数を生成できます。デフォルトでは、`rand()`は0から`RAND_MAX`（`<stdlib.h>`で定義された定数）の範囲の疑似乱数を生成します。範囲をより細かく制御するために、プログラマーは`rand()`の出力を操作できます。

ここに0から99の間の乱数を生成する簡単な例を示します:

```c
#include <stdio.h>
#include <stdlib.h> // rand()とsrand()用
#include <time.h>   // time()用

int main() {
    // 乱数生成器にシードを提供
    srand((unsigned) time(NULL));

    // 0から99の間の乱数を生成
    int randomNumber = rand() % 100;

    printf("Random Number: %d\n", randomNumber);

    return 0;
}
```

このプログラムを実行するたびに、出力例は異なる可能性があります:

```
Random Number: 42
```
異なる範囲内で乱数を生成するために、モジュラス演算子(`%`)を適宜調整できます。たとえば、`rand() % 10`は0から9までの数を生成します。

疑似乱数生成器を現在時刻(`time(NULL)`)でシード化する(`srand()`呼び出し)ことは、プログラムの実行ごとに異なる乱数のシーケンスを保証することを意味していることが重要です。シード化(`srand()`)せずに、`rand()`を使うと、プログラムを実行するたびに同じ数値のシーケンスを生成します。

## 深い分析

`rand()`関数とそのシード化の対応`srand()`は数十年に渡ってC標準ライブラリの一部です。これらは、ランダムであるように見える数値のシーケンスを生成するアルゴリズムに基づいています。これが「疑似ランダム」という用語の由来です。`rand()`内の基本アルゴリズムは通常、線形合同生成器（LCG）です。

`rand()`と`srand()`は多くのアプリケーションにとって十分ですが、ランダム性の質や予測可能性に関して既知の制限があります。暗号化操作など、高品質のランダム性を要求するアプリケーションの場合、`/dev/random`や`/dev/urandom`（Unix系システム上）、または暗号ライブラリが提供するAPIなどの代替手段が検討されるべきです。

C11の導入により、ISO C標準は同時操作のより洗練された制御を提供する新しいヘッダー`<stdatomic.h>`を含みましたが、これはランダム性に直接関連するものではありません。C言語で真のランダム性を求める場合、開発者はしばしば、より良いアルゴリズムを提供したり、ハードウェアのエントロピーソースを利用したりするプラットフォーム固有または外部のライブラリに目を向けます。

`rand()`は疑似乱数を生成するためのシンプルでアクセスしやすい手段として機能しますが、その出力の質と予測可能性により、現代のアプリケーションでの使用は限定されています。特にセキュリティ意識の高いアプリケーションにおいて、より堅牢なソリューションが求められる場合、標準ライブラリを超えて探求することが強く推奨されます。
