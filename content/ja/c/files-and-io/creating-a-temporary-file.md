---
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 17:55:39.876707-07:00
description: "\u2026"
lastmod: '2024-03-13T22:44:42.821514-06:00'
model: gpt-4-0125-preview
summary: "C\u8A00\u8A9E\u3067\u4E00\u6642\u30D5\u30A1\u30A4\u30EB\u3092\u4F5C\u6210\
  \u3059\u308B\u3053\u3068\u306F\u3001\u77ED\u671F\u9593\u4F7F\u7528\u3059\u308B\u305F\
  \u3081\u306B\u751F\u6210\u3055\u308C\u308B\u30D5\u30A1\u30A4\u30EB\u3067\u3042\u308A\
  \u3001\u901A\u5E38\u306F\u30C7\u30FC\u30BF\u51E6\u7406\u3084\u30B9\u30C8\u30EC\u30FC\
  \u30B8\u306E\u30B9\u30AF\u30E9\u30C3\u30C1\u30B9\u30DA\u30FC\u30B9\u3068\u3057\u3066\
  \u4F7F\u308F\u308C\u307E\u3059\u3002\u30D7\u30ED\u30B0\u30E9\u30DE\u30FC\u306F\u3001\
  \u30D7\u30ED\u30B0\u30E9\u30E0\u306E\u6C38\u7D9A\u7684\u306A\u30B9\u30C8\u30EC\u30FC\
  \u30B8\u306B\u5F71\u97FF\u3092\u4E0E\u3048\u305A\u306B\u4E00\u6642\u7684\u306A\u30C7\
  \u30FC\u30BF\u3092\u7BA1\u7406\u3059\u308B\u305F\u3081\u3001\u307E\u305F\u306F\u4F7F\
  \u7528\u5F8C\u306B\u6A5F\u5BC6\u30C7\u30FC\u30BF\u304C\u6D88\u53BB\u3055\u308C\u308B\
  \u3053\u3068\u3092\u4FDD\u8A3C\u3059\u308B\u305F\u3081\u306B\u3053\u308C\u3092\u884C\
  \u3044\u307E\u3059\u3002."
title: "\u4E00\u6642\u30D5\u30A1\u30A4\u30EB\u306E\u4F5C\u6210"
weight: 21
---

## 方法：
C言語で一時ファイルを作成するためには、`tmpfile()`や`mkstemp()`などの関数を利用できます。

**`tmpfile()`の使用：** この関数は、プログラムが終了する際やファイルが閉じられる際に自動的に削除される一意の一時ファイルを作成します。

```c
#include <stdio.h>

int main() {
    FILE *temp = tmpfile();
    if (temp == NULL) {
        perror("一時ファイルの作成に失敗");
        return 1;
    }

    // 一時ファイルへのデータ書き込み
    fputs("これはテストです。\n", temp);

    // 書き込んだ内容をリワインドして読み取る
    rewind(temp);
    char buffer[1024];
    while (fgets(buffer, sizeof(buffer), temp) != NULL) {
        printf("%s", buffer);
    }

    // 閉じるかプログラムが終了すると自動的に削除
    fclose(temp);

    return 0;
}
```
**サンプル出力：**
```
これはテストです。
```

**`mkstemp()`の使用：** 一時ファイルの場所やその権限についてより多くの制御を提供します。`XXXXXX`で終わるテンプレート文字列が必要で、それを一意のシーケンスに置き換えて名前の衝突を防ぎます。

```c
#include <unistd.h>
#include <stdio.h>
#include <fcntl.h>

int main() {
    char template[] = "/tmp/mytemp-XXXXXX";
    int fd = mkstemp(template);

    if (fd == -1) {
        perror("一時ファイルの作成に失敗");
        return 1;
    }
    
    printf("一時ファイルが作成されました: %s\n", template);

    // mkstemp()で作成された一時ファイルは手動で削除する必要があります
    unlink(template);

    close(fd);
    return 0;
}
```
**サンプル出力：**
```
一時ファイルが作成されました: /tmp/mytemp-abc123
```

## 深い潜水
一時ファイルの概念はCに特有のものではなく、その実用性のために多くのプログラミング環境で一般的な機能です。ISO C標準で規格化された`tmpfile()`関数は、標準ディレクトリに一意の名前のファイルを作成しますが、その存在ははかなく、セキュアまたは一時的な操作に理想的です。

`tmpfile()`の特筆すべき制限の一つは、デフォルトの一時ディレクトリに依存していることで、特に権限やセキュリティの観点からすべてのアプリケーションに適しているわけではありません。対照的に、`mkstemp()`はディレクトリを指定でき、提供されたテンプレート文字列を変更することで、一意のファイル名のセキュアなファイル作成を保証し、手動ファイル管理の犠牲を払ってより多用途なソリューションを提供します。

しかし、一時ファイルの作成は、適切に扱われない場合には、レースコンディションなどのセキュリティ脆弱性を導入する可能性があります。たとえば、`tmpfile()`と`mkstemp()`は、セキュアな一時ファイル作成の異なる側面（自動削除とセキュアな名前生成、それぞれ）に対処しますが、どちらも万能薬ではありません。開発者は、一時ファイルによって導入される可能性のある脆弱性を含む、アプリケーションのセキュリティ要件の詳細を考慮し、これらの関数が提供するものを超えて追加の保護措置を実装する必要があります。

プログラミングの広い景観で、一時データ処理においてパフォーマンスやセキュリティを向上させるために代替手段（例えば、動的データ構造やメモリマップトファイルを使用する）が提案されています。それにもかかわらず、物理的な一時ファイルは大規模なデータセットを扱う場合やプロセス間通信が関与する場合など、多くのシナリオで極めて重要なツールのままです。
