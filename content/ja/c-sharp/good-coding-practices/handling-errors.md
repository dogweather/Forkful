---
aliases:
- /ja/c-sharp/handling-errors/
date: 2024-01-26 00:52:59.048461-07:00
description: "C#\u3067\u306E\u30A8\u30E9\u30FC\u51E6\u7406\u306F\u3001\u4E88\u671F\
  \u3057\u306A\u3044\u554F\u984C\u3092\u7BA1\u7406\u3059\u308B\u3053\u3068\u306B\u3064\
  \u3044\u3066\u3067\u3059\u2014\u4F8B\u3048\u3070\u3001\u81EA\u5206\u306E\u9774\u7D10\
  \u306B\u3064\u307E\u305A\u304F\u3088\u3046\u306A\u3053\u3068\u3002\u30D7\u30ED\u30B0\
  \u30E9\u30E0\u306F\u4E0D\u6B63\u306A\u30C7\u30FC\u30BF\u3084\u4E0D\u5B89\u5B9A\u306A\
  \u63A5\u7D9A\u3067\u3064\u307E\u305A\u304F\u3053\u3068\u304C\u3042\u308A\u307E\u3059\
  \u3002\u30A8\u30E9\u30FC\u3092\u51E6\u7406\u3059\u308B\u3053\u3068\u3067\u3001\u30BD\
  \u30D5\u30C8\u30A6\u30A7\u30A2\u304C\u9854\u9762\u304B\u3089\u8EE2\u3076\u306E\u3092\
  \u9632\u304E\u3001\u512A\u96C5\u306B\u56DE\u5FA9\u3055\u305B\u307E\u3059\u3002"
lastmod: 2024-02-18 23:08:54.924610
model: gpt-4-1106-preview
summary: "C#\u3067\u306E\u30A8\u30E9\u30FC\u51E6\u7406\u306F\u3001\u4E88\u671F\u3057\
  \u306A\u3044\u554F\u984C\u3092\u7BA1\u7406\u3059\u308B\u3053\u3068\u306B\u3064\u3044\
  \u3066\u3067\u3059\u2014\u4F8B\u3048\u3070\u3001\u81EA\u5206\u306E\u9774\u7D10\u306B\
  \u3064\u307E\u305A\u304F\u3088\u3046\u306A\u3053\u3068\u3002\u30D7\u30ED\u30B0\u30E9\
  \u30E0\u306F\u4E0D\u6B63\u306A\u30C7\u30FC\u30BF\u3084\u4E0D\u5B89\u5B9A\u306A\u63A5\
  \u7D9A\u3067\u3064\u307E\u305A\u304F\u3053\u3068\u304C\u3042\u308A\u307E\u3059\u3002\
  \u30A8\u30E9\u30FC\u3092\u51E6\u7406\u3059\u308B\u3053\u3068\u3067\u3001\u30BD\u30D5\
  \u30C8\u30A6\u30A7\u30A2\u304C\u9854\u9762\u304B\u3089\u8EE2\u3076\u306E\u3092\u9632\
  \u304E\u3001\u512A\u96C5\u306B\u56DE\u5FA9\u3055\u305B\u307E\u3059\u3002"
title: "\u30A8\u30E9\u30FC\u51E6\u7406"
---

{{< edit_this_page >}}

## 何となぜ?

C#でのエラー処理は、予期しない問題を管理することについてです—例えば、自分の靴紐につまずくようなこと。プログラムは不正なデータや不安定な接続でつまずくことがあります。エラーを処理することで、ソフトウェアが顔面から転ぶのを防ぎ、優雅に回復させます。

## どのようにして:

try-catchブロックから始めましょう。これは、綱渡り芸人の下に安全網を張るようなものです。彼らが滑った場合に、墜落することなく捕まえられるのです。

```C#
using System;

class ErrorHandlingExample {
    static void Main() {
        try {
            int[] numbers = {1, 2, 3};
            Console.WriteLine(numbers[5]);  // おっと、インデックスが範囲外です！
        } catch (IndexOutOfRangeException e) {
            Console.WriteLine("エラーを捕捉: " + e.Message);
        }
    }
}
```

物事がうまくいかない時のサンプル出力：
```
エラーを捕捉: インデックスは配列の範囲外でした。
```

次に、finallyブロックを追加します—これは何があっても実行されるもので、例えば税金を支払うことに似ています。

```C#
try {
    // ここに問題を起こす可能性のあるコード
} catch (SomeSpecificException e) {
    // ここでその特定のエラーを処理
} finally {
    // 上記で何が起ころうとこのコードは実行される
    Console.WriteLine("これは必ず実行されます。");
}
```

## 深掘り

エラー処理はC#が誕生して以来取り入れられています。時間とともに進化してきました。昔のプログラマは、問題を知らせるために戻り値やグローバルフラグに頼っていました—使い勝手が悪く、エラーが発生しやすい方法です。

C#は例外という、より現代的なアプローチを使用します。予期しない事態が発生したときに例外が投げられます。これは、フットボールでプレー中にフラグを投げるようなものです。try、catch、finallyブロックで構成される構造化例外処理は、古いスタイルのエラーチェックに比べて、これらの瞬間をクリアかつクリーンに管理することを可能にしています。

代替手段はありますか？もちろんです。例外がすり抜けた場合の`UnhandledExceptionEventHandler`や、非同期コードでは例外が含まれる`Task`オブジェクトを使ったエラー処理があります。

実装の詳細—細かい文字通りに言えば—は重要です。例外はコストがかかる可能性があり、安易に投げられるとパフォーマンスが低下する可能性があります。そのため、我々は毎日のロジック制御ではなく、例外的なケースに対してそれを使用します。

## 関連項目

- [C# における例外の公式ドキュメント](https://docs.microsoft.com/ja-jp/dotnet/csharp/fundamentals/exceptions/exception-handling)
- [C# 例外処理のベストプラクティス](https://docs.microsoft.com/ja-jp/dotnet/standard/exceptions/best-practices-for-exceptions)
