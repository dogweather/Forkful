---
title:                "ロギング"
date:                  2024-01-26T01:04:23.278772-07:00
model:                 gpt-4-1106-preview
simple_title:         "ロギング"
programming_language: "Gleam"
category:             "Gleam"
tag:                  "Good Coding Practices"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/ja/gleam/logging.md"
---

{{< edit_this_page >}}

## 何となく？
ログは、私たちのプログラムで何が起こっているのかを記録する方法です。まるで小さなブラックボックスのようなものです。ものごとが間違っている時（そして信じてください、必ずそうなります）、ログは何が起こったのかを解明し、問題を診断し、パフォーマンスを最適化するために非常に価値があります。

## 方法：
Gleamでは、典型的にはログ記録用のライブラリを取り込むことになります—専用のログ記録メカニズムは箱から出してすぐには使うことはできません。仮に `gleam_logger` クレートを使用しているとしましょう。こうやって統合することができます：

```gleam
import gleam_logger

pub fn main() {
  gleam_logger.info("アプリが起動中です！")
  let result = intense_calculation()

  case result {
    Ok(value) -> 
      gleam_logger.debug("計算が成功しました", value)
    Error(err) -> 
      gleam_logger.error("計算が失敗しました", err)
  }
}
```

ログ出力の想定される出力は以下のようになるでしょう：

```
INFO: アプリが起動中です！
DEBUG: 計算が成功しました 42
ERROR: 計算が失敗しました 理由：ゼロ除算
```

## 深堀り
ログのアートはプログラミングの初期段階から存在しています。システムオペレーターは文字通りコンピュータからログを取得していました—すべてがスムーズに実行されていることを確認するために。時を経て、ログはデジタル化され、ソフトウェア開発の中核の一部となりました。

Gleamは、比較的新しい言語であり、Erlangエコシステムを対象としているため、組み込みのログフレームワークはありませんが、成熟したErlangのログ設備やその他のコミュニティ提供のライブラリを活用することができます。それぞれ異なる機能とトレードオフを持っています：あるものは構造化ログを提供するかもしれませんし、他のものは単純なテキスト出力のためのものかもしれません。

では、ログ施設を実装するという問題ですが、それは簡単でしょうか？一見すると、はい。しかし、層を剥がしていくと、同時実行処理、I/Oのボトルネック、ログローテーション、フォーマットの標準化（構造化ログではJSONを考える）、レベルフィルタリング、そしておそらく分散トレーシングを扱うことになります。さらに、関数型パラダイムでは、副作用（ログ記録など）を予測可能かつコントロールされた方法で扱いたいと一般に考えられています。

## 関連情報
以下はGleamとその周辺エコシステムでのログの細かな部分について詳しく知るためのリソースです：
- [Erlangの:loggerドキュメント](http://erlang.org/doc/apps/kernel/logger_chapter.html): GleamはErlangにコンパイルされるため、これは直接適用されます。
- [Gleamの標準ライブラリドキュメント](https://hexdocs.pm/gleam_stdlib/): 何かログユーティリティが追加された際のアップデート情報。
- [Awesome Gleam](https://github.com/gleam-lang/awesome-gleam): リソースのキュレーションされたリストで、ログライブラリも利用可能になると含まれるかもしれません。