---
title:                "文字列の長さを求める"
date:                  2024-02-03T17:57:02.561631-07:00
model:                 gpt-4-0125-preview
simple_title:         "文字列の長さを求める"
tag:                  "Strings"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/ja/go/finding-the-length-of-a-string.md"
changelog:
  - 2024-02-03, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## 何となぜ？
Goで文字列の長さを見つけるとは、その含む文字の数を決定することです。プログラマーは、検証、部分文字列の抽出、または単にユーザー入力で制約を強制するために、この操作を定期的に実行します。

## 方法：
Goでは、文字列は不変のバイトシーケンスとして扱われます。`len()`組み込み関数を使用して文字列の長さを見つけることができます。これはバイト数を返しますが、必ずしも文字の数を返すわけではありません。使用方法は以下の通りです：

```go
package main

import (
	"fmt"
	"unicode/utf8"
)

func main() {
	// len() を使用してバイト長を見つける
	str := "Hello, 世界"
	byteLength := len(str)
	fmt.Println("Byte Length:", byteLength) // 出力: Byte Length: 13

	// 文字列内の文字数またはルーンの正確な数を取得する
	runeLength := utf8.RuneCountInString(str)
	fmt.Println("Rune Length:", runeLength) // 出力: Rune Length: 9
}
```
最初の方法である `len()` を使用すると、バイト数を数えるため、常に期待される結果が得られるとは限りません。非ASCII文字（"世界" のような）を含む文字列の場合、Unicodeコードポイントを正確に数えるために `unicode/utf8` パッケージからの `RuneCountInString` を代わりに使用するべきです。

## 詳細な解析
Go 1以前は、バイトのシーケンスとしての文字列と、文字のシーケンスとしての文字列を扱うための厳格な区切りがありませんでした。Go 1以降、文字列の標準エンコーディングスキームとしてUTF-8を採用したことにより、より明確なアプローチが必要になりました。`len()`関数は、文字が単一バイトで表されるASCII文字列には完璧に機能します。しかし、Goアプリケーションがよりグローバルになるにつれて、さまざまな言語や文字セットをサポートする必要性が高まると、`len()`の単純なアプローチでは限界がありました。

`utf8.RuneCountInString()`の導入と使用は、これらの制限に対する回答を提供し、実際のUnicode文字（Go用語ではルーン）を数える方法を提供します。この方法は、複数のバイトにまたがる可能性があるUTF-8のエンコーディングの詳細に依存しない、長さの計算を保証します。

文字列をルーンのスライスとして扱う、Goの並行性と効率の精神により一致する別のアプローチが、文字列の走査や操作に関与するかもしれません。しかし、この方法は変換ステップを必要とし、Unicodeの複雑さ（例えば、結合文字）のすべてを即座に解決するわけではありません。

要約すると、`len()`はバイト長に適しており、ASCIIテキストに対して効率的ですが、`utf8.RuneCountInString()`はグローバルに互換性のあるアプリケーションに対してより信頼性の高い選択肢です。それでも、開発者には、これらの選択肢が伴うパフォーマンスとメモリ使用のトレードオフを理解することが推奨されます。
