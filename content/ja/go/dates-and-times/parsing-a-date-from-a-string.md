---
changelog:
- 2024-02-03, gpt-4-0125-preview, translated from English
date: 2024-02-03 18:05:30.438349-07:00
description: "\u2026"
lastmod: '2024-03-13T22:44:41.400766-06:00'
model: gpt-4-0125-preview
summary: "Go\u3067\u6587\u5B57\u5217\u304B\u3089\u65E5\u4ED8\u3092\u89E3\u6790\u3059\
  \u308B\u3053\u3068\u306F\u3001\u30C6\u30AD\u30B9\u30C8\u3068\u3057\u3066\u8868\u3055\
  \u308C\u305F\u65E5\u4ED8\u3092\u3088\u308A\u4F7F\u3044\u3084\u3059\u3044\u5F62\u5F0F\
  \uFF08\u4F8B\uFF1A`time."
title: "\u6587\u5B57\u5217\u304B\u3089\u306E\u65E5\u4ED8\u306E\u89E3\u6790"
weight: 30
---

## どのようにして：
Goは`time`パッケージを通して日付と時間の解析に対する強力なサポートを提供します。キーは、Goの基準日付形式：`Mon Jan 2 15:04:05 MST 2006`を理解することで、これを使用してGoに入ってくる文字列の解釈方法を指示します。始めるための簡単な例をここに示します:

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	// 例の日付文字列
	dateStr := "2023-04-12 14:45:00"
	
	// 入力日付文字列のレイアウト/形式を定義
	// このレイアウトは、Goに対して年に続いて月、
	// 次に日、時、分、最後に秒を期待するよう告げます
	layout := "2006-01-02 15:04:05"
	
	// レイアウトに従って日付文字列を解析
	parsedDate, err := time.Parse(layout, dateStr)
	if err != nil {
		fmt.Println("日付解析エラー:", err)
		return
	}
	
	// 解析された日付を出力
	fmt.Println("解析された日付:", parsedDate)
}
```

このコードを実行すると、次のようになります：

```
解析された日付: 2023-04-12 14:45:00 +0000 UTC
```

`layout`文字列が基準日の値を使用して入力文字列の形式を指定する方法に注目してください。入力日付の形式に一致するように`layout`を調整してください。

## 深堀り
Goの日付と時間の解析の設計は独特で、特定の基準日（`Mon Jan 2 15:04:05 MST 2006`）を利用しています。このアプローチは、より従来の形式指定子（例えば`YYYY`年）を使用するのではなく、読みやすさと使いやすさのために選ばれました。これは、より具体例に基づいた形式を利用しています。

他の言語に慣れたプログラマーにとっては当初奇妙に見えるかもしれませんが、多くの人が少しの調整期間の後に、より直感的に見えると感じています。Goの`time`パッケージで直接サポートされていないより複雑な日付操作や形式が必要なアプリケーションの場合、`github.com/jinzhu/now`などのサードパーティライブラリーが追加機能を提供できます。しかし、標準的なアプリケーションの大多数に対して、Goの組み込みの機能は堅牢で、高性能で、慣用的であり、単純明快というGoの哲学を体現しています。
