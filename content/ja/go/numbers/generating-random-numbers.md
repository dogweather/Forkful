---
title:                "乱数の生成"
aliases:
- /ja/go/generating-random-numbers/
date:                  2024-02-03T17:57:45.296725-07:00
model:                 gpt-4-0125-preview
simple_title:         "乱数の生成"
tag:                  "Numbers"
editURL:              "https://github.com/dogweather/forkful/blob/master/content/ja/go/generating-random-numbers.md"
changelog:
  - 2024-02-03, gpt-4-0125-preview, translated from English
---

{{< edit_this_page >}}

## 何となぜ？

プログラミングにおいて乱数を生成するとは、偶然よりも合理的に予測できない数列を作り出すことを指します。プログラマーは、シミュレーション、ゲーム、セキュリティアプリケーションなど、予測不可能性が機能性や秘密性に重要な役割を果たす様々な理由でこれを行います。

## 方法：

Goにおいて、乱数は擬似乱数の場合は`math/rand`パッケージを使って、暗号学的に安全な擬似乱数の場合は`crypto/rand`を使って生成されます。両方について探求しましょう。

### 擬似乱数のための`math/rand`の使用

まず、ジェネレーターをシードするために`math/rand`パッケージと`time`パッケージをインポートします。シードすることで、実行ごとに異なる数列を得ることができます。

```go
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func main() {
	rand.Seed(time.Now().UnixNano())
	fmt.Println("A random number:", rand.Intn(100)) // 0から99の間の数を生成
}
```

サンプル出力：`A random number: 42`

### 暗号学的に安全な擬似乱数のための`crypto/rand`の使用

よりセキュリティに敏感なアプリケーションのためには、予測が困難な乱数を生成し、暗号操作に適しているため、`crypto/rand`パッケージが適しています。

```go
package main

import (
	"crypto/rand"
	"fmt"
	"math/big"
)

func main() {
	n, _ := rand.Int(rand.Reader, big.NewInt(100))
	fmt.Println("A secure random number:", n)
}
```

サンプル出力：`A secure random number: 81`

## 深堀り

`math/rand`と`crypto/rand`パッケージの根本的な違いは、エントロピーの源とそれぞれの使用目的にあります。`math/rand`は初期シードに基づいて擬似乱数を生成するため、その数列は決定論的であり、シードが知れてしまえば予測可能です。これは、シミュレーションやゲームのように、絶対的な予測不可能性ではなく高性能が重要視されるシナリオに適しています。

一方で、`crypto/rand`は基盤となるオペレーティングシステムからランダム性を導出し、予測不可能性が重要である暗号化用途に適しています。しかし、これは性能や、生成される数値（整数の場合は`*big.Int`型など）を扱う複雑さを犠牲にしています。

歴史的に、コンピューターにおける乱数生成の概念は常に真の「ランダム性」の縁で踊ってきました。早期のシステムはランダム性を模倣した決定論的アルゴリズムに大きく依存していました。コンピューターが進化するにつれて、これらのアルゴリズムも、環境からのより洗練されたエントロピー源を取り入れ、進化してきました。

これらの進展にもかかわらず、コンピューター自体の決定論的な性質を考えると、計算における完璧なランダム性を追求することは本質的に矛盾しています。これが、`crypto/rand`のようなソースからの暗号学的に安全な擬似ランダム数が、そのオーバーヘッドにもかかわらず、予測可能性が有害であるほとんどのアプリケーションにとってより良い選択肢である理由です。

要するに、Goの乱数生成に対する二つの独立したパッケージのアプローチは、性能とセキュリティの間の妥協を巧みに対処し、開発者がその特定のニーズに基づいて選択できるようにしています。
