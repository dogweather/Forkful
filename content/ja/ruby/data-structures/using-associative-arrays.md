---
aliases:
- /ja/ruby/using-associative-arrays/
changelog:
- 2024-01-30, gpt-4-0125-preview, translated from English
date: 2024-01-30 19:13:02.705895-07:00
description: "\u9023\u60F3\u914D\u5217\u306F\u3001Ruby\u3067\u306F\u4E00\u822C\u306B\
  \u30CF\u30C3\u30B7\u30E5\u3068\u3057\u3066\u77E5\u3089\u308C\u3066\u304A\u308A\u3001\
  \u4E00\u610F\u306E\u30AD\u30FC\u3068\u5024\u3092\u30DA\u30A2\u30EA\u30F3\u30B0\u3059\
  \u308B\u3053\u3068\u304C\u3067\u304D\u307E\u3059\u3002\u7279\u5B9A\u306E\u53C2\u7167\
  \u3092\u901A\u3058\u3066\u8981\u7D20\u3092\u8FFD\u8DE1\u3059\u308B\u5FC5\u8981\u304C\
  \u3042\u308B\u5834\u5408\u3084\u3001\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\u306E\u30D7\
  \u30ED\u30D1\u30C6\u30A3\u3092\u4FDD\u5B58\u3057\u305F\u308A\u3001\u4E00\u610F\u306E\
  \u8B58\u5225\u5B50\u3067\u30C7\u30FC\u30BF\u306B\u3059\u3050\u306B\u30A2\u30AF\u30BB\
  \u30B9\u3057\u305F\u308A\u3059\u308B\u5834\u5408\u306A\u3069\u3001\u4E0D\u53EF\u6B20\
  \u306A\u30C4\u30FC\u30EB\u3067\u3059\u3002"
lastmod: 2024-02-18 23:08:55.382485
model: gpt-4-0125-preview
summary: "\u9023\u60F3\u914D\u5217\u306F\u3001Ruby\u3067\u306F\u4E00\u822C\u306B\u30CF\
  \u30C3\u30B7\u30E5\u3068\u3057\u3066\u77E5\u3089\u308C\u3066\u304A\u308A\u3001\u4E00\
  \u610F\u306E\u30AD\u30FC\u3068\u5024\u3092\u30DA\u30A2\u30EA\u30F3\u30B0\u3059\u308B\
  \u3053\u3068\u304C\u3067\u304D\u307E\u3059\u3002\u7279\u5B9A\u306E\u53C2\u7167\u3092\
  \u901A\u3058\u3066\u8981\u7D20\u3092\u8FFD\u8DE1\u3059\u308B\u5FC5\u8981\u304C\u3042\
  \u308B\u5834\u5408\u3084\u3001\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\u306E\u30D7\u30ED\
  \u30D1\u30C6\u30A3\u3092\u4FDD\u5B58\u3057\u305F\u308A\u3001\u4E00\u610F\u306E\u8B58\
  \u5225\u5B50\u3067\u30C7\u30FC\u30BF\u306B\u3059\u3050\u306B\u30A2\u30AF\u30BB\u30B9\
  \u3057\u305F\u308A\u3059\u308B\u5834\u5408\u306A\u3069\u3001\u4E0D\u53EF\u6B20\u306A\
  \u30C4\u30FC\u30EB\u3067\u3059\u3002"
title: "\u9023\u60F3\u914D\u5217\u306E\u4F7F\u7528"
---

{{< edit_this_page >}}

## 何となぜ？

連想配列は、Rubyでは一般にハッシュとして知られており、一意のキーと値をペアリングすることができます。特定の参照を通じて要素を追跡する必要がある場合や、オブジェクトのプロパティを保存したり、一意の識別子でデータにすぐにアクセスしたりする場合など、不可欠なツールです。

## 使い方：

Rubyでのハッシュの作成と使用は簡単です。空のハッシュを初期化して、キーと値のペアで埋めたり、キーで値にアクセスしたりなど、様々な操作ができます。以下のように行います：

```Ruby
# ハッシュを作成する
my_hash = { "name" => "John Doe", "age" => 30 }

# ハッシュを作る別の方法
another_hash = Hash.new
another_hash["position"] = "Developer"

# ハッシュの値にアクセスする
puts my_hash["name"] # 出力: John Doe

# 新しいキーと値のペアを追加する
my_hash["language"] = "Ruby"
puts my_hash # 出力: {"name"=>"John Doe", "age"=>30, "language"=>"Ruby"}

# ハッシュをイテレートする
my_hash.each do |key, value|
  puts "#{key}: #{value}"
end
# 出力:
# name: John Doe
# age: 30
# language: Ruby
```

効率的なキーとしてシンボルを使用することもできます：

```Ruby
# キーにシンボルを使用する
symbol_hash = { name: "Jane Doe", age: 22 }
puts symbol_hash[:name] # 出力: Jane Doe
```

## 深掘り：

連想配列の概念はRubyに特有のものではなく、多くの言語がそれを実装しています。Pythonの辞書やJavaScriptのオブジェクト（キーと値のペアとして使用される場合）など、さまざまな名称で実装されています。Rubyの初期段階では、ハッシュはやや遅く、多様性に欠けていました。しかし、時間が経つにつれて、Rubyのハッシュの実装は特にシンボルキーで非常に最適化され、頻繁なアクセスと更新のために非常に効率的になりました。

Rubyのハッシュは、その構文の使いやすさと柔軟性で際立っています - ほぼ任意のオブジェクトタイプをキーとして使用することができますが、シンボルと文字列が最も一般的です。内部的には、Rubyのハッシュは、要素の数が増えてもスピードとメモリ効率のバランスを保つハッシングアルゴリズムを使用して実装されています。

ハッシュは非常に多目的ですが、Rubyでのデータストレージにおいて万能な解決策ではありません。順序付けられたコレクションには配列がより適しており、一意のアイテムのセットにはSetがより良い選択かもしれません。さらに、非常に複雑なデータ構造には、カスタムクラスを作成することが推奨されます。

ハッシュを使用するか他のデータ構造を使用するかの選択は、主に特定のユースケースに依存します。ハッシュは、高速な検索と一意のキーとその値の間の関連性を保持することに優れています。
