---
aliases:
- /ja/kotlin/using-associative-arrays/
changelog:
- 2024-01-30, gpt-4-0125-preview, translated from English
date: 2024-01-30 19:12:34.527827-07:00
description: "Kotlin\u306B\u304A\u3051\u308B\u9023\u60F3\u914D\u5217\u3001\u307E\u305F\
  \u306F\u30DE\u30C3\u30D7\u306F\u3001\u30AD\u30FC\u5024\u30DA\u30A2\u3092\u683C\u7D0D\
  \u3059\u308B\u30B3\u30EC\u30AF\u30B7\u30E7\u30F3\u3067\u3059\u3002\u30D7\u30ED\u30B0\
  \u30E9\u30DE\u30FC\u306F\u3053\u308C\u3092\u4F7F\u3063\u3066\u3001\u30E6\u30CB\u30FC\
  \u30AF\u306A\u30AD\u30FC\u306B\u57FA\u3065\u3044\u3066\u30C7\u30FC\u30BF\u3092\u52B9\
  \u7387\u7684\u306B\u6574\u7406\u3057\u3001\u53D6\u5F97\u3059\u308B\u305F\u3081\u306B\
  \u4F7F\u7528\u3057\u3001\u60C5\u5831\u3092\u7BA1\u7406\u3057\u3084\u3059\u304F\u3057\
  \u307E\u3059\u3002"
lastmod: 2024-02-18 23:08:54.872745
model: gpt-4-0125-preview
summary: "Kotlin\u306B\u304A\u3051\u308B\u9023\u60F3\u914D\u5217\u3001\u307E\u305F\
  \u306F\u30DE\u30C3\u30D7\u306F\u3001\u30AD\u30FC\u5024\u30DA\u30A2\u3092\u683C\u7D0D\
  \u3059\u308B\u30B3\u30EC\u30AF\u30B7\u30E7\u30F3\u3067\u3059\u3002\u30D7\u30ED\u30B0\
  \u30E9\u30DE\u30FC\u306F\u3053\u308C\u3092\u4F7F\u3063\u3066\u3001\u30E6\u30CB\u30FC\
  \u30AF\u306A\u30AD\u30FC\u306B\u57FA\u3065\u3044\u3066\u30C7\u30FC\u30BF\u3092\u52B9\
  \u7387\u7684\u306B\u6574\u7406\u3057\u3001\u53D6\u5F97\u3059\u308B\u305F\u3081\u306B\
  \u4F7F\u7528\u3057\u3001\u60C5\u5831\u3092\u7BA1\u7406\u3057\u3084\u3059\u304F\u3057\
  \u307E\u3059\u3002"
title: "\u9023\u60F3\u914D\u5217\u306E\u4F7F\u7528"
---

{{< edit_this_page >}}

## 何となく理由

Kotlinにおける連想配列、またはマップは、キー値ペアを格納するコレクションです。プログラマーはこれを使って、ユニークなキーに基づいてデータを効率的に整理し、取得するために使用し、情報を管理しやすくします。

## 方法

Kotlinでマップを作成して使うのは簡単です。以下にその方法を簡単に説明します：

```Kotlin
fun main() {
    // 可変マップの作成
    val fruits = mutableMapOf("a" to "Apple", "b" to "Banana")

    // 要素の追加
    fruits["o"] = "Orange" // インデックス操作を使用
    fruits.put("g", "Grape") // putメソッドを使用

    // 要素へのアクセス
    println(fruits["a"])  // 出力: Apple
    println(fruits["b"])  // 出力: Banana

    // 要素の削除
    fruits.remove("b")
    
    // マップの繰り返し処理
    for ((key, value) in fruits) {
        println("$key -> $value")
    }
    // サンプル出力：
    // a -> Apple
    // o -> Orange
    // g -> Grape
}
```

## より深く

Kotlinのマップは、Javaとの相互運用性から直接来ており、Javaではマップがコレクションの重要な部分を占めています。しかし、Kotlinは可変（`MutableMap`）と読み取り専用（`Map`）のインターフェースを提供することで、その使い勝手を向上させています。これは、Javaの統一された`Map`インターフェースとは異なります。この区別は、コレクションが変更を意図しているかどうかを明確にします。

Kotlinのマップ実装に関する重要な詳細は、可変マップと不変マップとの明確な区別であり、これは言語の不変性とスレッドセーフティに焦点を当てていることを強調しています。

マップは非常に有用ですが、Kotlinはリストやセットなど、固有のユースケースを持つ他のコレクションも提供しています。たとえば、リストは順序を保持し、重複を許可することで、インデックスによる要素へのアクセスに理想的です。一方、セットは一意性を保証しますが、順序を保ちません。マップ、リスト、セットを使用するかどうかは、アプリケーションの特定の要件、つまりキーに基づくアクセスや順序保存の必要性によって異なります。

もっと良い代替品について言えば、特に大規模なコレクションでパフォーマンスが重要な場合は、特定のユースケース、例えば並列アクセスやソートに最適化された外部ライブラリが提供する、より効率的な専門的なデータ構造を使用することを検討してください。
